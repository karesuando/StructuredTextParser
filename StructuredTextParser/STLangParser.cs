// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, John Gough, QUT 2005-2014
// (see accompanying GPPGcopyright.rtf)

// GPPG version 1.5.2
// Machine:  DESKTOP-N9PK5LB
// DateTime: 2022-06-04 17:39:20
// UserName: cyber
// Input file <stlang.y - 2022-06-04 17:38:42>

// options: lines gplex

using System;
using System.Collections.Generic;
using System.CodeDom.Compiler;
using System.Globalization;
using System.Text;
using QUT.Gppg;
using System.Linq;
using System.Collections;
using STLang.Symbols;
using STLang.Scanner;
using STLang.Subranges;
using STLang.DataTypes;
using STLang.Statements;
using STLang.Extensions;
using STLang.Expressions;
using STLang.SymbolTable;
using STLang.ErrorManager;
using STLang.MemoryLayout;
using STLang.ParserUtility;
using STLang.VMInstructions;
using STLang.ConstantTokens;
using STLang.AttributeStack;
using STLang.POUDefinitions;
using STLang.ByteCodegenerator;
using STLang.ConstantPoolHandler;
using STLang.ImplDependentParams;
using StructuredTextParser.Properties;
using STLang.RuntimeWrapper;

namespace STLang.Parser
{
public enum Tokens {error=95,EOF=96,
    WHILE=97,REPEAT=98,UNTIL=99,FOR=100,IF=101,TO=102,
    DO=103,THEN=104,ELSE=105,CASE=106,END_CASE=107,ELSIF=108,
    END_FOR=109,END_WHILE=110,END_IF=111,END_REPEAT=112,EXIT=113,BY=114,
    ASSIGN=115,OUTPUT_ASSIGN=116,PROGRAM=117,END_PROGRAM=118,ARRAY=119,OF=120,
    STRUCT=121,END_STRUCT=122,FUNCTION=123,END_FUNCTION=124,FUNCTION_BLOCK=125,END_FUNCTION_BLOCK=126,
    TYPE=127,END_TYPE=128,INT=129,SINT=130,DINT=131,LINT=132,
    USINT=133,UINT=134,UDINT=135,ULINT=136,REAL=137,LREAL=138,
    DATE=139,TIME=140,TIME_OF_DAY=141,TOD=142,DATE_AND_TIME=143,DT=144,
    STRING=145,WSTRING=146,BOOL=147,BYTE=148,CHAR=149,WCHAR=150,
    WORD=151,DWORD=152,LWORD=153,DOTDOT=154,ANY=155,ANY_INT=156,
    ANY_DERIVED=157,ANY_ELEMENTARY=158,ANY_MAGNITUDE=159,ANY_STRING=160,ANY_REAL=161,ANY_BIT=162,
    ANY_NUM=163,ANY_DATE=164,R_EDGE=165,F_EDGE=166,VAR=167,VAR_INPUT=168,
    VAR_OUTPUT=169,VAR_IN_OUT=170,VAR_EXTERNAL=171,AT=172,VAR_GLOBAL=173,VAR_TEMP=174,
    VAR_ACCESS=175,VAR_CONFIG=176,END_VAR=177,CONSTANT=178,RETAIN=179,NON_RETAIN=180,
    TRUE=181,FALSE=182,RETURN=183,READ_ONLY=184,WRITE_ONLY=185,READ_WRITE=186,
    DUMMY_TOKEN=187,CONFIGURATION=188,END_CONFIGURATION=189,INITIAL_STEP=190,END_STEP=191,RESOURCE=192,
    END_RESOURCE=193,WITH=194,TASK=195,TRANSITION=196,END_TRANSITION=197,WHEN=198,
    INT_LIT=199,REAL_LIT=200,TYPED_INT=201,TYPED_REAL=202,TYPED_ENUM=203,DATE_LIT=204,
    DT_LIT=205,TIME_LIT=206,TOD_LIT=207,STRING_LIT=208,WSTRING_LIT=209,IDENT=210,
    DIRECT_VAR=211,IOR=212,XOR=213,AND=214,NEQ=215,GEQ=216,
    LEQ=217,MOD=218,UMINUS=219,NOT=220,POW=221};

public partial struct ValueType
#line 29 "stlang.y"
{
	public Tokens Token;
	public string Ident;
	public TokenInt LInt;
	public TokenDate Date;
	public TokenTime Time;
	public TokenDouble LReal;
	public TokenTOD TimeOfDay;
	public TokenDateTime DateTime;
	public TokenTypedInt TypedInt;
	public TokenTypedReal TypedReal;
	public TokenTypedEnum TypedEnum;
	public TokenDirectVar DirectVar;
	public SubRange Subrange;
	public string String;
	public object Object;
	public Statement Stat;
	public StatementList StatList;
	public DeclarationStatement Declaration;
	public POUVarDeclarations POUVariableDecls;
	public Expression Expression;
	public List<object> GenericList;
	public VarDeclStatement VarInitDecl;
	public List<VarDeclStatement> POUVarDecl;
	public CaseLabel CaseLabel;
	public List<SubRange> Subranges;
	public List<string> IdentifierList;
	public List<CaseLabel> CaseLabelList;
	public List<CaseElement> CaseElementList;
	public InitializerList InitList;
	public STVarType VarType;
	public STVarQualifier VarQualifier;
	public STDeclQualifier EdgeQualifier;
	public TypeNode DataType; 
	public ForLoopData ForList; 
	public DataTypeSpec TypeSpec;
	public POUParameter POUParameter;
	public StructDeclaration StructDecl;
	public StructMemberDeclaration MemberDecl;
	public ProgramOrganizationUnitCall POU;
	public IndexedVariable IndexedVariable;
}
#line default
// Abstract base class for GPLEX scanners
[GeneratedCodeAttribute( "Gardens Point Parser Generator", "1.5.2")]
public abstract class ScanBase : AbstractScanner<ValueType,LexLocation> {
  private LexLocation __yylloc = new LexLocation();
  public override LexLocation yylloc { get { return __yylloc; } set { __yylloc = value; } }
  protected virtual bool yywrap() { return true; }
}

// Utility class for encapsulating token information
[GeneratedCodeAttribute( "Gardens Point Parser Generator", "1.5.2")]
public class ScanObj {
  public int token;
  public ValueType yylval;
  public LexLocation yylloc;
  public ScanObj( int t, ValueType val, LexLocation loc ) {
    this.token = t; this.yylval = val; this.yylloc = loc;
  }
}

[GeneratedCodeAttribute( "Gardens Point Parser Generator", "1.5.2")]
public partial class STLangParser: ShiftReduceParser<ValueType, LexLocation>
{
#pragma warning disable 649
  private static Dictionary<int, string> aliases;
#pragma warning restore 649
  private static Rule[] rules = new Rule[403];
  private static State[] states = new State[609];
  private static string[] nonTerms = new string[] {
      "subrange", "statement_list", "opt_else_stat", "while_statement_body", 
      "for_statement_body", "default_statement", "function_body", "function_block_body", 
      "program_body", "case_stat_list", "var_init_decl", "var_declaration", "var_decl_list", 
      "elsif_stat", "opt_elsif_stat", "case_element_list", "case_elem_list", 
      "identifier_list", "enum_ident_seq", "case_label_list", "array_init_list", 
      "array_init_seq", "struct_init_list", "struct_init_seq", "initializer_seq", 
      "statement", "assignment_stat", "repeat_statement_body", "case_label", 
      "subrange_list", "struct_member_decls", "struct_member_decl", "case_element", 
      "function_decl", "elementary_type", "array_type", "structure_type", "subrange_type", 
      "enumerated_type", "derived_type", "non_generic_type", "string_type", "data_type", 
      "generic_type", "expression", "constant", "condition_DO", "condition_THEN", 
      "expression_OF", "variable", "simple_variable", "symbolic_variable", "initial_value", 
      "until_condition", "control_variable", "optional_by_stat", "initializer", 
      "var_decl", "temp_var_decl", "extern_var_decl", "global_var_decl", "access_var_decl", 
      "config_var_decl", "input_var_decl", "output_var_decl", "inout_var_decl", 
      "data_type_decl", "pou_variable_decl", "pou_call_sequence", "prog_org_unit_call", 
      "pou_parameter", "pou_variable_decls", "pou_var_decl_list", "indexed_variable", 
      "for_list_DO", "data_type_spec", "opt_var_qualifier", "opt_decl_qualifier", 
      "enum_identifier", "reserved_word", "assign", "main", "$accept", "Anon@1", 
      "pou_declarations", "pou_declaration", "function_block_decl", "program_decl", 
      "Anon@2", "Anon@3", "semicolon", "Anon@4", "Anon@5", "Anon@6", "Anon@7", 
      "Anon@8", "Anon@9", "type_decl_list", "Anon@10", "type_decl", "Anon@11", 
      "Anon@12", "Anon@13", "Anon@14", "Anon@15", "Anon@16", "Anon@17", "Anon@18", 
      "Anon@19", "Anon@20", "Anon@21", "Anon@22", "Anon@23", "Anon@24", "Anon@25", 
      "Anon@26", "Anon@27", "Anon@28", "Anon@29", "Anon@30", "Anon@31", "Anon@32", 
      "Anon@33", "Anon@34", "Anon@35", "Anon@36", "Anon@37", };

  static STLangParser() {
    states[0] = new State(-2,new int[]{-82,1,-84,3});
    states[1] = new State(new int[]{96,2});
    states[2] = new State(-1);
    states[3] = new State(new int[]{123,7,125,587,117,598,127,570},new int[]{-85,4,-86,608,-34,6,-87,586,-88,597,-67,607});
    states[4] = new State(new int[]{123,7,125,587,117,598,127,570,96,-3},new int[]{-86,5,-34,6,-87,586,-88,597,-67,607});
    states[5] = new State(-5);
    states[6] = new State(-6);
    states[7] = new State(new int[]{210,8});
    states[8] = new State(new int[]{58,9});
    states[9] = new State(new int[]{130,317,129,318,131,319,132,320,133,321,134,322,135,323,136,324,137,325,138,326,139,327,141,328,142,329,143,330,144,331,140,332,147,333,148,334,151,335,152,336,153,337,150,338,149,339,210,349,145,351,146,355},new int[]{-41,10,-35,347,-40,348,-42,350});
    states[10] = new State(-267,new int[]{-111,11});
    states[11] = new State(new int[]{167,251,174,514,171,521,173,528,175,535,176,542,168,549,169,556,170,563,127,570,95,-315,97,-315,98,-315,101,-315,100,-315,106,-315,210,-315,211,-315,113,-315,183,-315,59,-315},new int[]{-72,12,-73,248,-68,585,-58,250,-59,513,-60,520,-61,527,-62,534,-63,541,-64,548,-65,555,-66,562,-67,569});
    states[12] = new State(-268,new int[]{-112,13});
    states[13] = new State(new int[]{95,232,97,-185,98,-185,101,-185,100,-185,106,-185,210,-185,211,-185,113,-185,183,-185,59,-185},new int[]{-7,14,-2,15,-103,201});
    states[14] = new State(-269);
    states[15] = new State(new int[]{124,16,95,19,97,21,98,28,101,135,100,144,106,154,210,81,211,125,113,172,183,173,59,-202},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[16] = new State(-261);
    states[17] = new State(new int[]{59,18});
    states[18] = new State(-187);
    states[19] = new State(new int[]{124,20});
    states[20] = new State(-262);
    states[21] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,95,246},new int[]{-47,22,-45,244,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[22] = new State(new int[]{95,242,97,-185,98,-185,101,-185,100,-185,106,-185,210,-185,211,-185,113,-185,183,-185,59,-185},new int[]{-4,23,-2,24,-103,201});
    states[23] = new State(-189);
    states[24] = new State(new int[]{110,25,95,26,97,21,98,28,101,135,100,144,106,154,210,81,211,125,113,172,183,173,59,-202},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[25] = new State(-203);
    states[26] = new State(new int[]{110,27});
    states[27] = new State(-204);
    states[28] = new State(-190,new int[]{-104,29});
    states[29] = new State(new int[]{95,240,97,-185,98,-185,101,-185,100,-185,106,-185,210,-185,211,-185,113,-185,183,-185,59,-185},new int[]{-28,30,-2,31,-103,201});
    states[30] = new State(-191);
    states[31] = new State(new int[]{99,32,95,132,97,21,98,28,101,135,100,144,106,154,210,81,211,125,113,172,183,173,59,-202},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[32] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,95,130},new int[]{-54,33,-45,34,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[33] = new State(-206);
    states[34] = new State(new int[]{112,35,61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,59,-220});
    states[35] = new State(-218);
    states[36] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,37,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[37] = new State(new int[]{97,-155,60,38,62,40,95,-155,216,44,217,46,214,-155,212,-155,213,-155,221,54,218,56,38,-155,43,60,45,62,42,64,47,66,103,-155,98,-155,101,-155,100,-155,106,-155,210,-155,211,-155,113,-155,183,-155,59,-155,112,-155,41,-155,44,-155,93,-155,104,-155,102,-155,120,-155,198,-155,105,-155,107,-155,154,-155,58,-155,220,-155,40,-155,181,-155,182,-155,199,-155,200,-155,207,-155,206,-155,204,-155,205,-155,208,-155,209,-155,201,-155,202,-155,203,-155,114,-155,177,-155,172,-155,122,-155,128,-155});
    states[38] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,39,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[39] = new State(new int[]{61,-156,101,-156,98,-156,215,-156,97,-156,95,-156,214,-156,212,-156,213,-156,221,54,218,56,38,-156,43,60,45,62,42,64,47,66,103,-156,100,-156,106,-156,210,-156,211,-156,113,-156,183,-156,59,-156,112,-156,41,-156,44,-156,93,-156,104,-156,102,-156,120,-156,198,-156,105,-156,107,-156,154,-156,58,-156,220,-156,40,-156,181,-156,182,-156,199,-156,200,-156,207,-156,206,-156,204,-156,205,-156,208,-156,209,-156,201,-156,202,-156,203,-156,114,-156,177,-156,172,-156,122,-156,128,-156});
    states[40] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,41,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[41] = new State(new int[]{61,-157,101,-157,98,-157,215,-157,97,-157,95,-157,214,-157,212,-157,213,-157,221,54,218,56,38,-157,43,60,45,62,42,64,47,66,103,-157,100,-157,106,-157,210,-157,211,-157,113,-157,183,-157,59,-157,112,-157,41,-157,44,-157,93,-157,104,-157,102,-157,120,-157,198,-157,105,-157,107,-157,154,-157,58,-157,220,-157,40,-157,181,-157,182,-157,199,-157,200,-157,207,-157,206,-157,204,-157,205,-157,208,-157,209,-157,201,-157,202,-157,203,-157,114,-157,177,-157,172,-157,122,-157,128,-157});
    states[42] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,43,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[43] = new State(new int[]{97,-158,60,38,62,40,95,-158,216,44,217,46,214,-158,212,-158,213,-158,221,54,218,56,38,-158,43,60,45,62,42,64,47,66,103,-158,98,-158,101,-158,100,-158,106,-158,210,-158,211,-158,113,-158,183,-158,59,-158,112,-158,41,-158,44,-158,93,-158,104,-158,102,-158,120,-158,198,-158,105,-158,107,-158,154,-158,58,-158,220,-158,40,-158,181,-158,182,-158,199,-158,200,-158,207,-158,206,-158,204,-158,205,-158,208,-158,209,-158,201,-158,202,-158,203,-158,114,-158,177,-158,172,-158,122,-158,128,-158});
    states[44] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,45,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[45] = new State(new int[]{61,-159,101,-159,98,-159,215,-159,97,-159,95,-159,214,-159,212,-159,213,-159,221,54,218,56,38,-159,43,60,45,62,42,64,47,66,103,-159,100,-159,106,-159,210,-159,211,-159,113,-159,183,-159,59,-159,112,-159,41,-159,44,-159,93,-159,104,-159,102,-159,120,-159,198,-159,105,-159,107,-159,154,-159,58,-159,220,-159,40,-159,181,-159,182,-159,199,-159,200,-159,207,-159,206,-159,204,-159,205,-159,208,-159,209,-159,201,-159,202,-159,203,-159,114,-159,177,-159,172,-159,122,-159,128,-159});
    states[46] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,47,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[47] = new State(new int[]{61,-160,101,-160,98,-160,215,-160,97,-160,95,-160,214,-160,212,-160,213,-160,221,54,218,56,38,-160,43,60,45,62,42,64,47,66,103,-160,100,-160,106,-160,210,-160,211,-160,113,-160,183,-160,59,-160,112,-160,41,-160,44,-160,93,-160,104,-160,102,-160,120,-160,198,-160,105,-160,107,-160,154,-160,58,-160,220,-160,40,-160,181,-160,182,-160,199,-160,200,-160,207,-160,206,-160,204,-160,205,-160,208,-160,209,-160,201,-160,202,-160,203,-160,114,-160,177,-160,172,-160,122,-160,128,-160});
    states[48] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,49,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[49] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,-161,212,-161,213,-161,221,54,218,56,38,-161,43,60,45,62,42,64,47,66,103,-161,95,-161,97,-161,98,-161,101,-161,100,-161,106,-161,210,-161,211,-161,113,-161,183,-161,59,-161,112,-161,41,-161,44,-161,93,-161,104,-161,102,-161,120,-161,198,-161,105,-161,107,-161,154,-161,58,-161,220,-161,40,-161,181,-161,182,-161,199,-161,200,-161,207,-161,206,-161,204,-161,205,-161,208,-161,209,-161,201,-161,202,-161,203,-161,114,-161,177,-161,172,-161,122,-161,128,-161});
    states[50] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,51,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[51] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,-162,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,103,-162,95,-162,97,-162,98,-162,101,-162,100,-162,106,-162,210,-162,211,-162,113,-162,183,-162,59,-162,112,-162,41,-162,44,-162,93,-162,104,-162,102,-162,120,-162,198,-162,105,-162,107,-162,154,-162,58,-162,220,-162,40,-162,181,-162,182,-162,199,-162,200,-162,207,-162,206,-162,204,-162,205,-162,208,-162,209,-162,201,-162,202,-162,203,-162,114,-162,177,-162,172,-162,122,-162,128,-162});
    states[52] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,53,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[53] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,-163,213,-163,221,54,218,56,38,58,43,60,45,62,42,64,47,66,103,-163,95,-163,97,-163,98,-163,101,-163,100,-163,106,-163,210,-163,211,-163,113,-163,183,-163,59,-163,112,-163,41,-163,44,-163,93,-163,104,-163,102,-163,120,-163,198,-163,105,-163,107,-163,154,-163,58,-163,220,-163,40,-163,181,-163,182,-163,199,-163,200,-163,207,-163,206,-163,204,-163,205,-163,208,-163,209,-163,201,-163,202,-163,203,-163,114,-163,177,-163,172,-163,122,-163,128,-163});
    states[54] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,55,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[55] = new State(new int[]{61,-164,60,-164,62,-164,215,-164,216,-164,217,-164,214,-164,212,-164,213,-164,221,54,218,-164,38,-164,43,-164,45,-164,42,-164,47,-164,103,-164,95,-164,97,-164,98,-164,101,-164,100,-164,106,-164,210,-164,211,-164,113,-164,183,-164,59,-164,112,-164,41,-164,44,-164,93,-164,104,-164,102,-164,120,-164,198,-164,105,-164,107,-164,154,-164,58,-164,220,-164,40,-164,181,-164,182,-164,199,-164,200,-164,207,-164,206,-164,204,-164,205,-164,208,-164,209,-164,201,-164,202,-164,203,-164,114,-164,177,-164,172,-164,122,-164,128,-164});
    states[56] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,57,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[57] = new State(new int[]{61,-165,60,-165,62,-165,215,-165,216,-165,217,-165,214,-165,212,-165,213,-165,221,54,218,-165,38,-165,43,-165,45,-165,42,-165,47,-165,103,-165,95,-165,97,-165,98,-165,101,-165,100,-165,106,-165,210,-165,211,-165,113,-165,183,-165,59,-165,112,-165,41,-165,44,-165,93,-165,104,-165,102,-165,120,-165,198,-165,105,-165,107,-165,154,-165,58,-165,220,-165,40,-165,181,-165,182,-165,199,-165,200,-165,207,-165,206,-165,204,-165,205,-165,208,-165,209,-165,201,-165,202,-165,203,-165,114,-165,177,-165,172,-165,122,-165,128,-165});
    states[58] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,59,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[59] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,-166,212,-166,213,-166,221,54,218,56,38,-166,43,60,45,62,42,64,47,66,103,-166,95,-166,97,-166,98,-166,101,-166,100,-166,106,-166,210,-166,211,-166,113,-166,183,-166,59,-166,112,-166,41,-166,44,-166,93,-166,104,-166,102,-166,120,-166,198,-166,105,-166,107,-166,154,-166,58,-166,220,-166,40,-166,181,-166,182,-166,199,-166,200,-166,207,-166,206,-166,204,-166,205,-166,208,-166,209,-166,201,-166,202,-166,203,-166,114,-166,177,-166,172,-166,122,-166,128,-166});
    states[60] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,61,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[61] = new State(new int[]{61,-167,60,-167,62,-167,215,-167,216,-167,217,-167,214,-167,212,-167,213,-167,221,54,218,56,38,-167,43,-167,45,-167,42,64,47,66,103,-167,95,-167,97,-167,98,-167,101,-167,100,-167,106,-167,210,-167,211,-167,113,-167,183,-167,59,-167,112,-167,41,-167,44,-167,93,-167,104,-167,102,-167,120,-167,198,-167,105,-167,107,-167,154,-167,58,-167,220,-167,40,-167,181,-167,182,-167,199,-167,200,-167,207,-167,206,-167,204,-167,205,-167,208,-167,209,-167,201,-167,202,-167,203,-167,114,-167,177,-167,172,-167,122,-167,128,-167});
    states[62] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,63,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[63] = new State(new int[]{61,-168,60,-168,62,-168,215,-168,216,-168,217,-168,214,-168,212,-168,213,-168,221,54,218,56,38,-168,43,-168,45,-168,42,64,47,66,103,-168,95,-168,97,-168,98,-168,101,-168,100,-168,106,-168,210,-168,211,-168,113,-168,183,-168,59,-168,112,-168,41,-168,44,-168,93,-168,104,-168,102,-168,120,-168,198,-168,105,-168,107,-168,154,-168,58,-168,220,-168,40,-168,181,-168,182,-168,199,-168,200,-168,207,-168,206,-168,204,-168,205,-168,208,-168,209,-168,201,-168,202,-168,203,-168,114,-168,177,-168,172,-168,122,-168,128,-168});
    states[64] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,65,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[65] = new State(new int[]{61,-169,60,-169,62,-169,215,-169,216,-169,217,-169,214,-169,212,-169,213,-169,221,54,218,-169,38,-169,43,-169,45,-169,42,-169,47,-169,103,-169,95,-169,97,-169,98,-169,101,-169,100,-169,106,-169,210,-169,211,-169,113,-169,183,-169,59,-169,112,-169,41,-169,44,-169,93,-169,104,-169,102,-169,120,-169,198,-169,105,-169,107,-169,154,-169,58,-169,220,-169,40,-169,181,-169,182,-169,199,-169,200,-169,207,-169,206,-169,204,-169,205,-169,208,-169,209,-169,201,-169,202,-169,203,-169,114,-169,177,-169,172,-169,122,-169,128,-169});
    states[66] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,67,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[67] = new State(new int[]{61,-170,60,-170,62,-170,215,-170,216,-170,217,-170,214,-170,212,-170,213,-170,221,54,218,-170,38,-170,43,-170,45,-170,42,-170,47,-170,103,-170,95,-170,97,-170,98,-170,101,-170,100,-170,106,-170,210,-170,211,-170,113,-170,183,-170,59,-170,112,-170,41,-170,44,-170,93,-170,104,-170,102,-170,120,-170,198,-170,105,-170,107,-170,154,-170,58,-170,220,-170,40,-170,181,-170,182,-170,199,-170,200,-170,207,-170,206,-170,204,-170,205,-170,208,-170,209,-170,201,-170,202,-170,203,-170,114,-170,177,-170,172,-170,122,-170,128,-170});
    states[68] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,69,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[69] = new State(new int[]{61,-152,60,-152,62,-152,215,-152,216,-152,217,-152,214,-152,212,-152,213,-152,221,54,218,-152,38,-152,43,-152,45,-152,42,-152,47,-152,103,-152,95,-152,97,-152,98,-152,101,-152,100,-152,106,-152,210,-152,211,-152,113,-152,183,-152,59,-152,112,-152,41,-152,44,-152,93,-152,104,-152,102,-152,120,-152,198,-152,105,-152,107,-152,154,-152,58,-152,220,-152,40,-152,181,-152,182,-152,199,-152,200,-152,207,-152,206,-152,204,-152,205,-152,208,-152,209,-152,201,-152,202,-152,203,-152,114,-152,177,-152,172,-152,122,-152,128,-152});
    states[70] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,71,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[71] = new State(new int[]{61,-153,60,-153,62,-153,215,-153,216,-153,217,-153,214,-153,212,-153,213,-153,221,54,218,-153,38,-153,43,-153,45,-153,42,-153,47,-153,103,-153,95,-153,97,-153,98,-153,101,-153,100,-153,106,-153,210,-153,211,-153,113,-153,183,-153,59,-153,112,-153,41,-153,44,-153,93,-153,104,-153,102,-153,120,-153,198,-153,105,-153,107,-153,154,-153,58,-153,220,-153,40,-153,181,-153,182,-153,199,-153,200,-153,207,-153,206,-153,204,-153,205,-153,208,-153,209,-153,201,-153,202,-153,203,-153,114,-153,177,-153,172,-153,122,-153,128,-153});
    states[72] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,73,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[73] = new State(new int[]{61,-154,60,-154,62,-154,215,-154,216,-154,217,-154,214,-154,212,-154,213,-154,221,54,218,-154,38,-154,43,-154,45,-154,42,-154,47,-154,103,-154,95,-154,97,-154,98,-154,101,-154,100,-154,106,-154,210,-154,211,-154,113,-154,183,-154,59,-154,112,-154,41,-154,44,-154,93,-154,104,-154,102,-154,120,-154,198,-154,105,-154,107,-154,154,-154,58,-154,220,-154,40,-154,181,-154,182,-154,199,-154,200,-154,207,-154,206,-154,204,-154,205,-154,208,-154,209,-154,201,-154,202,-154,203,-154,114,-154,177,-154,172,-154,122,-154,128,-154});
    states[74] = new State(new int[]{95,78,220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,75,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[75] = new State(new int[]{41,76,95,77,61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66});
    states[76] = new State(-171);
    states[77] = new State(-172);
    states[78] = new State(new int[]{41,79});
    states[79] = new State(-176);
    states[80] = new State(-173);
    states[81] = new State(new int[]{40,82,91,-150,46,-150,115,-150,61,-150,103,-150,60,-150,62,-150,215,-150,216,-150,217,-150,214,-150,212,-150,213,-150,221,-150,218,-150,38,-150,43,-150,45,-150,42,-150,47,-150,95,-150,97,-150,98,-150,101,-150,100,-150,106,-150,210,-150,211,-150,113,-150,183,-150,59,-150,112,-150,41,-150,44,-150,93,-150,104,-150,102,-150,120,-150,198,-150,105,-150,107,-150,154,-150,58,-150,220,-150,181,-150,182,-150,199,-150,200,-150,207,-150,206,-150,204,-150,205,-150,208,-150,209,-150,201,-150,202,-150,203,-150,114,-150,177,-150,172,-150,122,-150,128,-150});
    states[82] = new State(new int[]{41,83,95,84,220,88,45,70,43,72,40,74,210,96,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-71,86,-45,87,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[83] = new State(-182);
    states[84] = new State(new int[]{41,85});
    states[85] = new State(-183);
    states[86] = new State(-180);
    states[87] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,41,-177,44,-177});
    states[88] = new State(new int[]{210,89,220,68,45,70,43,72,40,74,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,69,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[89] = new State(new int[]{40,82,115,128,116,129,91,-150,46,-150,61,-150,60,-150,62,-150,215,-150,216,-150,217,-150,214,-150,212,-150,213,-150,221,-150,218,-150,38,-150,43,-150,45,-150,42,-150,47,-150,41,-150,44,-150},new int[]{-81,90});
    states[90] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,91,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[91] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,41,-179,44,-179});
    states[92] = new State(new int[]{41,93,44,94});
    states[93] = new State(-184);
    states[94] = new State(new int[]{220,88,45,70,43,72,40,74,210,96,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-71,95,-45,87,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[95] = new State(-181);
    states[96] = new State(new int[]{40,82,115,128,116,129,91,-150,46,-150,61,-150,60,-150,62,-150,215,-150,216,-150,217,-150,214,-150,212,-150,213,-150,221,-150,218,-150,38,-150,43,-150,45,-150,42,-150,47,-150,41,-150,44,-150},new int[]{-81,97});
    states[97] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,98,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[98] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,41,-178,44,-178});
    states[99] = new State(-174);
    states[100] = new State(-129);
    states[101] = new State(-130);
    states[102] = new State(-131);
    states[103] = new State(-132);
    states[104] = new State(-133);
    states[105] = new State(-134);
    states[106] = new State(-135);
    states[107] = new State(-136);
    states[108] = new State(-137);
    states[109] = new State(-138);
    states[110] = new State(-139);
    states[111] = new State(-140);
    states[112] = new State(-141);
    states[113] = new State(-175);
    states[114] = new State(new int[]{46,115,115,-142,61,-142,103,-142,60,-142,62,-142,215,-142,216,-142,217,-142,214,-142,212,-142,213,-142,221,-142,218,-142,38,-142,43,-142,45,-142,42,-142,47,-142,95,-142,97,-142,98,-142,101,-142,100,-142,106,-142,210,-142,211,-142,113,-142,183,-142,59,-142,112,-142,41,-142,44,-142,93,-142,104,-142,102,-142,120,-142,198,-142,105,-142,107,-142,154,-142,58,-142,220,-142,40,-142,181,-142,182,-142,199,-142,200,-142,207,-142,206,-142,204,-142,205,-142,208,-142,209,-142,201,-142,202,-142,203,-142,114,-142,177,-142,172,-142,122,-142,128,-142,116,-142});
    states[115] = new State(new int[]{210,116});
    states[116] = new State(-151);
    states[117] = new State(new int[]{91,118,46,-144,115,-144,61,-144,103,-144,60,-144,62,-144,215,-144,216,-144,217,-144,214,-144,212,-144,213,-144,221,-144,218,-144,38,-144,43,-144,45,-144,42,-144,47,-144,95,-144,97,-144,98,-144,101,-144,100,-144,106,-144,210,-144,211,-144,113,-144,183,-144,59,-144,112,-144,41,-144,44,-144,93,-144,104,-144,102,-144,120,-144,198,-144,105,-144,107,-144,154,-144,58,-144,220,-144,40,-144,181,-144,182,-144,199,-144,200,-144,207,-144,206,-144,204,-144,205,-144,208,-144,209,-144,201,-144,202,-144,203,-144,114,-144,177,-144,172,-144,122,-144,128,-144,116,-144});
    states[118] = new State(new int[]{95,126,220,-147,45,-147,43,-147,40,-147,210,-147,181,-147,182,-147,199,-147,200,-147,207,-147,206,-147,204,-147,205,-147,208,-147,209,-147,201,-147,202,-147,203,-147,211,-147},new int[]{-102,119});
    states[119] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,120,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[120] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,93,-148,44,-148});
    states[121] = new State(new int[]{93,122,44,123});
    states[122] = new State(-145);
    states[123] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,124,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[124] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,93,-149,44,-149});
    states[125] = new State(-143);
    states[126] = new State(new int[]{93,127});
    states[127] = new State(-146);
    states[128] = new State(-10);
    states[129] = new State(-11);
    states[130] = new State(new int[]{112,131});
    states[131] = new State(-219);
    states[132] = new State(new int[]{99,133});
    states[133] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,95,130},new int[]{-54,134,-45,34,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[134] = new State(-207);
    states[135] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,95,235},new int[]{-48,136,-45,233,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[136] = new State(new int[]{95,232,97,-185,98,-185,101,-185,100,-185,106,-185,210,-185,211,-185,113,-185,183,-185,59,-185},new int[]{-2,137,-103,201});
    states[137] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,210,81,211,125,113,172,183,173,108,-192,105,-192,111,-192,59,-202},new int[]{-105,138,-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[138] = new State(new int[]{108,237,105,-238,111,-238},new int[]{-15,139,-14,228});
    states[139] = new State(new int[]{105,142,111,-236},new int[]{-3,140});
    states[140] = new State(new int[]{111,141});
    states[141] = new State(-193);
    states[142] = new State(new int[]{95,227,97,-185,98,-185,101,-185,100,-185,106,-185,210,-185,211,-185,113,-185,183,-185,59,-185},new int[]{-2,143,-103,201});
    states[143] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,210,81,211,125,113,172,183,173,111,-234,59,-202},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[144] = new State(new int[]{210,226,211,125},new int[]{-55,145,-50,225,-52,114,-51,117,-74,121});
    states[145] = new State(new int[]{115,128,116,129},new int[]{-81,146});
    states[146] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,95,218},new int[]{-75,147,-45,207,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[147] = new State(-194,new int[]{-106,148});
    states[148] = new State(new int[]{95,204,97,-185,98,-185,101,-185,100,-185,106,-185,210,-185,211,-185,113,-185,183,-185,59,-185},new int[]{-5,149,-2,150,-103,201});
    states[149] = new State(-195);
    states[150] = new State(new int[]{109,151,95,152,97,21,98,28,101,135,100,144,106,154,210,81,211,125,113,172,183,173,59,-202},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[151] = new State(-209);
    states[152] = new State(new int[]{109,153});
    states[153] = new State(-210);
    states[154] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,95,199},new int[]{-49,155,-45,197,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[155] = new State(new int[]{198,160,105,193,107,-252},new int[]{-16,156,-17,158,-33,196,-6,192});
    states[156] = new State(new int[]{107,157});
    states[157] = new State(-196);
    states[158] = new State(new int[]{198,160,105,193,107,-251},new int[]{-33,159,-6,192});
    states[159] = new State(-250);
    states[160] = new State(new int[]{95,188,220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-20,161,-29,191,-45,184,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-1,187});
    states[161] = new State(new int[]{58,162,44,182,95,179,97,-241,98,-241,101,-241,100,-241,106,-241,210,-241,211,-241,113,-241,183,-241,59,-241},new int[]{-10,181,-110,176});
    states[162] = new State(new int[]{95,179,97,-241,98,-241,101,-241,100,-241,106,-241,210,-241,211,-241,113,-241,183,-241,59,-241},new int[]{-10,163,-110,176});
    states[163] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,210,81,211,125,113,172,183,173,198,-245,105,-245,107,-245,59,-202},new int[]{-26,164,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[164] = new State(new int[]{59,165});
    states[165] = new State(-243);
    states[166] = new State(-197);
    states[167] = new State(new int[]{115,168,61,170});
    states[168] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,169,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[169] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,59,-259});
    states[170] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,171,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[171] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,59,-260});
    states[172] = new State(-198);
    states[173] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,59,-199},new int[]{-45,174,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[174] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,59,-200});
    states[175] = new State(-201);
    states[176] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,210,81,211,125,113,172,183,173,59,-202},new int[]{-26,177,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[177] = new State(new int[]{59,178});
    states[178] = new State(-242);
    states[179] = new State(new int[]{59,180});
    states[180] = new State(-244);
    states[181] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,210,81,211,125,113,172,183,173,198,-247,105,-247,107,-247,59,-202},new int[]{-26,164,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[182] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-29,183,-45,184,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-1,187});
    states[183] = new State(-256);
    states[184] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,154,185,58,-253,44,-253,95,-253,97,-253,98,-253,101,-253,100,-253,106,-253,210,-253,211,-253,113,-253,183,-253,59,-253});
    states[185] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,186,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[186] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,58,-12,44,-12,95,-12,97,-12,98,-12,101,-12,100,-12,106,-12,210,-12,211,-12,113,-12,183,-12,59,-12,93,-12,220,-12,40,-12,181,-12,182,-12,199,-12,200,-12,207,-12,206,-12,204,-12,205,-12,208,-12,209,-12,201,-12,202,-12,203,-12,41,-12});
    states[187] = new State(-254);
    states[188] = new State(new int[]{58,189});
    states[189] = new State(new int[]{95,179,97,-241,98,-241,101,-241,100,-241,106,-241,210,-241,211,-241,113,-241,183,-241,59,-241},new int[]{-10,190,-110,176});
    states[190] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,210,81,211,125,113,172,183,173,198,-246,105,-246,107,-246,59,-202},new int[]{-26,164,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[191] = new State(-255);
    states[192] = new State(-248);
    states[193] = new State(new int[]{95,179,97,-241,98,-241,101,-241,100,-241,106,-241,210,-241,211,-241,113,-241,183,-241,59,-241},new int[]{-10,194,-110,176});
    states[194] = new State(new int[]{95,195,97,21,98,28,101,135,100,144,106,154,210,81,211,125,113,172,183,173,198,-239,105,-239,107,-239,59,-202},new int[]{-26,164,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[195] = new State(-240);
    states[196] = new State(-249);
    states[197] = new State(new int[]{120,198,61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,198,-223,105,-223,107,-223});
    states[198] = new State(-221);
    states[199] = new State(new int[]{120,200});
    states[200] = new State(-222);
    states[201] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,210,81,211,125,113,172,183,173,59,-202},new int[]{-26,202,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[202] = new State(new int[]{59,203});
    states[203] = new State(-186);
    states[204] = new State(new int[]{59,205,109,206});
    states[205] = new State(-188);
    states[206] = new State(-211);
    states[207] = new State(new int[]{102,208,61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66});
    states[208] = new State(new int[]{95,216,220,-225,45,-225,43,-225,40,-225,210,-225,181,-225,182,-225,199,-225,200,-225,207,-225,206,-225,204,-225,205,-225,208,-225,209,-225,201,-225,202,-225,203,-225,211,-225},new int[]{-107,209});
    states[209] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,210,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[210] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,114,213,103,-233},new int[]{-56,211});
    states[211] = new State(new int[]{103,212});
    states[212] = new State(-226);
    states[213] = new State(-231,new int[]{-109,214});
    states[214] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,215,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[215] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,103,-232});
    states[216] = new State(new int[]{103,217});
    states[217] = new State(-229);
    states[218] = new State(new int[]{102,219,103,224});
    states[219] = new State(-227,new int[]{-108,220});
    states[220] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,221,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[221] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,114,213,103,-233},new int[]{-56,222});
    states[222] = new State(new int[]{103,223});
    states[223] = new State(-228);
    states[224] = new State(-230);
    states[225] = new State(-224);
    states[226] = new State(-150);
    states[227] = new State(new int[]{59,205,111,-235});
    states[228] = new State(new int[]{108,229,105,-237,111,-237});
    states[229] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,95,235},new int[]{-48,230,-45,233,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[230] = new State(new int[]{95,232,97,-185,98,-185,101,-185,100,-185,106,-185,210,-185,211,-185,113,-185,183,-185,59,-185},new int[]{-2,231,-103,201});
    states[231] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,210,81,211,125,113,172,183,173,108,-258,105,-258,111,-258,59,-202},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[232] = new State(new int[]{59,205});
    states[233] = new State(new int[]{104,234,61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,95,-217,97,-217,98,-217,101,-217,100,-217,106,-217,210,-217,211,-217,113,-217,183,-217,59,-217});
    states[234] = new State(-215);
    states[235] = new State(new int[]{104,236});
    states[236] = new State(-216);
    states[237] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,95,235},new int[]{-48,238,-45,233,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[238] = new State(new int[]{95,232,97,-185,98,-185,101,-185,100,-185,106,-185,210,-185,211,-185,113,-185,183,-185,59,-185},new int[]{-2,239,-103,201});
    states[239] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,210,81,211,125,113,172,183,173,108,-257,105,-257,111,-257,59,-202},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[240] = new State(new int[]{59,205,112,241});
    states[241] = new State(-208);
    states[242] = new State(new int[]{59,205,110,243});
    states[243] = new State(-205);
    states[244] = new State(new int[]{103,245,61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,95,-214,97,-214,98,-214,101,-214,100,-214,106,-214,210,-214,211,-214,113,-214,183,-214,59,-214});
    states[245] = new State(-212);
    states[246] = new State(new int[]{103,247});
    states[247] = new State(-213);
    states[248] = new State(new int[]{167,251,174,514,171,521,173,528,175,535,176,542,168,549,169,556,170,563,127,570,95,-314,97,-314,98,-314,101,-314,100,-314,106,-314,210,-314,211,-314,113,-314,183,-314,59,-314},new int[]{-68,249,-58,250,-59,513,-60,520,-61,527,-62,534,-63,541,-64,548,-65,555,-66,562,-67,569});
    states[249] = new State(-313);
    states[250] = new State(-302);
    states[251] = new State(new int[]{95,506,179,508,180,510,178,511,210,-332,172,-332},new int[]{-77,252});
    states[252] = new State(-278,new int[]{-117,253});
    states[253] = new State(new int[]{210,493,172,499},new int[]{-12,254,-13,255,-11,504,-18,262});
    states[254] = new State(-279);
    states[255] = new State(new int[]{177,256,95,260,210,493,172,499},new int[]{-11,257,-18,262});
    states[256] = new State(-318);
    states[257] = new State(new int[]{59,259,177,-126,95,-126,210,-126,172,-126},new int[]{-91,258});
    states[258] = new State(-317);
    states[259] = new State(-125);
    states[260] = new State(new int[]{177,261});
    states[261] = new State(-319);
    states[262] = new State(new int[]{58,263,44,489,210,492});
    states[263] = new State(new int[]{130,317,129,318,131,319,132,320,133,321,134,322,135,323,136,324,137,325,138,326,139,327,141,328,142,329,143,330,144,331,140,332,147,333,148,334,151,335,152,336,153,337,150,338,149,339,119,341,121,383,40,465,210,349,145,351,146,355,155,479,163,480,156,481,161,482,162,483,164,484,157,485,158,486,159,487,160,488},new int[]{-43,264,-35,316,-36,340,-37,368,-31,369,-39,389,-19,390,-38,470,-41,471,-40,476,-42,477,-44,478});
    states[264] = new State(new int[]{165,312,166,313,184,314,185,315,115,-337,59,-337,177,-337,95,-337,210,-337,172,-337},new int[]{-78,265});
    states[265] = new State(new int[]{59,-320,177,-320,95,-320,210,-320,172,-320,115,-321},new int[]{-125,266});
    states[266] = new State(new int[]{115,267});
    states[267] = new State(new int[]{220,68,45,70,43,72,40,270,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,91,294},new int[]{-53,268,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[268] = new State(-322);
    states[269] = new State(new int[]{61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,59,-116,177,-116,95,-116,210,-116,172,-116,41,-116,44,-116,93,-116,122,-116,128,-116});
    states[270] = new State(new int[]{95,78,41,273,220,68,45,70,43,72,40,270,210,274,181,100,182,101,199,284,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,91,294},new int[]{-45,271,-57,272,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-53,283,-21,278,-22,279,-23,297,-24,298});
    states[271] = new State(new int[]{41,76,95,77,61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66,44,-116});
    states[272] = new State(-97);
    states[273] = new State(-105);
    states[274] = new State(new int[]{40,82,91,-150,46,-150,41,-150,95,-150,61,-150,60,-150,62,-150,215,-150,216,-150,217,-150,214,-150,212,-150,213,-150,221,-150,218,-150,38,-150,43,-150,45,-150,42,-150,47,-150,44,-150,93,-150,115,-111},new int[]{-97,275});
    states[275] = new State(new int[]{115,276});
    states[276] = new State(new int[]{220,68,45,70,43,72,40,270,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,91,294},new int[]{-53,277,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[277] = new State(-112);
    states[278] = new State(-117);
    states[279] = new State(new int[]{93,280,44,281,95,310});
    states[280] = new State(-99);
    states[281] = new State(new int[]{220,68,45,70,43,72,40,270,210,274,181,100,182,101,199,284,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,91,294},new int[]{-57,282,-53,283,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[282] = new State(-96);
    states[283] = new State(-106);
    states[284] = new State(new int[]{40,285,41,-131,95,-131,61,-131,60,-131,62,-131,215,-131,216,-131,217,-131,214,-131,212,-131,213,-131,221,-131,218,-131,38,-131,43,-131,45,-131,42,-131,47,-131,44,-131,93,-131});
    states[285] = new State(new int[]{95,-107,220,-109,45,-109,43,-109,40,-109,210,-109,181,-109,182,-109,199,-109,200,-109,207,-109,206,-109,204,-109,205,-109,208,-109,209,-109,201,-109,202,-109,203,-109,211,-109,91,-109},new int[]{-95,286,-96,289});
    states[286] = new State(new int[]{95,287});
    states[287] = new State(new int[]{41,288});
    states[288] = new State(-108);
    states[289] = new State(new int[]{220,68,45,70,43,72,40,270,210,274,181,100,182,101,199,284,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,91,294},new int[]{-25,290,-57,309,-53,283,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[290] = new State(new int[]{41,291,44,292,95,307});
    states[291] = new State(-110);
    states[292] = new State(new int[]{220,68,45,70,43,72,40,270,210,274,181,100,182,101,199,284,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,91,294},new int[]{-57,293,-53,283,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[293] = new State(-114);
    states[294] = new State(new int[]{95,304,93,306,220,-94,45,-94,43,-94,40,-94,210,-94,181,-94,182,-94,199,-94,200,-94,207,-94,206,-94,204,-94,205,-94,208,-94,209,-94,201,-94,202,-94,203,-94,211,-94,91,-94},new int[]{-94,295});
    states[295] = new State(new int[]{220,68,45,70,43,72,40,270,210,274,181,100,182,101,199,284,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,91,294},new int[]{-57,296,-53,283,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[296] = new State(-95);
    states[297] = new State(-118);
    states[298] = new State(new int[]{41,299,44,300,95,302});
    states[299] = new State(-103);
    states[300] = new State(new int[]{220,68,45,70,43,72,40,270,210,274,181,100,182,101,199,284,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,91,294},new int[]{-57,301,-53,283,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[301] = new State(-98);
    states[302] = new State(new int[]{41,303});
    states[303] = new State(-104);
    states[304] = new State(new int[]{93,305});
    states[305] = new State(-101);
    states[306] = new State(-102);
    states[307] = new State(new int[]{220,68,45,70,43,72,40,270,210,274,181,100,182,101,199,284,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,91,294},new int[]{-57,308,-53,283,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[308] = new State(-115);
    states[309] = new State(-113);
    states[310] = new State(new int[]{93,311});
    states[311] = new State(-100);
    states[312] = new State(-333);
    states[313] = new State(-334);
    states[314] = new State(-335);
    states[315] = new State(-336);
    states[316] = new State(new int[]{165,-57,166,-57,184,-57,185,-57,115,-57,59,-57,177,-57,95,-57,210,-57,172,-57,122,-57,128,-57,40,-54});
    states[317] = new State(-20);
    states[318] = new State(-21);
    states[319] = new State(-22);
    states[320] = new State(-23);
    states[321] = new State(-24);
    states[322] = new State(-25);
    states[323] = new State(-26);
    states[324] = new State(-27);
    states[325] = new State(-28);
    states[326] = new State(-29);
    states[327] = new State(-30);
    states[328] = new State(-31);
    states[329] = new State(-32);
    states[330] = new State(-33);
    states[331] = new State(-34);
    states[332] = new State(-35);
    states[333] = new State(-36);
    states[334] = new State(-37);
    states[335] = new State(-38);
    states[336] = new State(-39);
    states[337] = new State(-40);
    states[338] = new State(-41);
    states[339] = new State(-42);
    states[340] = new State(-58);
    states[341] = new State(new int[]{91,342});
    states[342] = new State(new int[]{95,363,220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-30,343,-1,367,-45,361,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[343] = new State(new int[]{93,344,44,359,220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-1,362,-45,361,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[344] = new State(new int[]{120,345});
    states[345] = new State(new int[]{130,317,129,318,131,319,132,320,133,321,134,322,135,323,136,324,137,325,138,326,139,327,141,328,142,329,143,330,144,331,140,332,147,333,148,334,151,335,152,336,153,337,150,338,149,339,210,349,145,351,146,355},new int[]{-41,346,-35,347,-40,348,-42,350});
    states[346] = new State(-68);
    states[347] = new State(-54);
    states[348] = new State(-55);
    states[349] = new State(-53);
    states[350] = new State(-56);
    states[351] = new State(new int[]{91,352,167,-90,174,-90,171,-90,173,-90,175,-90,176,-90,168,-90,169,-90,170,-90,127,-90,95,-90,97,-90,98,-90,101,-90,100,-90,106,-90,210,-90,211,-90,113,-90,183,-90,59,-90,165,-90,166,-90,184,-90,185,-90,115,-90,177,-90,172,-90,40,-90,122,-90,128,-90});
    states[352] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,353,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[353] = new State(new int[]{93,354,61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66});
    states[354] = new State(-88);
    states[355] = new State(new int[]{91,356,167,-91,174,-91,171,-91,173,-91,175,-91,176,-91,168,-91,169,-91,170,-91,127,-91,95,-91,97,-91,98,-91,101,-91,100,-91,106,-91,210,-91,211,-91,113,-91,183,-91,59,-91,165,-91,166,-91,184,-91,185,-91,115,-91,177,-91,172,-91,40,-91,122,-91,128,-91});
    states[356] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-45,357,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[357] = new State(new int[]{93,358,61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66});
    states[358] = new State(-89);
    states[359] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-1,360,-45,361,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[360] = new State(-18);
    states[361] = new State(new int[]{154,185,61,36,60,38,62,40,215,42,216,44,217,46,214,48,212,50,213,52,221,54,218,56,38,58,43,60,45,62,42,64,47,66});
    states[362] = new State(-19);
    states[363] = new State(new int[]{93,364});
    states[364] = new State(new int[]{120,365});
    states[365] = new State(new int[]{130,317,129,318,131,319,132,320,133,321,134,322,135,323,136,324,137,325,138,326,139,327,141,328,142,329,143,330,144,331,140,332,147,333,148,334,151,335,152,336,153,337,150,338,149,339,210,349,145,351,146,355},new int[]{-41,366,-35,347,-40,348,-42,350});
    states[366] = new State(-69);
    states[367] = new State(-17);
    states[368] = new State(-59);
    states[369] = new State(new int[]{122,370,95,372,210,374},new int[]{-32,371});
    states[370] = new State(-74);
    states[371] = new State(-72);
    states[372] = new State(new int[]{122,373});
    states[373] = new State(-77);
    states[374] = new State(new int[]{58,375});
    states[375] = new State(new int[]{130,317,129,318,131,319,132,320,133,321,134,322,135,323,136,324,137,325,138,326,139,327,141,328,142,329,143,330,144,331,140,332,147,333,148,334,151,335,152,336,153,337,150,338,149,339,119,341,121,383,40,465,210,349,145,351,146,355,155,479,163,480,156,481,161,482,162,483,164,484,157,485,158,486,159,487,160,488},new int[]{-76,376,-43,378,-35,316,-36,340,-37,368,-31,369,-39,389,-19,390,-38,470,-41,471,-40,476,-42,477,-44,478});
    states[376] = new State(new int[]{59,259,122,-126,95,-126,210,-126},new int[]{-91,377});
    states[377] = new State(-73);
    states[378] = new State(new int[]{165,312,166,313,184,314,185,315,115,-337,59,-337,122,-337,95,-337,210,-337,177,-337,172,-337,128,-337},new int[]{-78,379});
    states[379] = new State(new int[]{115,380,59,-65,122,-65,95,-65,210,-65,177,-65,172,-65,128,-65});
    states[380] = new State(-66,new int[]{-89,381});
    states[381] = new State(new int[]{220,68,45,70,43,72,40,270,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125,91,294},new int[]{-53,382,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[382] = new State(-67);
    states[383] = new State(new int[]{210,-70,95,-75},new int[]{-90,384,-92,386});
    states[384] = new State(new int[]{210,374},new int[]{-32,385});
    states[385] = new State(-71);
    states[386] = new State(new int[]{95,387});
    states[387] = new State(new int[]{122,388});
    states[388] = new State(-76);
    states[389] = new State(-60);
    states[390] = new State(new int[]{41,391,44,392,95,463,210,394,203,395,130,317,129,318,131,319,132,320,133,321,134,322,135,323,136,324,137,325,138,326,139,327,141,328,142,329,143,330,144,331,140,332,147,333,148,334,151,335,152,336,153,337,150,338,149,339,145,398,146,399,179,400,180,401,178,402,165,403,166,404,184,405,185,406,168,407,169,408,170,409,173,410,175,411,176,412,174,413,171,414,167,415,177,416,172,417,123,418,124,419,125,420,126,421,117,422,118,423,101,424,104,425,105,426,108,427,111,428,97,429,110,430,98,431,99,432,112,433,100,434,102,435,114,436,103,437,109,438,106,439,120,440,107,441,113,442,183,443,127,444,128,445,119,446,121,447,122,448,214,449,220,450,212,451,213,452,218,453,188,454,189,455,196,456,197,457,192,458,193,459,194,460,195,461},new int[]{-79,462,-80,396,-35,397});
    states[391] = new State(-84);
    states[392] = new State(new int[]{210,394,203,395,130,317,129,318,131,319,132,320,133,321,134,322,135,323,136,324,137,325,138,326,139,327,141,328,142,329,143,330,144,331,140,332,147,333,148,334,151,335,152,336,153,337,150,338,149,339,145,398,146,399,179,400,180,401,178,402,165,403,166,404,184,405,185,406,168,407,169,408,170,409,173,410,175,411,176,412,174,413,171,414,167,415,177,416,172,417,123,418,124,419,125,420,126,421,117,422,118,423,101,424,104,425,105,426,108,427,111,428,97,429,110,430,98,431,99,432,112,433,100,434,102,435,114,436,103,437,109,438,106,439,120,440,107,441,113,442,183,443,127,444,128,445,119,446,121,447,122,448,214,449,220,450,212,451,213,452,218,453,188,454,189,455,196,456,197,457,192,458,193,459,194,460,195,461},new int[]{-79,393,-80,396,-35,397});
    states[393] = new State(-82);
    states[394] = new State(-78);
    states[395] = new State(-79);
    states[396] = new State(-80);
    states[397] = new State(-338);
    states[398] = new State(-339);
    states[399] = new State(-340);
    states[400] = new State(-341);
    states[401] = new State(-342);
    states[402] = new State(-343);
    states[403] = new State(-344);
    states[404] = new State(-345);
    states[405] = new State(-346);
    states[406] = new State(-347);
    states[407] = new State(-348);
    states[408] = new State(-349);
    states[409] = new State(-350);
    states[410] = new State(-351);
    states[411] = new State(-352);
    states[412] = new State(-353);
    states[413] = new State(-354);
    states[414] = new State(-355);
    states[415] = new State(-356);
    states[416] = new State(-357);
    states[417] = new State(-358);
    states[418] = new State(-359);
    states[419] = new State(-360);
    states[420] = new State(-361);
    states[421] = new State(-362);
    states[422] = new State(-363);
    states[423] = new State(-364);
    states[424] = new State(-365);
    states[425] = new State(-366);
    states[426] = new State(-367);
    states[427] = new State(-368);
    states[428] = new State(-369);
    states[429] = new State(-370);
    states[430] = new State(-371);
    states[431] = new State(-372);
    states[432] = new State(-373);
    states[433] = new State(-374);
    states[434] = new State(-375);
    states[435] = new State(-376);
    states[436] = new State(-377);
    states[437] = new State(-378);
    states[438] = new State(-379);
    states[439] = new State(-380);
    states[440] = new State(-381);
    states[441] = new State(-382);
    states[442] = new State(-383);
    states[443] = new State(-384);
    states[444] = new State(-385);
    states[445] = new State(-386);
    states[446] = new State(-387);
    states[447] = new State(-388);
    states[448] = new State(-389);
    states[449] = new State(-390);
    states[450] = new State(-391);
    states[451] = new State(-392);
    states[452] = new State(-393);
    states[453] = new State(-394);
    states[454] = new State(-395);
    states[455] = new State(-396);
    states[456] = new State(-397);
    states[457] = new State(-398);
    states[458] = new State(-399);
    states[459] = new State(-400);
    states[460] = new State(-401);
    states[461] = new State(-402);
    states[462] = new State(-83);
    states[463] = new State(new int[]{41,464});
    states[464] = new State(-85);
    states[465] = new State(new int[]{95,467,41,469,210,394,203,395,130,317,129,318,131,319,132,320,133,321,134,322,135,323,136,324,137,325,138,326,139,327,141,328,142,329,143,330,144,331,140,332,147,333,148,334,151,335,152,336,153,337,150,338,149,339,145,398,146,399,179,400,180,401,178,402,165,403,166,404,184,405,185,406,168,407,169,408,170,409,173,410,175,411,176,412,174,413,171,414,167,415,177,416,172,417,123,418,124,419,125,420,126,421,117,422,118,423,101,424,104,425,105,426,108,427,111,428,97,429,110,430,98,431,99,432,112,433,100,434,102,435,114,436,103,437,109,438,106,439,120,440,107,441,113,442,183,443,127,444,128,445,119,446,121,447,122,448,214,449,220,450,212,451,213,452,218,453,188,454,189,455,196,456,197,457,192,458,193,459,194,460,195,461},new int[]{-79,466,-80,396,-35,397});
    states[466] = new State(-81);
    states[467] = new State(new int[]{41,468});
    states[468] = new State(-86);
    states[469] = new State(-87);
    states[470] = new State(-61);
    states[471] = new State(new int[]{40,472});
    states[472] = new State(-92,new int[]{-93,473});
    states[473] = new State(new int[]{220,68,45,70,43,72,40,74,210,81,181,100,182,101,199,102,200,103,207,104,206,105,204,106,205,107,208,108,209,109,201,110,202,111,203,112,211,125},new int[]{-1,474,-45,361,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[474] = new State(new int[]{41,475});
    states[475] = new State(-93);
    states[476] = new State(new int[]{40,-55,165,-62,166,-62,184,-62,185,-62,115,-62,59,-62,177,-62,95,-62,210,-62,172,-62,122,-62,128,-62});
    states[477] = new State(new int[]{40,-56,165,-63,166,-63,184,-63,185,-63,115,-63,59,-63,177,-63,95,-63,210,-63,172,-63,122,-63,128,-63});
    states[478] = new State(-64);
    states[479] = new State(-43);
    states[480] = new State(-44);
    states[481] = new State(-45);
    states[482] = new State(-46);
    states[483] = new State(-47);
    states[484] = new State(-48);
    states[485] = new State(-49);
    states[486] = new State(-50);
    states[487] = new State(-51);
    states[488] = new State(-52);
    states[489] = new State(new int[]{210,490,130,317,129,318,131,319,132,320,133,321,134,322,135,323,136,324,137,325,138,326,139,327,141,328,142,329,143,330,144,331,140,332,147,333,148,334,151,335,152,336,153,337,150,338,149,339,145,398,146,399,179,400,180,401,178,402,165,403,166,404,184,405,185,406,168,407,169,408,170,409,173,410,175,411,176,412,174,413,171,414,167,415,177,416,172,417,123,418,124,419,125,420,126,421,117,422,118,423,101,424,104,425,105,426,108,427,111,428,97,429,110,430,98,431,99,432,112,433,100,434,102,435,114,436,103,437,109,438,106,439,120,440,107,441,113,442,183,443,127,444,128,445,119,446,121,447,122,448,214,449,220,450,212,451,213,452,218,453,188,454,189,455,196,456,197,457,192,458,193,459,194,460,195,461},new int[]{-80,491,-35,397});
    states[490] = new State(-14);
    states[491] = new State(-15);
    states[492] = new State(-16);
    states[493] = new State(new int[]{172,494,58,-13,44,-13,210,-13});
    states[494] = new State(new int[]{211,495});
    states[495] = new State(-323,new int[]{-126,496});
    states[496] = new State(new int[]{58,497});
    states[497] = new State(new int[]{130,317,129,318,131,319,132,320,133,321,134,322,135,323,136,324,137,325,138,326,139,327,141,328,142,329,143,330,144,331,140,332,147,333,148,334,151,335,152,336,153,337,150,338,149,339,119,341,121,383,40,465,210,349,145,351,146,355,155,479,163,480,156,481,161,482,162,483,164,484,157,485,158,486,159,487,160,488},new int[]{-76,498,-43,378,-35,316,-36,340,-37,368,-31,369,-39,389,-19,390,-38,470,-41,471,-40,476,-42,477,-44,478});
    states[498] = new State(-324);
    states[499] = new State(new int[]{211,500});
    states[500] = new State(-325,new int[]{-127,501});
    states[501] = new State(new int[]{58,502});
    states[502] = new State(new int[]{130,317,129,318,131,319,132,320,133,321,134,322,135,323,136,324,137,325,138,326,139,327,141,328,142,329,143,330,144,331,140,332,147,333,148,334,151,335,152,336,153,337,150,338,149,339,119,341,121,383,40,465,210,349,145,351,146,355,155,479,163,480,156,481,161,482,162,483,164,484,157,485,158,486,159,487,160,488},new int[]{-76,503,-43,378,-35,316,-36,340,-37,368,-31,369,-39,389,-19,390,-38,470,-41,471,-40,476,-42,477,-44,478});
    states[503] = new State(-326);
    states[504] = new State(new int[]{59,259,177,-126,95,-126,210,-126,172,-126},new int[]{-91,505});
    states[505] = new State(-316);
    states[506] = new State(new int[]{177,507});
    states[507] = new State(-280);
    states[508] = new State(new int[]{178,509,210,-327,172,-327});
    states[509] = new State(-331);
    states[510] = new State(-328);
    states[511] = new State(new int[]{179,512,210,-329,172,-329});
    states[512] = new State(-330);
    states[513] = new State(-303);
    states[514] = new State(new int[]{95,518,179,508,180,510,178,511,210,-332,172,-332},new int[]{-77,515});
    states[515] = new State(-290,new int[]{-121,516});
    states[516] = new State(new int[]{210,493,172,499},new int[]{-12,517,-13,255,-11,504,-18,262});
    states[517] = new State(-291);
    states[518] = new State(new int[]{177,519});
    states[519] = new State(-292);
    states[520] = new State(-304);
    states[521] = new State(new int[]{95,525,179,508,180,510,178,511,210,-332,172,-332},new int[]{-77,522});
    states[522] = new State(-293,new int[]{-122,523});
    states[523] = new State(new int[]{210,493,172,499},new int[]{-12,524,-13,255,-11,504,-18,262});
    states[524] = new State(-294);
    states[525] = new State(new int[]{177,526});
    states[526] = new State(-295);
    states[527] = new State(-305);
    states[528] = new State(new int[]{95,532,179,508,180,510,178,511,210,-332,172,-332},new int[]{-77,529});
    states[529] = new State(-284,new int[]{-119,530});
    states[530] = new State(new int[]{210,493,172,499},new int[]{-12,531,-13,255,-11,504,-18,262});
    states[531] = new State(-285);
    states[532] = new State(new int[]{177,533});
    states[533] = new State(-286);
    states[534] = new State(-306);
    states[535] = new State(new int[]{95,539,179,508,180,510,178,511,210,-332,172,-332},new int[]{-77,536});
    states[536] = new State(-296,new int[]{-123,537});
    states[537] = new State(new int[]{210,493,172,499},new int[]{-12,538,-13,255,-11,504,-18,262});
    states[538] = new State(-297);
    states[539] = new State(new int[]{177,540});
    states[540] = new State(-298);
    states[541] = new State(-307);
    states[542] = new State(new int[]{95,546,179,508,180,510,178,511,210,-332,172,-332},new int[]{-77,543});
    states[543] = new State(-299,new int[]{-124,544});
    states[544] = new State(new int[]{210,493,172,499},new int[]{-12,545,-13,255,-11,504,-18,262});
    states[545] = new State(-300);
    states[546] = new State(new int[]{177,547});
    states[547] = new State(-301);
    states[548] = new State(-308);
    states[549] = new State(new int[]{95,553,179,508,180,510,178,511,210,-332,172,-332},new int[]{-77,550});
    states[550] = new State(-275,new int[]{-116,551});
    states[551] = new State(new int[]{210,493,172,499},new int[]{-12,552,-13,255,-11,504,-18,262});
    states[552] = new State(-276);
    states[553] = new State(new int[]{177,554});
    states[554] = new State(-277);
    states[555] = new State(-309);
    states[556] = new State(new int[]{95,560,179,508,180,510,178,511,210,-332,172,-332},new int[]{-77,557});
    states[557] = new State(-281,new int[]{-118,558});
    states[558] = new State(new int[]{210,493,172,499},new int[]{-12,559,-13,255,-11,504,-18,262});
    states[559] = new State(-282);
    states[560] = new State(new int[]{177,561});
    states[561] = new State(-283);
    states[562] = new State(-310);
    states[563] = new State(new int[]{95,567,179,508,180,510,178,511,210,-332,172,-332},new int[]{-77,564});
    states[564] = new State(-287,new int[]{-120,565});
    states[565] = new State(new int[]{210,493,172,499},new int[]{-12,566,-13,255,-11,504,-18,262});
    states[566] = new State(-288);
    states[567] = new State(new int[]{177,568});
    states[568] = new State(-289);
    states[569] = new State(-311);
    states[570] = new State(new int[]{95,581,210,-122},new int[]{-98,571,-99,583});
    states[571] = new State(new int[]{128,572,95,573,210,576},new int[]{-100,575});
    states[572] = new State(-119);
    states[573] = new State(new int[]{128,574});
    states[574] = new State(-120);
    states[575] = new State(-124);
    states[576] = new State(new int[]{58,577});
    states[577] = new State(-127,new int[]{-101,578});
    states[578] = new State(new int[]{130,317,129,318,131,319,132,320,133,321,134,322,135,323,136,324,137,325,138,326,139,327,141,328,142,329,143,330,144,331,140,332,147,333,148,334,151,335,152,336,153,337,150,338,149,339,119,341,121,383,40,465,210,349,145,351,146,355,155,479,163,480,156,481,161,482,162,483,164,484,157,485,158,486,159,487,160,488},new int[]{-76,579,-43,378,-35,316,-36,340,-37,368,-31,369,-39,389,-19,390,-38,470,-41,471,-40,476,-42,477,-44,478});
    states[579] = new State(new int[]{59,259,128,-126,95,-126,210,-126},new int[]{-91,580});
    states[580] = new State(-128);
    states[581] = new State(new int[]{128,582});
    states[582] = new State(-121);
    states[583] = new State(new int[]{210,576},new int[]{-100,584});
    states[584] = new State(-123);
    states[585] = new State(-312);
    states[586] = new State(-7);
    states[587] = new State(new int[]{210,588});
    states[588] = new State(-270,new int[]{-113,589});
    states[589] = new State(new int[]{167,251,174,514,171,521,173,528,175,535,176,542,168,549,169,556,170,563,127,570,95,-315,97,-315,98,-315,101,-315,100,-315,106,-315,210,-315,211,-315,113,-315,183,-315,59,-315},new int[]{-72,590,-73,248,-68,585,-58,250,-59,513,-60,520,-61,527,-62,534,-63,541,-64,548,-65,555,-66,562,-67,569});
    states[590] = new State(-271,new int[]{-114,591});
    states[591] = new State(new int[]{95,232,97,-185,98,-185,101,-185,100,-185,106,-185,210,-185,211,-185,113,-185,183,-185,59,-185},new int[]{-8,592,-2,593,-103,201});
    states[592] = new State(-272);
    states[593] = new State(new int[]{126,594,95,595,97,21,98,28,101,135,100,144,106,154,210,81,211,125,113,172,183,173,59,-202},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[594] = new State(-263);
    states[595] = new State(new int[]{126,596});
    states[596] = new State(-264);
    states[597] = new State(-8);
    states[598] = new State(new int[]{210,599});
    states[599] = new State(-273,new int[]{-115,600});
    states[600] = new State(new int[]{167,251,174,514,171,521,173,528,175,535,176,542,168,549,169,556,170,563,127,570,95,-315,97,-315,98,-315,101,-315,100,-315,106,-315,210,-315,211,-315,113,-315,183,-315,59,-315},new int[]{-72,601,-73,248,-68,585,-58,250,-59,513,-60,520,-61,527,-62,534,-63,541,-64,548,-65,555,-66,562,-67,569});
    states[601] = new State(new int[]{95,232,97,-185,98,-185,101,-185,100,-185,106,-185,210,-185,211,-185,113,-185,183,-185,59,-185},new int[]{-9,602,-2,603,-103,201});
    states[602] = new State(-274);
    states[603] = new State(new int[]{118,604,95,605,97,21,98,28,101,135,100,144,106,154,210,81,211,125,113,172,183,173,59,-202},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[604] = new State(-265);
    states[605] = new State(new int[]{118,606});
    states[606] = new State(-266);
    states[607] = new State(-9);
    states[608] = new State(-4);

    for (int sNo = 0; sNo < states.Length; sNo++) states[sNo].number = sNo;

    rules[1] = new Rule(-83, new int[]{-82,96});
    rules[2] = new Rule(-84, new int[]{});
    rules[3] = new Rule(-82, new int[]{-84,-85});
    rules[4] = new Rule(-85, new int[]{-86});
    rules[5] = new Rule(-85, new int[]{-85,-86});
    rules[6] = new Rule(-86, new int[]{-34});
    rules[7] = new Rule(-86, new int[]{-87});
    rules[8] = new Rule(-86, new int[]{-88});
    rules[9] = new Rule(-86, new int[]{-67});
    rules[10] = new Rule(-81, new int[]{115});
    rules[11] = new Rule(-81, new int[]{116});
    rules[12] = new Rule(-1, new int[]{-45,154,-45});
    rules[13] = new Rule(-18, new int[]{210});
    rules[14] = new Rule(-18, new int[]{-18,44,210});
    rules[15] = new Rule(-18, new int[]{-18,44,-80});
    rules[16] = new Rule(-18, new int[]{-18,210});
    rules[17] = new Rule(-30, new int[]{-1});
    rules[18] = new Rule(-30, new int[]{-30,44,-1});
    rules[19] = new Rule(-30, new int[]{-30,-1});
    rules[20] = new Rule(-35, new int[]{130});
    rules[21] = new Rule(-35, new int[]{129});
    rules[22] = new Rule(-35, new int[]{131});
    rules[23] = new Rule(-35, new int[]{132});
    rules[24] = new Rule(-35, new int[]{133});
    rules[25] = new Rule(-35, new int[]{134});
    rules[26] = new Rule(-35, new int[]{135});
    rules[27] = new Rule(-35, new int[]{136});
    rules[28] = new Rule(-35, new int[]{137});
    rules[29] = new Rule(-35, new int[]{138});
    rules[30] = new Rule(-35, new int[]{139});
    rules[31] = new Rule(-35, new int[]{141});
    rules[32] = new Rule(-35, new int[]{142});
    rules[33] = new Rule(-35, new int[]{143});
    rules[34] = new Rule(-35, new int[]{144});
    rules[35] = new Rule(-35, new int[]{140});
    rules[36] = new Rule(-35, new int[]{147});
    rules[37] = new Rule(-35, new int[]{148});
    rules[38] = new Rule(-35, new int[]{151});
    rules[39] = new Rule(-35, new int[]{152});
    rules[40] = new Rule(-35, new int[]{153});
    rules[41] = new Rule(-35, new int[]{150});
    rules[42] = new Rule(-35, new int[]{149});
    rules[43] = new Rule(-44, new int[]{155});
    rules[44] = new Rule(-44, new int[]{163});
    rules[45] = new Rule(-44, new int[]{156});
    rules[46] = new Rule(-44, new int[]{161});
    rules[47] = new Rule(-44, new int[]{162});
    rules[48] = new Rule(-44, new int[]{164});
    rules[49] = new Rule(-44, new int[]{157});
    rules[50] = new Rule(-44, new int[]{158});
    rules[51] = new Rule(-44, new int[]{159});
    rules[52] = new Rule(-44, new int[]{160});
    rules[53] = new Rule(-40, new int[]{210});
    rules[54] = new Rule(-41, new int[]{-35});
    rules[55] = new Rule(-41, new int[]{-40});
    rules[56] = new Rule(-41, new int[]{-42});
    rules[57] = new Rule(-43, new int[]{-35});
    rules[58] = new Rule(-43, new int[]{-36});
    rules[59] = new Rule(-43, new int[]{-37});
    rules[60] = new Rule(-43, new int[]{-39});
    rules[61] = new Rule(-43, new int[]{-38});
    rules[62] = new Rule(-43, new int[]{-40});
    rules[63] = new Rule(-43, new int[]{-42});
    rules[64] = new Rule(-43, new int[]{-44});
    rules[65] = new Rule(-76, new int[]{-43,-78});
    rules[66] = new Rule(-89, new int[]{});
    rules[67] = new Rule(-76, new int[]{-43,-78,115,-89,-53});
    rules[68] = new Rule(-36, new int[]{119,91,-30,93,120,-41});
    rules[69] = new Rule(-36, new int[]{119,91,95,93,120,-41});
    rules[70] = new Rule(-90, new int[]{});
    rules[71] = new Rule(-31, new int[]{121,-90,-32});
    rules[72] = new Rule(-31, new int[]{-31,-32});
    rules[73] = new Rule(-32, new int[]{210,58,-76,-91});
    rules[74] = new Rule(-37, new int[]{-31,122});
    rules[75] = new Rule(-92, new int[]{});
    rules[76] = new Rule(-37, new int[]{121,-92,95,122});
    rules[77] = new Rule(-37, new int[]{-31,95,122});
    rules[78] = new Rule(-79, new int[]{210});
    rules[79] = new Rule(-79, new int[]{203});
    rules[80] = new Rule(-79, new int[]{-80});
    rules[81] = new Rule(-19, new int[]{40,-79});
    rules[82] = new Rule(-19, new int[]{-19,44,-79});
    rules[83] = new Rule(-19, new int[]{-19,-79});
    rules[84] = new Rule(-39, new int[]{-19,41});
    rules[85] = new Rule(-39, new int[]{-19,95,41});
    rules[86] = new Rule(-39, new int[]{40,95,41});
    rules[87] = new Rule(-39, new int[]{40,41});
    rules[88] = new Rule(-42, new int[]{145,91,-45,93});
    rules[89] = new Rule(-42, new int[]{146,91,-45,93});
    rules[90] = new Rule(-42, new int[]{145});
    rules[91] = new Rule(-42, new int[]{146});
    rules[92] = new Rule(-93, new int[]{});
    rules[93] = new Rule(-38, new int[]{-41,40,-93,-1,41});
    rules[94] = new Rule(-94, new int[]{});
    rules[95] = new Rule(-22, new int[]{91,-94,-57});
    rules[96] = new Rule(-22, new int[]{-22,44,-57});
    rules[97] = new Rule(-24, new int[]{40,-57});
    rules[98] = new Rule(-24, new int[]{-24,44,-57});
    rules[99] = new Rule(-21, new int[]{-22,93});
    rules[100] = new Rule(-21, new int[]{-22,95,93});
    rules[101] = new Rule(-21, new int[]{91,95,93});
    rules[102] = new Rule(-21, new int[]{91,93});
    rules[103] = new Rule(-23, new int[]{-24,41});
    rules[104] = new Rule(-23, new int[]{-24,95,41});
    rules[105] = new Rule(-23, new int[]{40,41});
    rules[106] = new Rule(-57, new int[]{-53});
    rules[107] = new Rule(-95, new int[]{});
    rules[108] = new Rule(-57, new int[]{199,40,-95,95,41});
    rules[109] = new Rule(-96, new int[]{});
    rules[110] = new Rule(-57, new int[]{199,40,-96,-25,41});
    rules[111] = new Rule(-97, new int[]{});
    rules[112] = new Rule(-57, new int[]{210,-97,115,-53});
    rules[113] = new Rule(-25, new int[]{-57});
    rules[114] = new Rule(-25, new int[]{-25,44,-57});
    rules[115] = new Rule(-25, new int[]{-25,95,-57});
    rules[116] = new Rule(-53, new int[]{-45});
    rules[117] = new Rule(-53, new int[]{-21});
    rules[118] = new Rule(-53, new int[]{-23});
    rules[119] = new Rule(-67, new int[]{127,-98,128});
    rules[120] = new Rule(-67, new int[]{127,-98,95,128});
    rules[121] = new Rule(-67, new int[]{127,95,128});
    rules[122] = new Rule(-99, new int[]{});
    rules[123] = new Rule(-98, new int[]{-99,-100});
    rules[124] = new Rule(-98, new int[]{-98,-100});
    rules[125] = new Rule(-91, new int[]{59});
    rules[126] = new Rule(-91, new int[]{});
    rules[127] = new Rule(-101, new int[]{});
    rules[128] = new Rule(-100, new int[]{210,58,-101,-76,-91});
    rules[129] = new Rule(-46, new int[]{181});
    rules[130] = new Rule(-46, new int[]{182});
    rules[131] = new Rule(-46, new int[]{199});
    rules[132] = new Rule(-46, new int[]{200});
    rules[133] = new Rule(-46, new int[]{207});
    rules[134] = new Rule(-46, new int[]{206});
    rules[135] = new Rule(-46, new int[]{204});
    rules[136] = new Rule(-46, new int[]{205});
    rules[137] = new Rule(-46, new int[]{208});
    rules[138] = new Rule(-46, new int[]{209});
    rules[139] = new Rule(-46, new int[]{201});
    rules[140] = new Rule(-46, new int[]{202});
    rules[141] = new Rule(-46, new int[]{203});
    rules[142] = new Rule(-50, new int[]{-52});
    rules[143] = new Rule(-50, new int[]{211});
    rules[144] = new Rule(-52, new int[]{-51});
    rules[145] = new Rule(-52, new int[]{-74,93});
    rules[146] = new Rule(-52, new int[]{-51,91,95,93});
    rules[147] = new Rule(-102, new int[]{});
    rules[148] = new Rule(-74, new int[]{-51,91,-102,-45});
    rules[149] = new Rule(-74, new int[]{-74,44,-45});
    rules[150] = new Rule(-51, new int[]{210});
    rules[151] = new Rule(-51, new int[]{-52,46,210});
    rules[152] = new Rule(-45, new int[]{220,-45});
    rules[153] = new Rule(-45, new int[]{45,-45});
    rules[154] = new Rule(-45, new int[]{43,-45});
    rules[155] = new Rule(-45, new int[]{-45,61,-45});
    rules[156] = new Rule(-45, new int[]{-45,60,-45});
    rules[157] = new Rule(-45, new int[]{-45,62,-45});
    rules[158] = new Rule(-45, new int[]{-45,215,-45});
    rules[159] = new Rule(-45, new int[]{-45,216,-45});
    rules[160] = new Rule(-45, new int[]{-45,217,-45});
    rules[161] = new Rule(-45, new int[]{-45,214,-45});
    rules[162] = new Rule(-45, new int[]{-45,212,-45});
    rules[163] = new Rule(-45, new int[]{-45,213,-45});
    rules[164] = new Rule(-45, new int[]{-45,221,-45});
    rules[165] = new Rule(-45, new int[]{-45,218,-45});
    rules[166] = new Rule(-45, new int[]{-45,38,-45});
    rules[167] = new Rule(-45, new int[]{-45,43,-45});
    rules[168] = new Rule(-45, new int[]{-45,45,-45});
    rules[169] = new Rule(-45, new int[]{-45,42,-45});
    rules[170] = new Rule(-45, new int[]{-45,47,-45});
    rules[171] = new Rule(-45, new int[]{40,-45,41});
    rules[172] = new Rule(-45, new int[]{40,-45,95});
    rules[173] = new Rule(-45, new int[]{-70});
    rules[174] = new Rule(-45, new int[]{-46});
    rules[175] = new Rule(-45, new int[]{-50});
    rules[176] = new Rule(-45, new int[]{40,95,41});
    rules[177] = new Rule(-71, new int[]{-45});
    rules[178] = new Rule(-71, new int[]{210,-81,-45});
    rules[179] = new Rule(-71, new int[]{220,210,-81,-45});
    rules[180] = new Rule(-69, new int[]{210,40,-71});
    rules[181] = new Rule(-69, new int[]{-69,44,-71});
    rules[182] = new Rule(-70, new int[]{210,40,41});
    rules[183] = new Rule(-70, new int[]{210,40,95,41});
    rules[184] = new Rule(-70, new int[]{-69,41});
    rules[185] = new Rule(-103, new int[]{});
    rules[186] = new Rule(-2, new int[]{-103,-26,59});
    rules[187] = new Rule(-2, new int[]{-2,-26,59});
    rules[188] = new Rule(-2, new int[]{95,59});
    rules[189] = new Rule(-26, new int[]{97,-47,-4});
    rules[190] = new Rule(-104, new int[]{});
    rules[191] = new Rule(-26, new int[]{98,-104,-28});
    rules[192] = new Rule(-105, new int[]{});
    rules[193] = new Rule(-26, new int[]{101,-48,-2,-105,-15,-3,111});
    rules[194] = new Rule(-106, new int[]{});
    rules[195] = new Rule(-26, new int[]{100,-55,-81,-75,-106,-5});
    rules[196] = new Rule(-26, new int[]{106,-49,-16,107});
    rules[197] = new Rule(-26, new int[]{-27});
    rules[198] = new Rule(-26, new int[]{113});
    rules[199] = new Rule(-26, new int[]{183});
    rules[200] = new Rule(-26, new int[]{183,-45});
    rules[201] = new Rule(-26, new int[]{-70});
    rules[202] = new Rule(-26, new int[]{});
    rules[203] = new Rule(-4, new int[]{-2,110});
    rules[204] = new Rule(-4, new int[]{-2,95,110});
    rules[205] = new Rule(-4, new int[]{95,110});
    rules[206] = new Rule(-28, new int[]{-2,99,-54});
    rules[207] = new Rule(-28, new int[]{-2,95,99,-54});
    rules[208] = new Rule(-28, new int[]{95,112});
    rules[209] = new Rule(-5, new int[]{-2,109});
    rules[210] = new Rule(-5, new int[]{-2,95,109});
    rules[211] = new Rule(-5, new int[]{95,109});
    rules[212] = new Rule(-47, new int[]{-45,103});
    rules[213] = new Rule(-47, new int[]{95,103});
    rules[214] = new Rule(-47, new int[]{-45});
    rules[215] = new Rule(-48, new int[]{-45,104});
    rules[216] = new Rule(-48, new int[]{95,104});
    rules[217] = new Rule(-48, new int[]{-45});
    rules[218] = new Rule(-54, new int[]{-45,112});
    rules[219] = new Rule(-54, new int[]{95,112});
    rules[220] = new Rule(-54, new int[]{-45});
    rules[221] = new Rule(-49, new int[]{-45,120});
    rules[222] = new Rule(-49, new int[]{95,120});
    rules[223] = new Rule(-49, new int[]{-45});
    rules[224] = new Rule(-55, new int[]{-50});
    rules[225] = new Rule(-107, new int[]{});
    rules[226] = new Rule(-75, new int[]{-45,102,-107,-45,-56,103});
    rules[227] = new Rule(-108, new int[]{});
    rules[228] = new Rule(-75, new int[]{95,102,-108,-45,-56,103});
    rules[229] = new Rule(-75, new int[]{-45,102,95,103});
    rules[230] = new Rule(-75, new int[]{95,103});
    rules[231] = new Rule(-109, new int[]{});
    rules[232] = new Rule(-56, new int[]{114,-109,-45});
    rules[233] = new Rule(-56, new int[]{});
    rules[234] = new Rule(-3, new int[]{105,-2});
    rules[235] = new Rule(-3, new int[]{105,95});
    rules[236] = new Rule(-3, new int[]{});
    rules[237] = new Rule(-15, new int[]{-14});
    rules[238] = new Rule(-15, new int[]{});
    rules[239] = new Rule(-6, new int[]{105,-10});
    rules[240] = new Rule(-6, new int[]{105,-10,95});
    rules[241] = new Rule(-110, new int[]{});
    rules[242] = new Rule(-10, new int[]{-110,-26,59});
    rules[243] = new Rule(-10, new int[]{-10,-26,59});
    rules[244] = new Rule(-10, new int[]{95,59});
    rules[245] = new Rule(-33, new int[]{198,-20,58,-10});
    rules[246] = new Rule(-33, new int[]{198,95,58,-10});
    rules[247] = new Rule(-33, new int[]{198,-20,-10});
    rules[248] = new Rule(-33, new int[]{-6});
    rules[249] = new Rule(-17, new int[]{-33});
    rules[250] = new Rule(-17, new int[]{-17,-33});
    rules[251] = new Rule(-16, new int[]{-17});
    rules[252] = new Rule(-16, new int[]{});
    rules[253] = new Rule(-29, new int[]{-45});
    rules[254] = new Rule(-29, new int[]{-1});
    rules[255] = new Rule(-20, new int[]{-29});
    rules[256] = new Rule(-20, new int[]{-20,44,-29});
    rules[257] = new Rule(-14, new int[]{108,-48,-2});
    rules[258] = new Rule(-14, new int[]{-14,108,-48,-2});
    rules[259] = new Rule(-27, new int[]{-50,115,-45});
    rules[260] = new Rule(-27, new int[]{-50,61,-45});
    rules[261] = new Rule(-7, new int[]{-2,124});
    rules[262] = new Rule(-7, new int[]{-2,95,124});
    rules[263] = new Rule(-8, new int[]{-2,126});
    rules[264] = new Rule(-8, new int[]{-2,95,126});
    rules[265] = new Rule(-9, new int[]{-2,118});
    rules[266] = new Rule(-9, new int[]{-2,95,118});
    rules[267] = new Rule(-111, new int[]{});
    rules[268] = new Rule(-112, new int[]{});
    rules[269] = new Rule(-34, new int[]{123,210,58,-41,-111,-72,-112,-7});
    rules[270] = new Rule(-113, new int[]{});
    rules[271] = new Rule(-114, new int[]{});
    rules[272] = new Rule(-87, new int[]{125,210,-113,-72,-114,-8});
    rules[273] = new Rule(-115, new int[]{});
    rules[274] = new Rule(-88, new int[]{117,210,-115,-72,-9});
    rules[275] = new Rule(-116, new int[]{});
    rules[276] = new Rule(-64, new int[]{168,-77,-116,-12});
    rules[277] = new Rule(-64, new int[]{168,95,177});
    rules[278] = new Rule(-117, new int[]{});
    rules[279] = new Rule(-58, new int[]{167,-77,-117,-12});
    rules[280] = new Rule(-58, new int[]{167,95,177});
    rules[281] = new Rule(-118, new int[]{});
    rules[282] = new Rule(-65, new int[]{169,-77,-118,-12});
    rules[283] = new Rule(-65, new int[]{169,95,177});
    rules[284] = new Rule(-119, new int[]{});
    rules[285] = new Rule(-61, new int[]{173,-77,-119,-12});
    rules[286] = new Rule(-61, new int[]{173,95,177});
    rules[287] = new Rule(-120, new int[]{});
    rules[288] = new Rule(-66, new int[]{170,-77,-120,-12});
    rules[289] = new Rule(-66, new int[]{170,95,177});
    rules[290] = new Rule(-121, new int[]{});
    rules[291] = new Rule(-59, new int[]{174,-77,-121,-12});
    rules[292] = new Rule(-59, new int[]{174,95,177});
    rules[293] = new Rule(-122, new int[]{});
    rules[294] = new Rule(-60, new int[]{171,-77,-122,-12});
    rules[295] = new Rule(-60, new int[]{171,95,177});
    rules[296] = new Rule(-123, new int[]{});
    rules[297] = new Rule(-62, new int[]{175,-77,-123,-12});
    rules[298] = new Rule(-62, new int[]{175,95,177});
    rules[299] = new Rule(-124, new int[]{});
    rules[300] = new Rule(-63, new int[]{176,-77,-124,-12});
    rules[301] = new Rule(-63, new int[]{176,95,177});
    rules[302] = new Rule(-68, new int[]{-58});
    rules[303] = new Rule(-68, new int[]{-59});
    rules[304] = new Rule(-68, new int[]{-60});
    rules[305] = new Rule(-68, new int[]{-61});
    rules[306] = new Rule(-68, new int[]{-62});
    rules[307] = new Rule(-68, new int[]{-63});
    rules[308] = new Rule(-68, new int[]{-64});
    rules[309] = new Rule(-68, new int[]{-65});
    rules[310] = new Rule(-68, new int[]{-66});
    rules[311] = new Rule(-68, new int[]{-67});
    rules[312] = new Rule(-73, new int[]{-68});
    rules[313] = new Rule(-73, new int[]{-73,-68});
    rules[314] = new Rule(-72, new int[]{-73});
    rules[315] = new Rule(-72, new int[]{});
    rules[316] = new Rule(-13, new int[]{-11,-91});
    rules[317] = new Rule(-13, new int[]{-13,-11,-91});
    rules[318] = new Rule(-12, new int[]{-13,177});
    rules[319] = new Rule(-12, new int[]{-13,95,177});
    rules[320] = new Rule(-11, new int[]{-18,58,-43,-78});
    rules[321] = new Rule(-125, new int[]{});
    rules[322] = new Rule(-11, new int[]{-18,58,-43,-78,-125,115,-53});
    rules[323] = new Rule(-126, new int[]{});
    rules[324] = new Rule(-11, new int[]{210,172,211,-126,58,-76});
    rules[325] = new Rule(-127, new int[]{});
    rules[326] = new Rule(-11, new int[]{172,211,-127,58,-76});
    rules[327] = new Rule(-77, new int[]{179});
    rules[328] = new Rule(-77, new int[]{180});
    rules[329] = new Rule(-77, new int[]{178});
    rules[330] = new Rule(-77, new int[]{178,179});
    rules[331] = new Rule(-77, new int[]{179,178});
    rules[332] = new Rule(-77, new int[]{});
    rules[333] = new Rule(-78, new int[]{165});
    rules[334] = new Rule(-78, new int[]{166});
    rules[335] = new Rule(-78, new int[]{184});
    rules[336] = new Rule(-78, new int[]{185});
    rules[337] = new Rule(-78, new int[]{});
    rules[338] = new Rule(-80, new int[]{-35});
    rules[339] = new Rule(-80, new int[]{145});
    rules[340] = new Rule(-80, new int[]{146});
    rules[341] = new Rule(-80, new int[]{179});
    rules[342] = new Rule(-80, new int[]{180});
    rules[343] = new Rule(-80, new int[]{178});
    rules[344] = new Rule(-80, new int[]{165});
    rules[345] = new Rule(-80, new int[]{166});
    rules[346] = new Rule(-80, new int[]{184});
    rules[347] = new Rule(-80, new int[]{185});
    rules[348] = new Rule(-80, new int[]{168});
    rules[349] = new Rule(-80, new int[]{169});
    rules[350] = new Rule(-80, new int[]{170});
    rules[351] = new Rule(-80, new int[]{173});
    rules[352] = new Rule(-80, new int[]{175});
    rules[353] = new Rule(-80, new int[]{176});
    rules[354] = new Rule(-80, new int[]{174});
    rules[355] = new Rule(-80, new int[]{171});
    rules[356] = new Rule(-80, new int[]{167});
    rules[357] = new Rule(-80, new int[]{177});
    rules[358] = new Rule(-80, new int[]{172});
    rules[359] = new Rule(-80, new int[]{123});
    rules[360] = new Rule(-80, new int[]{124});
    rules[361] = new Rule(-80, new int[]{125});
    rules[362] = new Rule(-80, new int[]{126});
    rules[363] = new Rule(-80, new int[]{117});
    rules[364] = new Rule(-80, new int[]{118});
    rules[365] = new Rule(-80, new int[]{101});
    rules[366] = new Rule(-80, new int[]{104});
    rules[367] = new Rule(-80, new int[]{105});
    rules[368] = new Rule(-80, new int[]{108});
    rules[369] = new Rule(-80, new int[]{111});
    rules[370] = new Rule(-80, new int[]{97});
    rules[371] = new Rule(-80, new int[]{110});
    rules[372] = new Rule(-80, new int[]{98});
    rules[373] = new Rule(-80, new int[]{99});
    rules[374] = new Rule(-80, new int[]{112});
    rules[375] = new Rule(-80, new int[]{100});
    rules[376] = new Rule(-80, new int[]{102});
    rules[377] = new Rule(-80, new int[]{114});
    rules[378] = new Rule(-80, new int[]{103});
    rules[379] = new Rule(-80, new int[]{109});
    rules[380] = new Rule(-80, new int[]{106});
    rules[381] = new Rule(-80, new int[]{120});
    rules[382] = new Rule(-80, new int[]{107});
    rules[383] = new Rule(-80, new int[]{113});
    rules[384] = new Rule(-80, new int[]{183});
    rules[385] = new Rule(-80, new int[]{127});
    rules[386] = new Rule(-80, new int[]{128});
    rules[387] = new Rule(-80, new int[]{119});
    rules[388] = new Rule(-80, new int[]{121});
    rules[389] = new Rule(-80, new int[]{122});
    rules[390] = new Rule(-80, new int[]{214});
    rules[391] = new Rule(-80, new int[]{220});
    rules[392] = new Rule(-80, new int[]{212});
    rules[393] = new Rule(-80, new int[]{213});
    rules[394] = new Rule(-80, new int[]{218});
    rules[395] = new Rule(-80, new int[]{188});
    rules[396] = new Rule(-80, new int[]{189});
    rules[397] = new Rule(-80, new int[]{196});
    rules[398] = new Rule(-80, new int[]{197});
    rules[399] = new Rule(-80, new int[]{192});
    rules[400] = new Rule(-80, new int[]{193});
    rules[401] = new Rule(-80, new int[]{194});
    rules[402] = new Rule(-80, new int[]{195});
  }

  protected override void Initialize() {
    this.InitSpecialTokens((int)Tokens.error, (int)Tokens.EOF);
    this.InitStates(states);
    this.InitRules(rules);
    this.InitNonTerminals(nonTerms);
  }

  protected override void DoAction(int action)
  {
#pragma warning disable 162, 1522
    switch (action)
    {
      case 2: // Anon@1 -> /* empty */
#line 145 "stlang.y"
                  {this.PushSymbolTable();}
#line default
        break;
      case 3: // main -> Anon@1, pou_declarations
#line 145 "stlang.y"
                                                             {this.PopSymbolTable();}
#line default
        break;
      case 6: // pou_declaration -> function_decl
#line 153 "stlang.y"
                                      {this.ReInitializeParser();}
#line default
        break;
      case 7: // pou_declaration -> function_block_decl
#line 154 "stlang.y"
                          {this.ReInitializeParser();}
#line default
        break;
      case 8: // pou_declaration -> program_decl
#line 155 "stlang.y"
                          {this.ReInitializeParser();}
#line default
        break;
      case 10: // assign -> ASSIGN
#line 159 "stlang.y"
                                {CurrentSemanticValue.Token = Tokens.ASSIGN;}
#line default
        break;
      case 11: // assign -> OUTPUT_ASSIGN
#line 160 "stlang.y"
                    {CurrentSemanticValue.Token = Tokens.OUTPUT_ASSIGN;}
#line default
        break;
      case 12: // subrange -> expression, DOTDOT, expression
#line 163 "stlang.y"
                                               {CurrentSemanticValue.Subrange = this.MakeSubrange(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3], LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 13: // identifier_list -> IDENT
#line 166 "stlang.y"
                                                        {CurrentSemanticValue.IdentifierList = this.MakeIdentifierList(ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 14: // identifier_list -> identifier_list, ',', IDENT
#line 167 "stlang.y"
                                            {CurrentSemanticValue.IdentifierList = this.AddIdentToList(ValueStack[ValueStack.Depth-3].IdentifierList, ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 15: // identifier_list -> identifier_list, ',', reserved_word
#line 168 "stlang.y"
                                            {CurrentSemanticValue.IdentifierList = ValueStack[ValueStack.Depth-3].IdentifierList; this.report.SyntaxError(192, ValueStack[ValueStack.Depth-1].Ident.ToString(), LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 16: // identifier_list -> identifier_list, IDENT
#line 169 "stlang.y"
                                         {CurrentSemanticValue.IdentifierList = this.AddIdentToList(ValueStack[ValueStack.Depth-2].IdentifierList, ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);this.report.SyntaxError(75, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 17: // subrange_list -> subrange
#line 172 "stlang.y"
                                               {CurrentSemanticValue.Subranges = this.MakeSubRangeList(ValueStack[ValueStack.Depth-1].Subrange, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 18: // subrange_list -> subrange_list, ',', subrange
#line 173 "stlang.y"
                                   {CurrentSemanticValue.Subranges = this.AddSubRange(ValueStack[ValueStack.Depth-3].Subranges, ValueStack[ValueStack.Depth-1].Subrange, LocationStack[LocationStack.Depth-1]); }
#line default
        break;
      case 19: // subrange_list -> subrange_list, subrange
#line 174 "stlang.y"
                                   {CurrentSemanticValue.Subranges = this.AddSubRange(ValueStack[ValueStack.Depth-2].Subranges, ValueStack[ValueStack.Depth-1].Subrange, LocationStack[LocationStack.Depth-1]);this.report.SyntaxError(75, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 20: // elementary_type -> SINT
#line 177 "stlang.y"
                                 {CurrentSemanticValue.DataType = TypeNode.SInt;}
#line default
        break;
      case 21: // elementary_type -> INT
#line 178 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.Int;}
#line default
        break;
      case 22: // elementary_type -> DINT
#line 179 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.DInt;}
#line default
        break;
      case 23: // elementary_type -> LINT
#line 180 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.LInt;}
#line default
        break;
      case 24: // elementary_type -> USINT
#line 181 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.USInt;}
#line default
        break;
      case 25: // elementary_type -> UINT
#line 182 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.UInt;}
#line default
        break;
      case 26: // elementary_type -> UDINT
#line 183 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.UDInt;}
#line default
        break;
      case 27: // elementary_type -> ULINT
#line 184 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.ULInt;}
#line default
        break;
      case 28: // elementary_type -> REAL
#line 185 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.Real;}
#line default
        break;
      case 29: // elementary_type -> LREAL
#line 186 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.LReal;}
#line default
        break;
      case 30: // elementary_type -> DATE
#line 187 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.Date;}
#line default
        break;
      case 31: // elementary_type -> TIME_OF_DAY
#line 188 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.TimeOfDay;}
#line default
        break;
      case 32: // elementary_type -> TOD
#line 189 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.TimeOfDay;}
#line default
        break;
      case 33: // elementary_type -> DATE_AND_TIME
#line 190 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.DateAndTime;}
#line default
        break;
      case 34: // elementary_type -> DT
#line 191 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.DateAndTime;}
#line default
        break;
      case 35: // elementary_type -> TIME
#line 192 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.Time;}
#line default
        break;
      case 36: // elementary_type -> BOOL
#line 193 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.Bool;}
#line default
        break;
      case 37: // elementary_type -> BYTE
#line 194 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.Byte;}
#line default
        break;
      case 38: // elementary_type -> WORD
#line 195 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.Word;}
#line default
        break;
      case 39: // elementary_type -> DWORD
#line 196 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.DWord;}
#line default
        break;
      case 40: // elementary_type -> LWORD
#line 197 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.LWord;}
#line default
        break;
      case 41: // elementary_type -> WCHAR
#line 198 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.WChar;}
#line default
        break;
      case 42: // elementary_type -> CHAR
#line 199 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.Char;}
#line default
        break;
      case 43: // generic_type -> ANY
#line 202 "stlang.y"
                                 {CurrentSemanticValue.DataType = TypeNode.Any;}
#line default
        break;
      case 44: // generic_type -> ANY_NUM
#line 203 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.AnyNum;}
#line default
        break;
      case 45: // generic_type -> ANY_INT
#line 204 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.AnyInt;}
#line default
        break;
      case 46: // generic_type -> ANY_REAL
#line 205 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.AnyReal;}
#line default
        break;
      case 47: // generic_type -> ANY_BIT
#line 206 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.AnyBit;}
#line default
        break;
      case 48: // generic_type -> ANY_DATE
#line 207 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.AnyDate;}
#line default
        break;
      case 49: // generic_type -> ANY_DERIVED
#line 208 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.AnyDerived;}
#line default
        break;
      case 50: // generic_type -> ANY_ELEMENTARY
#line 209 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.AnyElementary;}
#line default
        break;
      case 51: // generic_type -> ANY_MAGNITUDE
#line 210 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.AnyMagnitude;}
#line default
        break;
      case 52: // generic_type -> ANY_STRING
#line 211 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.AnyString;}
#line default
        break;
      case 53: // derived_type -> IDENT
#line 214 "stlang.y"
                                 {CurrentSemanticValue.DataType = this.GetDerivedType(ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 64: // data_type -> generic_type
#line 229 "stlang.y"
                     {CurrentSemanticValue.DataType = TypeNode.Error; this.report.SemanticError(51, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 65: // data_type_spec -> data_type, opt_decl_qualifier
#line 232 "stlang.y"
                                               {CurrentSemanticValue.TypeSpec = this.MakeDataTypeSpec(ValueStack[ValueStack.Depth-2].DataType, ValueStack[ValueStack.Depth-1].EdgeQualifier, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 66: // Anon@2 -> /* empty */
#line 233 "stlang.y"
                                          {this.Push(ValueStack[ValueStack.Depth-3].DataType);}
#line default
        break;
      case 67: // data_type_spec -> data_type, opt_decl_qualifier, ASSIGN, Anon@2, initial_value
#line 233 "stlang.y"
                                                                          {CurrentSemanticValue.TypeSpec = this.MakeDataTypeSpec(ValueStack[ValueStack.Depth-5].DataType, ValueStack[ValueStack.Depth-4].EdgeQualifier, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-4]);}
#line default
        break;
      case 68: // array_type -> ARRAY, '[', subrange_list, ']', OF, non_generic_type
#line 236 "stlang.y"
                                                                   {CurrentSemanticValue.DataType = this.MakeArrayType(ValueStack[ValueStack.Depth-4].Subranges, ValueStack[ValueStack.Depth-1].DataType, LocationStack[LocationStack.Depth-4], LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 69: // array_type -> ARRAY, '[', error, ']', OF, non_generic_type
#line 237 "stlang.y"
                                              {CurrentSemanticValue.DataType = TypeNode.Error; this.yyerrok();}
#line default
        break;
      case 70: // Anon@3 -> /* empty */
#line 241 "stlang.y"
                         {this.CheckNestingDepth(LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 71: // struct_member_decls -> STRUCT, Anon@3, struct_member_decl
#line 241 "stlang.y"
                                                                          {CurrentSemanticValue.StructDecl = this.MakeStructMemberList(ValueStack[ValueStack.Depth-1].MemberDecl);}
#line default
        break;
      case 72: // struct_member_decls -> struct_member_decls, struct_member_decl
#line 242 "stlang.y"
                                                                          {CurrentSemanticValue.StructDecl = this.AddStructMemberDecl(ValueStack[ValueStack.Depth-2].StructDecl, ValueStack[ValueStack.Depth-1].MemberDecl, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 73: // struct_member_decl -> IDENT, ':', data_type_spec, semicolon
#line 246 "stlang.y"
                                                      {CurrentSemanticValue.MemberDecl = this.MakeStructMemberDecl(ValueStack[ValueStack.Depth-4].Ident, ValueStack[ValueStack.Depth-2].TypeSpec, LocationStack[LocationStack.Depth-4]);}
#line default
        break;
      case 74: // structure_type -> struct_member_decls, END_STRUCT
#line 249 "stlang.y"
                                                 {CurrentSemanticValue.DataType = this.MakeStructDataType(ValueStack[ValueStack.Depth-2].StructDecl);}
#line default
        break;
      case 75: // Anon@4 -> /* empty */
#line 250 "stlang.y"
             {this.CheckNestingDepth(LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 76: // structure_type -> STRUCT, Anon@4, error, END_STRUCT
#line 252 "stlang.y"
                 {CurrentSemanticValue.DataType = TypeNode.Error; this.yyerrok();}
#line default
        break;
      case 77: // structure_type -> struct_member_decls, error, END_STRUCT
#line 253 "stlang.y"
                                           {CurrentSemanticValue.DataType = this.MakeStructDataType(ValueStack[ValueStack.Depth-3].StructDecl); this.yyerrok();}
#line default
        break;
      case 78: // enum_identifier -> IDENT
#line 256 "stlang.y"
                                                     {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 79: // enum_identifier -> TYPED_ENUM
#line 257 "stlang.y"
                                                     {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].TypedEnum.Value; this.report.SyntaxError(169, ValueStack[ValueStack.Depth-1].TypedEnum.ToString(), LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 80: // enum_identifier -> reserved_word
#line 258 "stlang.y"
                                         {CurrentSemanticValue.Ident = ""; this.report.SyntaxError(192, ValueStack[ValueStack.Depth-1].Ident.ToString(), LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 81: // enum_ident_seq -> '(', enum_identifier
#line 261 "stlang.y"
                                                     {CurrentSemanticValue.IdentifierList = this.MakeEnumIdentList(ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 82: // enum_ident_seq -> enum_ident_seq, ',', enum_identifier
#line 262 "stlang.y"
                                                     {CurrentSemanticValue.IdentifierList = this.AddToEnumIdentList(ValueStack[ValueStack.Depth-3].IdentifierList, ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 83: // enum_ident_seq -> enum_ident_seq, enum_identifier
#line 263 "stlang.y"
                                         {CurrentSemanticValue.IdentifierList = this.AddToEnumIdentList(ValueStack[ValueStack.Depth-2].IdentifierList, ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]); this.report.SyntaxError(75, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 84: // enumerated_type -> enum_ident_seq, ')'
#line 266 "stlang.y"
                                                     {CurrentSemanticValue.DataType = this.MakeEnumeratedType(ValueStack[ValueStack.Depth-2].IdentifierList);}
#line default
        break;
      case 85: // enumerated_type -> enum_ident_seq, error, ')'
#line 267 "stlang.y"
                                                     {CurrentSemanticValue.DataType = this.MakeEnumeratedType(ValueStack[ValueStack.Depth-3].IdentifierList); this.yyerrok();}
#line default
        break;
      case 86: // enumerated_type -> '(', error, ')'
#line 268 "stlang.y"
                                         {CurrentSemanticValue.DataType = TypeNode.Error;this.yyerrok();}
#line default
        break;
      case 87: // enumerated_type -> '(', ')'
#line 269 "stlang.y"
                                         {CurrentSemanticValue.DataType = TypeNode.Error; this.report.SyntaxError(166, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 88: // string_type -> STRING, '[', expression, ']'
#line 272 "stlang.y"
                                                     {CurrentSemanticValue.DataType = this.MakeStringType(ValueStack[ValueStack.Depth-2].Expression, LocationStack[LocationStack.Depth-4]);}
#line default
        break;
      case 89: // string_type -> WSTRING, '[', expression, ']'
#line 273 "stlang.y"
                                         {CurrentSemanticValue.DataType = this.MakeWStringType(ValueStack[ValueStack.Depth-2].Expression, LocationStack[LocationStack.Depth-4]);}
#line default
        break;
      case 90: // string_type -> STRING
#line 274 "stlang.y"
                                         {CurrentSemanticValue.DataType = TypeNode.String;}
#line default
        break;
      case 91: // string_type -> WSTRING
#line 275 "stlang.y"
                                         {CurrentSemanticValue.DataType = TypeNode.WString;}
#line default
        break;
      case 92: // Anon@5 -> /* empty */
#line 278 "stlang.y"
                                       {this.SubrangeTypeStart(ValueStack[ValueStack.Depth-2].DataType);}
#line default
        break;
      case 93: // subrange_type -> non_generic_type, '(', Anon@5, subrange, ')'
#line 278 "stlang.y"
                                                                                        {CurrentSemanticValue.DataType = this.MakeSubrangeType(ValueStack[ValueStack.Depth-5].DataType, ValueStack[ValueStack.Depth-2].Subrange, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 94: // Anon@6 -> /* empty */
#line 281 "stlang.y"
                      {this.PushArrayElemType(LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 95: // array_init_seq -> '[', Anon@6, initializer
#line 281 "stlang.y"
                                                                {CurrentSemanticValue.InitList = this.MakeArrayInitializer(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);    }
#line default
        break;
      case 96: // array_init_seq -> array_init_seq, ',', initializer
#line 282 "stlang.y"
                                                    {CurrentSemanticValue.InitList = this.AddArrayInitializer(ValueStack[ValueStack.Depth-3].InitList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]); }
#line default
        break;
      case 97: // struct_init_seq -> '(', initializer
#line 285 "stlang.y"
                                                                {CurrentSemanticValue.InitList = this.MakeStructInitializer(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 98: // struct_init_seq -> struct_init_seq, ',', initializer
#line 286 "stlang.y"
                                                    {CurrentSemanticValue.InitList = this.AddStructMemberInitializer(ValueStack[ValueStack.Depth-3].InitList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 99: // array_init_list -> array_init_seq, ']'
#line 289 "stlang.y"
                                                                {CurrentSemanticValue.InitList = this.WrapUpArrayInitList(ValueStack[ValueStack.Depth-2].InitList, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 100: // array_init_list -> array_init_seq, error, ']'
#line 290 "stlang.y"
                                                     {CurrentSemanticValue.InitList = this.WrapUpArrayInitList(ValueStack[ValueStack.Depth-3].InitList, LocationStack[LocationStack.Depth-1]); this.yyerrok();}
#line default
        break;
      case 101: // array_init_list -> '[', error, ']'
#line 291 "stlang.y"
                                                    {CurrentSemanticValue.InitList = null; this.yyerrok();}
#line default
        break;
      case 102: // array_init_list -> '[', ']'
#line 292 "stlang.y"
                                                    {CurrentSemanticValue.InitList = null; this.report.Warning(19, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 103: // struct_init_list -> struct_init_seq, ')'
#line 296 "stlang.y"
                                                                {CurrentSemanticValue.InitList = this.WrapUpStructInitList(ValueStack[ValueStack.Depth-2].InitList, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 104: // struct_init_list -> struct_init_seq, error, ')'
#line 297 "stlang.y"
                                                    {CurrentSemanticValue.InitList = this.WrapUpStructInitList(ValueStack[ValueStack.Depth-3].InitList, LocationStack[LocationStack.Depth-1]); this.yyerrok();}
#line default
        break;
      case 105: // struct_init_list -> '(', ')'
#line 298 "stlang.y"
                                                             {CurrentSemanticValue.InitList = null; this.report.Warning(19, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 106: // initializer -> initial_value
#line 301 "stlang.y"
                                                                               {CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].Expression;}
#line default
        break;
      case 107: // Anon@7 -> /* empty */
#line 302 "stlang.y"
                  {this.CheckIfArrayType(LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 108: // initializer -> INT_LIT, '(', Anon@7, error, ')'
#line 302 "stlang.y"
                                                                   {CurrentSemanticValue.Expression = this.ExpandInitializerSequence(ValueStack[ValueStack.Depth-5].LInt, null, LocationStack[LocationStack.Depth-5]);this.yyerrok();}
#line default
        break;
      case 109: // Anon@8 -> /* empty */
#line 303 "stlang.y"
                  {this.CheckIfArrayType(LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 110: // initializer -> INT_LIT, '(', Anon@8, initializer_seq, ')'
#line 303 "stlang.y"
                                                                   {CurrentSemanticValue.Expression = this.ExpandInitializerSequence(ValueStack[ValueStack.Depth-5].LInt, ValueStack[ValueStack.Depth-2].InitList, LocationStack[LocationStack.Depth-5]);}
#line default
        break;
      case 111: // Anon@9 -> /* empty */
#line 304 "stlang.y"
            {this.PushFieldType(ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 112: // initializer -> IDENT, Anon@9, ASSIGN, initial_value
#line 304 "stlang.y"
                                                                   {CurrentSemanticValue.Expression = this.MakeStructMemberInit(ValueStack[ValueStack.Depth-4].Ident, ValueStack[ValueStack.Depth-1].Expression);}
#line default
        break;
      case 113: // initializer_seq -> initializer
#line 307 "stlang.y"
                                                        {CurrentSemanticValue.InitList = this.MakeInitializerSequence(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);                    }
#line default
        break;
      case 114: // initializer_seq -> initializer_seq, ',', initializer
#line 308 "stlang.y"
                                            {CurrentSemanticValue.InitList = this.AddInitializerToSequence(ValueStack[ValueStack.Depth-3].InitList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);               }
#line default
        break;
      case 115: // initializer_seq -> initializer_seq, error, initializer
#line 309 "stlang.y"
                                            {CurrentSemanticValue.InitList = this.AddInitializerToSequence(ValueStack[ValueStack.Depth-3].InitList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);this.yyerrok();}
#line default
        break;
      case 116: // initial_value -> expression
#line 312 "stlang.y"
                                                          {CurrentSemanticValue.Expression = this.CheckInitialValue(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 117: // initial_value -> array_init_list
#line 313 "stlang.y"
                                              {CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].InitList;}
#line default
        break;
      case 118: // initial_value -> struct_init_list
#line 314 "stlang.y"
                                              {CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].InitList;}
#line default
        break;
      case 119: // data_type_decl -> TYPE, type_decl_list, END_TYPE
#line 317 "stlang.y"
                                                      {this.isTypeDecl = false;}
#line default
        break;
      case 120: // data_type_decl -> TYPE, type_decl_list, error, END_TYPE
#line 318 "stlang.y"
                                          {this.isTypeDecl = false; this.yyerrok();}
#line default
        break;
      case 121: // data_type_decl -> TYPE, error, END_TYPE
#line 319 "stlang.y"
                                          {this.isTypeDecl = false; this.yyerrok();}
#line default
        break;
      case 122: // Anon@10 -> /* empty */
#line 322 "stlang.y"
                  {this.isTypeDecl = true;}
#line default
        break;
      case 126: // semicolon -> /* empty */
#line 327 "stlang.y"
                  {this.report.SyntaxError(63, this.Scanner.yylloc);}
#line default
        break;
      case 127: // Anon@11 -> /* empty */
#line 330 "stlang.y"
                            {this.derivedTypeName = ValueStack[ValueStack.Depth-2].Ident;}
#line default
        break;
      case 128: // type_decl -> IDENT, ':', Anon@11, data_type_spec, semicolon
#line 330 "stlang.y"
                                                                                   {this.InstallDerivedType(ValueStack[ValueStack.Depth-5].Ident, ValueStack[ValueStack.Depth-2].TypeSpec, LocationStack[LocationStack.Depth-5]);}
#line default
        break;
      case 129: // constant -> TRUE
#line 333 "stlang.y"
                               {CurrentSemanticValue.Expression = this.MakeConstant(true, ValueStack[ValueStack.Depth-1].Ident);}
#line default
        break;
      case 130: // constant -> FALSE
#line 334 "stlang.y"
                   {CurrentSemanticValue.Expression = this.MakeConstant(false, ValueStack[ValueStack.Depth-1].Ident);}
#line default
        break;
      case 131: // constant -> INT_LIT
#line 335 "stlang.y"
                   {CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].LInt);}
#line default
        break;
      case 132: // constant -> REAL_LIT
#line 336 "stlang.y"
                   {CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].LReal);}
#line default
        break;
      case 133: // constant -> TOD_LIT
#line 337 "stlang.y"
                   {CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].TimeOfDay);}
#line default
        break;
      case 134: // constant -> TIME_LIT
#line 338 "stlang.y"
                   {CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].Time);}
#line default
        break;
      case 135: // constant -> DATE_LIT
#line 339 "stlang.y"
                   {CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].Date);}
#line default
        break;
      case 136: // constant -> DT_LIT
#line 340 "stlang.y"
                   {CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].DateTime);}
#line default
        break;
      case 137: // constant -> STRING_LIT
#line 341 "stlang.y"
                   {CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].String, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 138: // constant -> WSTRING_LIT
#line 342 "stlang.y"
                   {CurrentSemanticValue.Expression = this.MakeWString(ValueStack[ValueStack.Depth-1].String, LocationStack[LocationStack.Depth-1]); }
#line default
        break;
      case 139: // constant -> TYPED_INT
#line 343 "stlang.y"
                   {CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].TypedInt, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 140: // constant -> TYPED_REAL
#line 344 "stlang.y"
                   {CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].TypedReal, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 141: // constant -> TYPED_ENUM
#line 345 "stlang.y"
                   {CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].TypedEnum, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 142: // variable -> symbolic_variable
#line 348 "stlang.y"
                                               {CurrentSemanticValue.Expression = this.MakeSymbolicVariable(ValueStack[ValueStack.Depth-1].Expression);}
#line default
        break;
      case 143: // variable -> DIRECT_VAR
#line 349 "stlang.y"
                                      {CurrentSemanticValue.Expression = this.MakeDirectVariable(ValueStack[ValueStack.Depth-1].DirectVar, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 144: // symbolic_variable -> simple_variable
#line 353 "stlang.y"
                                      {CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].Expression;}
#line default
        break;
      case 145: // symbolic_variable -> indexed_variable, ']'
#line 354 "stlang.y"
                                      {CurrentSemanticValue.Expression = this.MakeIndexedVariable(ValueStack[ValueStack.Depth-2].IndexedVariable);}
#line default
        break;
      case 146: // symbolic_variable -> simple_variable, '[', error, ']'
#line 355 "stlang.y"
                                      {CurrentSemanticValue.Expression = Expression.Error; this.yyerrok();}
#line default
        break;
      case 147: // Anon@12 -> /* empty */
#line 358 "stlang.y"
                                      {this.isIndexExpr = true;}
#line default
        break;
      case 148: // indexed_variable -> simple_variable, '[', Anon@12, expression
#line 358 "stlang.y"
                                                                             {CurrentSemanticValue.IndexedVariable = this.MakeIndexedVariable(ValueStack[ValueStack.Depth-4].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-4], LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 149: // indexed_variable -> indexed_variable, ',', expression
#line 359 "stlang.y"
                                      {CurrentSemanticValue.IndexedVariable = this.MakeIndexedVariable(ValueStack[ValueStack.Depth-3].IndexedVariable, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3], LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 150: // simple_variable -> IDENT
#line 362 "stlang.y"
                                                   {CurrentSemanticValue.Expression = this.MakeSimpleVariable(ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);    }
#line default
        break;
      case 151: // simple_variable -> symbolic_variable, '.', IDENT
#line 363 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeSimpleVariable(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 152: // expression -> NOT, expression
#line 366 "stlang.y"
                                                   {CurrentSemanticValue.Expression = this.MakeNotOperator(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 153: // expression -> '-', expression
#line 367 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeUnaryMinusOperator(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 154: // expression -> '+', expression
#line 368 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeUnaryPlusOperator(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 155: // expression -> expression, '=', expression
#line 369 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeEqlOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 156: // expression -> expression, '<', expression
#line 370 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeLesOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 157: // expression -> expression, '>', expression
#line 371 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeGtrOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 158: // expression -> expression, NEQ, expression
#line 372 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeNeqOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 159: // expression -> expression, GEQ, expression
#line 373 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeGeqOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 160: // expression -> expression, LEQ, expression
#line 374 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeLeqOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 161: // expression -> expression, AND, expression
#line 375 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeAndOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 162: // expression -> expression, IOR, expression
#line 376 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeIOrOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 163: // expression -> expression, XOR, expression
#line 377 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeXOrOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 164: // expression -> expression, POW, expression
#line 378 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakePowOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 165: // expression -> expression, MOD, expression
#line 379 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeModOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 166: // expression -> expression, '&', expression
#line 380 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeAndOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 167: // expression -> expression, '+', expression
#line 381 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeAddOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 168: // expression -> expression, '-', expression
#line 382 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeSubOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 169: // expression -> expression, '*', expression
#line 383 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeMulOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 170: // expression -> expression, '/', expression
#line 384 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeDivOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 171: // expression -> '(', expression, ')'
#line 385 "stlang.y"
                                       {CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-2].Expression;}
#line default
        break;
      case 172: // expression -> '(', expression, error
#line 386 "stlang.y"
                                       {CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-2].Expression; this.report.SemanticError(43, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 173: // expression -> prog_org_unit_call
#line 387 "stlang.y"
                                       {CurrentSemanticValue.Expression = this.MakeFunctionCall(ValueStack[ValueStack.Depth-1].POU);       }
#line default
        break;
      case 174: // expression -> constant
#line 388 "stlang.y"
                                       {CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].Expression;                              }
#line default
        break;
      case 175: // expression -> variable
#line 389 "stlang.y"
                                       {CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].Expression; this.CheckIfForLoopVar(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 176: // expression -> '(', error, ')'
#line 390 "stlang.y"
                                       {CurrentSemanticValue.Expression = Expression.Error; this.yyerrok();}
#line default
        break;
      case 177: // pou_parameter -> expression
#line 393 "stlang.y"
                                                   {CurrentSemanticValue.POUParameter = this.MakeParameter(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 178: // pou_parameter -> IDENT, assign, expression
#line 394 "stlang.y"
                                       {CurrentSemanticValue.POUParameter = this.MakeParameter(ValueStack[ValueStack.Depth-3].Ident, ValueStack[ValueStack.Depth-2].Token, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3]);}
#line default
        break;
      case 179: // pou_parameter -> NOT, IDENT, assign, expression
#line 395 "stlang.y"
                                       {CurrentSemanticValue.POUParameter = this.MakeParameter(ValueStack[ValueStack.Depth-3].Ident, ValueStack[ValueStack.Depth-2].Token, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3], true);}
#line default
        break;
      case 180: // pou_call_sequence -> IDENT, '(', pou_parameter
#line 399 "stlang.y"
                                                       {CurrentSemanticValue.POU = this.MakePOUCall(ValueStack[ValueStack.Depth-3].Ident, ValueStack[ValueStack.Depth-1].POUParameter, LocationStack[LocationStack.Depth-3]);}
#line default
        break;
      case 181: // pou_call_sequence -> pou_call_sequence, ',', pou_parameter
#line 400 "stlang.y"
                                                       {CurrentSemanticValue.POU = this.AddPOUParameter(ValueStack[ValueStack.Depth-3].POU, ValueStack[ValueStack.Depth-1].POUParameter);}
#line default
        break;
      case 182: // prog_org_unit_call -> IDENT, '(', ')'
#line 404 "stlang.y"
                                                   {CurrentSemanticValue.POU = this.MakePOUCall(ValueStack[ValueStack.Depth-3].Ident, LocationStack[LocationStack.Depth-3]);}
#line default
        break;
      case 183: // prog_org_unit_call -> IDENT, '(', error, ')'
#line 405 "stlang.y"
                                                   {CurrentSemanticValue.POU = this.MakePOUCall(ValueStack[ValueStack.Depth-4].Ident, LocationStack[LocationStack.Depth-4]); this.yyerrok();}
#line default
        break;
      case 184: // prog_org_unit_call -> pou_call_sequence, ')'
#line 406 "stlang.y"
                                                   {CurrentSemanticValue.POU = this.MakePOUCall(ValueStack[ValueStack.Depth-2].POU, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 185: // Anon@13 -> /* empty */
#line 409 "stlang.y"
                  {this.PushTop();}
#line default
        break;
      case 186: // statement_list -> Anon@13, statement, ';'
#line 409 "stlang.y"
                                                   {CurrentSemanticValue.StatList = this.MakeStatementList(ValueStack[ValueStack.Depth-2].Stat);}
#line default
        break;
      case 187: // statement_list -> statement_list, statement, ';'
#line 410 "stlang.y"
                                       {CurrentSemanticValue.StatList = this.AddToStatementList(ValueStack[ValueStack.Depth-3].StatList, ValueStack[ValueStack.Depth-2].Stat, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 188: // statement_list -> error, ';'
#line 411 "stlang.y"
                                       {CurrentSemanticValue.StatList = StatementList.Empty; this.yyerrok();}
#line default
        break;
      case 189: // statement -> WHILE, condition_DO, while_statement_body
#line 415 "stlang.y"
                                    {CurrentSemanticValue.Stat = this.MakeWhileStatement(ValueStack[ValueStack.Depth-2].Expression, ValueStack[ValueStack.Depth-1].StatList, LocationStack[LocationStack.Depth-3]);}
#line default
        break;
      case 190: // Anon@14 -> /* empty */
#line 416 "stlang.y"
             {this.loopNestingDepth++;}
#line default
        break;
      case 191: // statement -> REPEAT, Anon@14, repeat_statement_body
#line 417 "stlang.y"
                                    {CurrentSemanticValue.Stat = ValueStack[ValueStack.Depth-1].Stat;}
#line default
        break;
      case 192: // Anon@15 -> /* empty */
#line 419 "stlang.y"
                      {this.PopTop();}
#line default
        break;
      case 193: // statement -> IF, condition_THEN, statement_list, Anon@15, opt_elsif_stat, 
                //              opt_else_stat, END_IF
#line 422 "stlang.y"
                                       {CurrentSemanticValue.Stat = this.MakeIfStatement(ValueStack[ValueStack.Depth-6].Expression, ValueStack[ValueStack.Depth-5].StatList, ValueStack[ValueStack.Depth-3].GenericList, ValueStack[ValueStack.Depth-2].StatList);}
#line default
        break;
      case 194: // Anon@16 -> /* empty */
#line 423 "stlang.y"
                                              {this.PushForLoopData(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].ForList);}
#line default
        break;
      case 195: // statement -> FOR, control_variable, assign, for_list_DO, Anon@16, 
                //              for_statement_body
#line 424 "stlang.y"
                                    {CurrentSemanticValue.Stat = this.MakeForLoopStatement(ValueStack[ValueStack.Depth-5].Expression, ValueStack[ValueStack.Depth-3].ForList, ValueStack[ValueStack.Depth-1].StatList);}
#line default
        break;
      case 196: // statement -> CASE, expression_OF, case_element_list, END_CASE
#line 427 "stlang.y"
                                          {CurrentSemanticValue.Stat = this.MakeCaseStatement(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-2].CaseElementList, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 197: // statement -> assignment_stat
#line 428 "stlang.y"
                                       {CurrentSemanticValue.Stat = ValueStack[ValueStack.Depth-1].Stat;}
#line default
        break;
      case 198: // statement -> EXIT
#line 429 "stlang.y"
                                       {CurrentSemanticValue.Stat = this.MakeExitStatement(LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 199: // statement -> RETURN
#line 430 "stlang.y"
                                       {CurrentSemanticValue.Stat = this.MakeReturnStatement(LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 200: // statement -> RETURN, expression
#line 431 "stlang.y"
                                       {CurrentSemanticValue.Stat = this.MakeReturnStatement2(LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 201: // statement -> prog_org_unit_call
#line 432 "stlang.y"
                                       {CurrentSemanticValue.Stat = this.MakeFunctionBlockCallStatement(ValueStack[ValueStack.Depth-1].POU);}
#line default
        break;
      case 202: // statement -> /* empty */
#line 433 "stlang.y"
                                       {CurrentSemanticValue.Stat = Statement.Empty;}
#line default
        break;
      case 203: // while_statement_body -> statement_list, END_WHILE
#line 437 "stlang.y"
                                     {CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-2].StatList;}
#line default
        break;
      case 204: // while_statement_body -> statement_list, error, END_WHILE
#line 438 "stlang.y"
                                     {CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-3].StatList;this.yyerrok();}
#line default
        break;
      case 205: // while_statement_body -> error, END_WHILE
#line 439 "stlang.y"
                                     {CurrentSemanticValue.StatList = StatementList.Empty;this.yyerrok();}
#line default
        break;
      case 206: // repeat_statement_body -> statement_list, UNTIL, until_condition
#line 443 "stlang.y"
                                                  {CurrentSemanticValue.Stat = this.MakeRepeatStatement(ValueStack[ValueStack.Depth-3].StatList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3]);}
#line default
        break;
      case 207: // repeat_statement_body -> statement_list, error, UNTIL, until_condition
#line 444 "stlang.y"
                                                  {CurrentSemanticValue.Stat = this.MakeRepeatStatement(ValueStack[ValueStack.Depth-4].StatList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-4]);this.yyerrok();}
#line default
        break;
      case 208: // repeat_statement_body -> error, END_REPEAT
#line 445 "stlang.y"
                                                  {CurrentSemanticValue.Stat = this.MakeRepeatStatement(); this.yyerrok();}
#line default
        break;
      case 209: // for_statement_body -> statement_list, END_FOR
#line 449 "stlang.y"
                                     {CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-2].StatList;}
#line default
        break;
      case 210: // for_statement_body -> statement_list, error, END_FOR
#line 450 "stlang.y"
                                     {CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-3].StatList; this.yyerrok();}
#line default
        break;
      case 211: // for_statement_body -> error, END_FOR
#line 451 "stlang.y"
                                     {CurrentSemanticValue.StatList = StatementList.Empty; this.yyerrok();}
#line default
        break;
      case 212: // condition_DO -> expression, DO
#line 454 "stlang.y"
                                 {CurrentSemanticValue.Expression = this.CheckIfBoolCondition("WHILE-DO", ValueStack[ValueStack.Depth-2].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 213: // condition_DO -> error, DO
#line 455 "stlang.y"
                     {CurrentSemanticValue.Expression = Expression.Error; this.yyerrok();}
#line default
        break;
      case 214: // condition_DO -> expression
#line 456 "stlang.y"
                     {CurrentSemanticValue.Expression = this.CheckIfBoolCondition("WHILE-DO", ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]); this.report.SyntaxError(80, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 215: // condition_THEN -> expression, THEN
#line 459 "stlang.y"
                                   {CurrentSemanticValue.Expression = this.CheckIfBoolCondition("IF-THEN-ELSE", ValueStack[ValueStack.Depth-2].Expression,  LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 216: // condition_THEN -> error, THEN
#line 460 "stlang.y"
                       {CurrentSemanticValue.Expression = Expression.Error; this.yyerrok();}
#line default
        break;
      case 217: // condition_THEN -> expression
#line 461 "stlang.y"
                       {CurrentSemanticValue.Expression = this.CheckIfBoolCondition("IF-THEN-ELSE", ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);this.report.SyntaxError(81, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 218: // until_condition -> expression, END_REPEAT
#line 464 "stlang.y"
                                        {CurrentSemanticValue.Expression = this.CheckIfBoolCondition("REPEAT-UNTIL", ValueStack[ValueStack.Depth-2].Expression, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 219: // until_condition -> error, END_REPEAT
#line 465 "stlang.y"
                            {CurrentSemanticValue.Expression = Expression.Error; this.yyerrok();}
#line default
        break;
      case 220: // until_condition -> expression
#line 466 "stlang.y"
                            {CurrentSemanticValue.Expression = this.CheckIfBoolCondition("REPEAT-UNTIL", ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);this.report.SyntaxError(82, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 221: // expression_OF -> expression, OF
#line 469 "stlang.y"
                                {CurrentSemanticValue.Expression = this.CheckCtrlExpression(LocationStack[LocationStack.Depth-2], ValueStack[ValueStack.Depth-2].Expression);}
#line default
        break;
      case 222: // expression_OF -> error, OF
#line 470 "stlang.y"
                    {CurrentSemanticValue.Expression = this.CheckCtrlExpression(LocationStack[LocationStack.Depth-2]);this.yyerrok();}
#line default
        break;
      case 223: // expression_OF -> expression
#line 471 "stlang.y"
                    {CurrentSemanticValue.Expression = this.CheckCtrlExpression(LocationStack[LocationStack.Depth-1], ValueStack[ValueStack.Depth-1].Expression);this.report.SyntaxError(83, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 224: // control_variable -> variable
#line 474 "stlang.y"
                           {CurrentSemanticValue.Expression = this.SaveControlVariable(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);this.forLoopVarKind = 0x2;}
#line default
        break;
      case 225: // Anon@17 -> /* empty */
#line 477 "stlang.y"
                                {this.forLoopVarKind = 0x4;}
#line default
        break;
      case 226: // for_list_DO -> expression, TO, Anon@17, expression, optional_by_stat, DO
#line 477 "stlang.y"
                                                                                            {CurrentSemanticValue.ForList = this.MakeForLoopData(ValueStack[ValueStack.Depth-6].Expression, ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-2].Expression, LocationStack[LocationStack.Depth-6], LocationStack[LocationStack.Depth-3], LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 227: // Anon@18 -> /* empty */
#line 478 "stlang.y"
               {this.forLoopVarKind = 0x4;}
#line default
        break;
      case 228: // for_list_DO -> error, TO, Anon@18, expression, optional_by_stat, DO
#line 478 "stlang.y"
                                                                                {CurrentSemanticValue.ForList = this.MakeForLoopData(null, ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-2].Expression, null, LocationStack[LocationStack.Depth-3], LocationStack[LocationStack.Depth-2]);this.yyerrok();}
#line default
        break;
      case 229: // for_list_DO -> expression, TO, error, DO
#line 479 "stlang.y"
                                                                                {CurrentSemanticValue.ForList = this.MakeForLoopData(ValueStack[ValueStack.Depth-4].Expression, null, null, LocationStack[LocationStack.Depth-4]);this.yyerrok();}
#line default
        break;
      case 230: // for_list_DO -> error, DO
#line 480 "stlang.y"
                                                                                {CurrentSemanticValue.ForList = this.MakeForLoopData(null, null, null);this.yyerrok();}
#line default
        break;
      case 231: // Anon@19 -> /* empty */
#line 484 "stlang.y"
         {this.forLoopVarKind = 0x8;}
#line default
        break;
      case 232: // optional_by_stat -> BY, Anon@19, expression
#line 484 "stlang.y"
                                                 {CurrentSemanticValue.Expression = this.CheckForLoopIncr(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 233: // optional_by_stat -> /* empty */
#line 485 "stlang.y"
                                                 {CurrentSemanticValue.Expression = MakeIntConstant((long)1);}
#line default
        break;
      case 234: // opt_else_stat -> ELSE, statement_list
#line 488 "stlang.y"
                                       {CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-1].StatList; this.PopTop();  }
#line default
        break;
      case 235: // opt_else_stat -> ELSE, error
#line 489 "stlang.y"
                           {CurrentSemanticValue.StatList = null; this.PopTop();}
#line default
        break;
      case 236: // opt_else_stat -> /* empty */
#line 490 "stlang.y"
                           {CurrentSemanticValue.StatList = null;}
#line default
        break;
      case 237: // opt_elsif_stat -> elsif_stat
#line 493 "stlang.y"
                               {CurrentSemanticValue.GenericList = ValueStack[ValueStack.Depth-1].GenericList;}
#line default
        break;
      case 238: // opt_elsif_stat -> /* empty */
#line 494 "stlang.y"
                   {CurrentSemanticValue.GenericList = null;}
#line default
        break;
      case 239: // default_statement -> ELSE, case_stat_list
#line 498 "stlang.y"
                                {CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-1].StatList;}
#line default
        break;
      case 240: // default_statement -> ELSE, case_stat_list, error
#line 499 "stlang.y"
                                {CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-2].StatList; this.yyerrok();}
#line default
        break;
      case 241: // Anon@20 -> /* empty */
#line 502 "stlang.y"
                  {this.PushTop();}
#line default
        break;
      case 242: // case_stat_list -> Anon@20, statement, ';'
#line 502 "stlang.y"
                                                  {CurrentSemanticValue.StatList = this.MakeCaseStatList(ValueStack[ValueStack.Depth-2].Stat);         }
#line default
        break;
      case 243: // case_stat_list -> case_stat_list, statement, ';'
#line 503 "stlang.y"
                                                  {CurrentSemanticValue.StatList = this.AddToCaseStatList(ValueStack[ValueStack.Depth-3].StatList, ValueStack[ValueStack.Depth-2].Stat, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 245: // case_element -> WHEN, case_label_list, ':', case_stat_list
#line 511 "stlang.y"
                                                          {CurrentSemanticValue.Object = this.MakeCaseElement(ValueStack[ValueStack.Depth-3].CaseLabelList, ValueStack[ValueStack.Depth-1].StatList);}
#line default
        break;
      case 246: // case_element -> WHEN, error, ':', case_stat_list
#line 512 "stlang.y"
                                              {CurrentSemanticValue.Object = this.MakeCaseElement(null, ValueStack[ValueStack.Depth-1].StatList);this.yyerrok();}
#line default
        break;
      case 247: // case_element -> WHEN, case_label_list, case_stat_list
#line 513 "stlang.y"
                                              {CurrentSemanticValue.Object = this.MakeCaseElement(null, ValueStack[ValueStack.Depth-1].StatList); this.report.SyntaxError(91, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 248: // case_element -> default_statement
#line 514 "stlang.y"
                                              {CurrentSemanticValue.Object = this.MakeDefaultCaseElement(ValueStack[ValueStack.Depth-1].StatList);}
#line default
        break;
      case 249: // case_elem_list -> case_element
#line 517 "stlang.y"
                                                  {CurrentSemanticValue.CaseElementList = this.MakeCaseElementList(ValueStack[ValueStack.Depth-1].Object);}
#line default
        break;
      case 250: // case_elem_list -> case_elem_list, case_element
#line 518 "stlang.y"
                                      {CurrentSemanticValue.CaseElementList = this.AddCaseElementToList(ValueStack[ValueStack.Depth-2].CaseElementList, ValueStack[ValueStack.Depth-1].Object, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 251: // case_element_list -> case_elem_list
#line 522 "stlang.y"
                                   {CurrentSemanticValue.CaseElementList = ValueStack[ValueStack.Depth-1].CaseElementList;}
#line default
        break;
      case 252: // case_element_list -> /* empty */
#line 523 "stlang.y"
                       {CurrentSemanticValue.CaseElementList = new List<CaseElement>();}
#line default
        break;
      case 253: // case_label -> expression
#line 526 "stlang.y"
                                   {CurrentSemanticValue.CaseLabel = this.CheckCaseLabel(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 254: // case_label -> subrange
#line 527 "stlang.y"
                       {CurrentSemanticValue.CaseLabel = this.CheckCaseLabel(ValueStack[ValueStack.Depth-1].Subrange, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 255: // case_label_list -> case_label
#line 530 "stlang.y"
                                                  {CurrentSemanticValue.CaseLabelList = this.MakeCaseLabelList(ValueStack[ValueStack.Depth-1].CaseLabel, LocationStack[LocationStack.Depth-1]);     }
#line default
        break;
      case 256: // case_label_list -> case_label_list, ',', case_label
#line 531 "stlang.y"
                                      {CurrentSemanticValue.CaseLabelList = this.AddCaseLabelToList(ValueStack[ValueStack.Depth-3].CaseLabelList, ValueStack[ValueStack.Depth-1].CaseLabel, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 257: // elsif_stat -> ELSIF, condition_THEN, statement_list
#line 535 "stlang.y"
                                   {CurrentSemanticValue.GenericList = this.MakeElseIfStatement(ValueStack[ValueStack.Depth-2].Expression, ValueStack[ValueStack.Depth-1].StatList);}
#line default
        break;
      case 258: // elsif_stat -> elsif_stat, ELSIF, condition_THEN, statement_list
#line 537 "stlang.y"
                                   {CurrentSemanticValue.GenericList = this.AddElseIfStatementToList(ValueStack[ValueStack.Depth-4].GenericList, ValueStack[ValueStack.Depth-2].Expression, ValueStack[ValueStack.Depth-1].StatList);}
#line default
        break;
      case 259: // assignment_stat -> variable, ASSIGN, expression
#line 540 "stlang.y"
                                             {CurrentSemanticValue.Stat = this.MakeAssignmentStatement(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3]);}
#line default
        break;
      case 260: // assignment_stat -> variable, '=', expression
#line 541 "stlang.y"
                                 {CurrentSemanticValue.Stat = this.MakeAssignmentStatement(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3]);}
#line default
        break;
      case 261: // function_body -> statement_list, END_FUNCTION
#line 544 "stlang.y"
                                                      {CurrentSemanticValue.StatList = this.CheckFunctionValueDefinition(ValueStack[ValueStack.Depth-2].StatList, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 262: // function_body -> statement_list, error, END_FUNCTION
#line 545 "stlang.y"
                                                      {CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-3].StatList;this.yyerrok();}
#line default
        break;
      case 263: // function_block_body -> statement_list, END_FUNCTION_BLOCK
#line 550 "stlang.y"
                                              {CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-2].StatList;}
#line default
        break;
      case 264: // function_block_body -> statement_list, error, END_FUNCTION_BLOCK
#line 551 "stlang.y"
                                              {CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-3].StatList; this.yyerrok();}
#line default
        break;
      case 265: // program_body -> statement_list, END_PROGRAM
#line 555 "stlang.y"
                                                          {CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-2].StatList;}
#line default
        break;
      case 266: // program_body -> statement_list, error, END_PROGRAM
#line 556 "stlang.y"
                                                          {CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-3].StatList; this.yyerrok();}
#line default
        break;
      case 267: // Anon@21 -> /* empty */
#line 560 "stlang.y"
                                                      {this.PushSymbolTable(0);}
#line default
        break;
      case 268: // Anon@22 -> /* empty */
#line 561 "stlang.y"
                         {this.InstallFunctionProtoType(ValueStack[ValueStack.Depth-5].Ident, ValueStack[ValueStack.Depth-3].DataType, ValueStack[ValueStack.Depth-1].POUVariableDecls, LocationStack[LocationStack.Depth-6]);}
#line default
        break;
      case 269: // function_decl -> FUNCTION, IDENT, ':', non_generic_type, Anon@21, 
                //                  pou_variable_decls, Anon@22, function_body
#line 562 "stlang.y"
                    {this.SaveFunctionDefinition(ValueStack[ValueStack.Depth-3].POUVariableDecls, ValueStack[ValueStack.Depth-1].StatList);}
#line default
        break;
      case 270: // Anon@23 -> /* empty */
#line 566 "stlang.y"
                             {this.PushSymbolTable(1);}
#line default
        break;
      case 271: // Anon@24 -> /* empty */
#line 567 "stlang.y"
                          {this.InstallFunctionBlockProtoType(ValueStack[ValueStack.Depth-3].Ident, ValueStack[ValueStack.Depth-1].POUVariableDecls, LocationStack[LocationStack.Depth-4]);}
#line default
        break;
      case 272: // function_block_decl -> FUNCTION_BLOCK, IDENT, Anon@23, pou_variable_decls, 
                //                        Anon@24, function_block_body
#line 568 "stlang.y"
                          {this.SaveFunctionBlockDeclaration(ValueStack[ValueStack.Depth-3].POUVariableDecls, ValueStack[ValueStack.Depth-1].StatList);}
#line default
        break;
      case 273: // Anon@25 -> /* empty */
#line 571 "stlang.y"
                                {this.PushSymbolTable(2);}
#line default
        break;
      case 275: // Anon@26 -> /* empty */
#line 576 "stlang.y"
                                              {this.CheckVarTypeQualUsage(STVarType.VAR_INPUT, ValueStack[ValueStack.Depth-1].VarQualifier, LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 276: // input_var_decl -> VAR_INPUT, opt_var_qualifier, Anon@26, var_declaration
#line 577 "stlang.y"
                         {CurrentSemanticValue.Declaration = this.MakeFormalParameterDecl(STVarType.VAR_INPUT, ValueStack[ValueStack.Depth-3].VarQualifier, ValueStack[ValueStack.Depth-1].POUVarDecl);}
#line default
        break;
      case 277: // input_var_decl -> VAR_INPUT, error, END_VAR
#line 578 "stlang.y"
                              {CurrentSemanticValue.Declaration = null; this.yyerrok();}
#line default
        break;
      case 278: // Anon@27 -> /* empty */
#line 581 "stlang.y"
                                        {this.CheckVarTypeQualUsage(STVarType.VAR, ValueStack[ValueStack.Depth-1].VarQualifier, LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 279: // var_decl -> VAR, opt_var_qualifier, Anon@27, var_declaration
#line 582 "stlang.y"
                      {CurrentSemanticValue.Declaration = this.MakeLocalVariableDecl(STVarType.VAR, ValueStack[ValueStack.Depth-3].VarQualifier, ValueStack[ValueStack.Depth-1].POUVarDecl);}
#line default
        break;
      case 280: // var_decl -> VAR, error, END_VAR
#line 583 "stlang.y"
                            {CurrentSemanticValue.Declaration = null; this.yyerrok();}
#line default
        break;
      case 281: // Anon@28 -> /* empty */
#line 586 "stlang.y"
                                               {this.CheckVarTypeQualUsage(STVarType.VAR_OUTPUT, ValueStack[ValueStack.Depth-1].VarQualifier, LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 282: // output_var_decl -> VAR_OUTPUT, opt_var_qualifier, Anon@28, var_declaration
#line 587 "stlang.y"
                      {CurrentSemanticValue.Declaration = this.MakeFormalParameterDecl(STVarType.VAR_OUTPUT, ValueStack[ValueStack.Depth-3].VarQualifier, ValueStack[ValueStack.Depth-1].POUVarDecl);}
#line default
        break;
      case 283: // output_var_decl -> VAR_OUTPUT, error, END_VAR
#line 588 "stlang.y"
                                  {CurrentSemanticValue.Declaration = null; this.yyerrok();}
#line default
        break;
      case 284: // Anon@29 -> /* empty */
#line 591 "stlang.y"
                                               {this.CheckVarTypeQualUsage(STVarType.VAR_OUTPUT, ValueStack[ValueStack.Depth-1].VarQualifier, LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 286: // global_var_decl -> VAR_GLOBAL, error, END_VAR
#line 593 "stlang.y"
                               {CurrentSemanticValue.Declaration = null; this.yyerrok();}
#line default
        break;
      case 287: // Anon@30 -> /* empty */
#line 596 "stlang.y"
                                               {this.CheckVarTypeQualUsage(STVarType.VAR_INOUT, ValueStack[ValueStack.Depth-1].VarQualifier,  LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 288: // inout_var_decl -> VAR_IN_OUT, opt_var_qualifier, Anon@30, var_declaration
#line 597 "stlang.y"
                      {CurrentSemanticValue.Declaration = this.MakeFormalParameterDecl(STVarType.VAR_INOUT, ValueStack[ValueStack.Depth-3].VarQualifier, ValueStack[ValueStack.Depth-1].POUVarDecl);}
#line default
        break;
      case 289: // inout_var_decl -> VAR_IN_OUT, error, END_VAR
#line 598 "stlang.y"
                               {CurrentSemanticValue.Declaration = null; this.yyerrok();}
#line default
        break;
      case 290: // Anon@31 -> /* empty */
#line 601 "stlang.y"
                                             {this.CheckVarTypeQualUsage(STVarType.VAR_TEMP, ValueStack[ValueStack.Depth-1].VarQualifier,  LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 291: // temp_var_decl -> VAR_TEMP, opt_var_qualifier, Anon@31, var_declaration
#line 602 "stlang.y"
                      {CurrentSemanticValue.Declaration = this.MakeLocalVariableDecl(STVarType.VAR_TEMP, ValueStack[ValueStack.Depth-3].VarQualifier, ValueStack[ValueStack.Depth-1].POUVarDecl);}
#line default
        break;
      case 292: // temp_var_decl -> VAR_TEMP, error, END_VAR
#line 603 "stlang.y"
                             {CurrentSemanticValue.Declaration = null; this.yyerrok();}
#line default
        break;
      case 293: // Anon@32 -> /* empty */
#line 606 "stlang.y"
                                                 {this.CheckVarTypeQualUsage(STVarType.VAR_EXTERNAL, ValueStack[ValueStack.Depth-1].VarQualifier,  LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 295: // extern_var_decl -> VAR_EXTERNAL, error, END_VAR
#line 608 "stlang.y"
                                 {CurrentSemanticValue.Declaration = null; this.yyerrok();}
#line default
        break;
      case 296: // Anon@33 -> /* empty */
#line 611 "stlang.y"
                                               {this.CheckVarTypeQualUsage(STVarType.VAR_ACCESS, ValueStack[ValueStack.Depth-1].VarQualifier,  LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 298: // access_var_decl -> VAR_ACCESS, error, END_VAR
#line 613 "stlang.y"
                               {CurrentSemanticValue.Declaration = null; this.yyerrok();}
#line default
        break;
      case 299: // Anon@34 -> /* empty */
#line 616 "stlang.y"
                                               {this.CheckVarTypeQualUsage(STVarType.VAR_CONFIG, ValueStack[ValueStack.Depth-1].VarQualifier,  LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 301: // config_var_decl -> VAR_CONFIG, error, END_VAR
#line 618 "stlang.y"
                               {CurrentSemanticValue.Declaration = null; this.yyerrok();}
#line default
        break;
      case 302: // pou_variable_decl -> var_decl
#line 622 "stlang.y"
                                  {CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
#line default
        break;
      case 303: // pou_variable_decl -> temp_var_decl
#line 623 "stlang.y"
                      {CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
#line default
        break;
      case 304: // pou_variable_decl -> extern_var_decl
#line 624 "stlang.y"
                      {CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
#line default
        break;
      case 305: // pou_variable_decl -> global_var_decl
#line 625 "stlang.y"
                      {CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
#line default
        break;
      case 306: // pou_variable_decl -> access_var_decl
#line 626 "stlang.y"
                      {CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
#line default
        break;
      case 307: // pou_variable_decl -> config_var_decl
#line 627 "stlang.y"
                      {CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
#line default
        break;
      case 308: // pou_variable_decl -> input_var_decl
#line 628 "stlang.y"
                                  {CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
#line default
        break;
      case 309: // pou_variable_decl -> output_var_decl
#line 629 "stlang.y"
                      {CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
#line default
        break;
      case 310: // pou_variable_decl -> inout_var_decl
#line 630 "stlang.y"
                      {CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
#line default
        break;
      case 311: // pou_variable_decl -> data_type_decl
#line 631 "stlang.y"
                      {CurrentSemanticValue.Declaration = null;}
#line default
        break;
      case 312: // pou_var_decl_list -> pou_variable_decl
#line 635 "stlang.y"
                                                       {CurrentSemanticValue.POUVariableDecls = this.MakePOUVarDeclList(ValueStack[ValueStack.Depth-1].Declaration);}
#line default
        break;
      case 313: // pou_var_decl_list -> pou_var_decl_list, pou_variable_decl
#line 636 "stlang.y"
                                           {CurrentSemanticValue.POUVariableDecls = this.AddPOUVarDeclToList(ValueStack[ValueStack.Depth-2].POUVariableDecls, ValueStack[ValueStack.Depth-1].Declaration);}
#line default
        break;
      case 314: // pou_variable_decls -> pou_var_decl_list
#line 640 "stlang.y"
                                    {CurrentSemanticValue.POUVariableDecls = ValueStack[ValueStack.Depth-1].POUVariableDecls;}
#line default
        break;
      case 315: // pou_variable_decls -> /* empty */
#line 641 "stlang.y"
                        {CurrentSemanticValue.POUVariableDecls = this.MakeEmptyPOUVarDecl();}
#line default
        break;
      case 316: // var_decl_list -> var_init_decl, semicolon
#line 644 "stlang.y"
                                                         {CurrentSemanticValue.POUVarDecl = this.MakeVariableDeclList(ValueStack[ValueStack.Depth-2].VarInitDecl);}
#line default
        break;
      case 317: // var_decl_list -> var_decl_list, var_init_decl, semicolon
#line 645 "stlang.y"
                                             {CurrentSemanticValue.POUVarDecl = this.AddToVariableDeclList(ValueStack[ValueStack.Depth-3].POUVarDecl, ValueStack[ValueStack.Depth-2].VarInitDecl);}
#line default
        break;
      case 318: // var_declaration -> var_decl_list, END_VAR
#line 648 "stlang.y"
                                              {CurrentSemanticValue.POUVarDecl = ValueStack[ValueStack.Depth-2].POUVarDecl;}
#line default
        break;
      case 319: // var_declaration -> var_decl_list, error, END_VAR
#line 649 "stlang.y"
                                              {CurrentSemanticValue.POUVarDecl = ValueStack[ValueStack.Depth-3].POUVarDecl;this.yyerrok();}
#line default
        break;
      case 320: // var_init_decl -> identifier_list, ':', data_type, opt_decl_qualifier
#line 652 "stlang.y"
                                                                   {CurrentSemanticValue.VarInitDecl = this.InstallLocalVars(ValueStack[ValueStack.Depth-4].IdentifierList, ValueStack[ValueStack.Depth-2].DataType, ValueStack[ValueStack.Depth-1].EdgeQualifier, LocationStack[LocationStack.Depth-1]);}
#line default
        break;
      case 321: // Anon@35 -> /* empty */
#line 653 "stlang.y"
                                                       {this.Push(ValueStack[ValueStack.Depth-2].DataType);}
#line default
        break;
      case 322: // var_init_decl -> identifier_list, ':', data_type, opt_decl_qualifier, Anon@35, 
                //                  ASSIGN, initial_value
#line 653 "stlang.y"
                                                                                             {CurrentSemanticValue.VarInitDecl = this.InstallLocalVars(ValueStack[ValueStack.Depth-7].IdentifierList, ValueStack[ValueStack.Depth-5].DataType, ValueStack[ValueStack.Depth-4].EdgeQualifier, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3]);}
#line default
        break;
      case 323: // Anon@36 -> /* empty */
#line 654 "stlang.y"
                          {}
#line default
        break;
      case 324: // var_init_decl -> IDENT, AT, DIRECT_VAR, Anon@36, ':', data_type_spec
#line 654 "stlang.y"
                                                       {CurrentSemanticValue.VarInitDecl = this.InstallSymbolicVariable(ValueStack[ValueStack.Depth-6].Ident, ValueStack[ValueStack.Depth-1].TypeSpec, ValueStack[ValueStack.Depth-4].DirectVar, LocationStack[LocationStack.Depth-6]);}
#line default
        break;
      case 325: // Anon@37 -> /* empty */
#line 655 "stlang.y"
                    {}
#line default
        break;
      case 326: // var_init_decl -> AT, DIRECT_VAR, Anon@37, ':', data_type_spec
#line 655 "stlang.y"
                                                       {CurrentSemanticValue.VarInitDecl = this.InstallDirectVariable(ValueStack[ValueStack.Depth-4].DirectVar, ValueStack[ValueStack.Depth-1].TypeSpec, LocationStack[LocationStack.Depth-4]);}
#line default
        break;
      case 327: // opt_var_qualifier -> RETAIN
#line 659 "stlang.y"
                      {CurrentSemanticValue.VarQualifier = STVarQualifier.RETAIN;}
#line default
        break;
      case 328: // opt_var_qualifier -> NON_RETAIN
#line 660 "stlang.y"
                      {CurrentSemanticValue.VarQualifier = STVarQualifier.NON_RETAIN;}
#line default
        break;
      case 329: // opt_var_qualifier -> CONSTANT
#line 661 "stlang.y"
                      {CurrentSemanticValue.VarQualifier = STVarQualifier.CONSTANT;}
#line default
        break;
      case 330: // opt_var_qualifier -> CONSTANT, RETAIN
#line 662 "stlang.y"
                      {CurrentSemanticValue.VarQualifier = STVarQualifier.CONSTANT; this.report.SemanticError(173, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 331: // opt_var_qualifier -> RETAIN, CONSTANT
#line 663 "stlang.y"
                      {CurrentSemanticValue.VarQualifier = STVarQualifier.CONSTANT; this.report.SemanticError(173, LocationStack[LocationStack.Depth-2]);}
#line default
        break;
      case 332: // opt_var_qualifier -> /* empty */
#line 664 "stlang.y"
                      {CurrentSemanticValue.VarQualifier = STVarQualifier.NONE;}
#line default
        break;
      case 333: // opt_decl_qualifier -> R_EDGE
#line 668 "stlang.y"
                      {CurrentSemanticValue.EdgeQualifier = STDeclQualifier.R_EDGE;}
#line default
        break;
      case 334: // opt_decl_qualifier -> F_EDGE
#line 669 "stlang.y"
                      {CurrentSemanticValue.EdgeQualifier = STDeclQualifier.F_EDGE;}
#line default
        break;
      case 335: // opt_decl_qualifier -> READ_ONLY
#line 670 "stlang.y"
                      {CurrentSemanticValue.EdgeQualifier = STDeclQualifier.READ_ONLY;}
#line default
        break;
      case 336: // opt_decl_qualifier -> WRITE_ONLY
#line 671 "stlang.y"
                      {CurrentSemanticValue.EdgeQualifier = STDeclQualifier.WRITE_ONLY;}
#line default
        break;
      case 337: // opt_decl_qualifier -> /* empty */
#line 672 "stlang.y"
                      {CurrentSemanticValue.EdgeQualifier = STDeclQualifier.NONE;}
#line default
        break;
      case 338: // reserved_word -> elementary_type
#line 675 "stlang.y"
                                      {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].DataType.Name;}
#line default
        break;
      case 339: // reserved_word -> STRING
#line 676 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 340: // reserved_word -> WSTRING
#line 677 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 341: // reserved_word -> RETAIN
#line 678 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 342: // reserved_word -> NON_RETAIN
#line 679 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 343: // reserved_word -> CONSTANT
#line 680 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 344: // reserved_word -> R_EDGE
#line 681 "stlang.y"
                                   {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 345: // reserved_word -> F_EDGE
#line 682 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 346: // reserved_word -> READ_ONLY
#line 683 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 347: // reserved_word -> WRITE_ONLY
#line 684 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 348: // reserved_word -> VAR_INPUT
#line 685 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 349: // reserved_word -> VAR_OUTPUT
#line 686 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 350: // reserved_word -> VAR_IN_OUT
#line 687 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 351: // reserved_word -> VAR_GLOBAL
#line 688 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 352: // reserved_word -> VAR_ACCESS
#line 689 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 353: // reserved_word -> VAR_CONFIG
#line 690 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 354: // reserved_word -> VAR_TEMP
#line 691 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 355: // reserved_word -> VAR_EXTERNAL
#line 692 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 356: // reserved_word -> VAR
#line 693 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 357: // reserved_word -> END_VAR
#line 694 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 358: // reserved_word -> AT
#line 695 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 359: // reserved_word -> FUNCTION
#line 696 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 360: // reserved_word -> END_FUNCTION
#line 697 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 361: // reserved_word -> FUNCTION_BLOCK
#line 698 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 362: // reserved_word -> END_FUNCTION_BLOCK
#line 699 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 363: // reserved_word -> PROGRAM
#line 700 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 364: // reserved_word -> END_PROGRAM
#line 701 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 365: // reserved_word -> IF
#line 702 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 366: // reserved_word -> THEN
#line 703 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 367: // reserved_word -> ELSE
#line 704 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 368: // reserved_word -> ELSIF
#line 705 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 369: // reserved_word -> END_IF
#line 706 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 370: // reserved_word -> WHILE
#line 707 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 371: // reserved_word -> END_WHILE
#line 708 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 372: // reserved_word -> REPEAT
#line 709 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 373: // reserved_word -> UNTIL
#line 710 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 374: // reserved_word -> END_REPEAT
#line 711 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 375: // reserved_word -> FOR
#line 712 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 376: // reserved_word -> TO
#line 713 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 377: // reserved_word -> BY
#line 714 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 378: // reserved_word -> DO
#line 715 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 379: // reserved_word -> END_FOR
#line 716 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 380: // reserved_word -> CASE
#line 717 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 381: // reserved_word -> OF
#line 718 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 382: // reserved_word -> END_CASE
#line 719 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 383: // reserved_word -> EXIT
#line 720 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 384: // reserved_word -> RETURN
#line 721 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 385: // reserved_word -> TYPE
#line 722 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 386: // reserved_word -> END_TYPE
#line 723 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 387: // reserved_word -> ARRAY
#line 724 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 388: // reserved_word -> STRUCT
#line 725 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 389: // reserved_word -> END_STRUCT
#line 726 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 390: // reserved_word -> AND
#line 727 "stlang.y"
                          {CurrentSemanticValue.Ident = "AND";}
#line default
        break;
      case 391: // reserved_word -> NOT
#line 728 "stlang.y"
                          {CurrentSemanticValue.Ident = "NOT";}
#line default
        break;
      case 392: // reserved_word -> IOR
#line 729 "stlang.y"
                          {CurrentSemanticValue.Ident = "OR";}
#line default
        break;
      case 393: // reserved_word -> XOR
#line 730 "stlang.y"
                          {CurrentSemanticValue.Ident = "XOR";}
#line default
        break;
      case 394: // reserved_word -> MOD
#line 731 "stlang.y"
                          {CurrentSemanticValue.Ident = "MOD";}
#line default
        break;
      case 395: // reserved_word -> CONFIGURATION
#line 732 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 396: // reserved_word -> END_CONFIGURATION
#line 733 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 397: // reserved_word -> TRANSITION
#line 734 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 398: // reserved_word -> END_TRANSITION
#line 735 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 399: // reserved_word -> RESOURCE
#line 736 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 400: // reserved_word -> END_RESOURCE
#line 737 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 401: // reserved_word -> WITH
#line 738 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
      case 402: // reserved_word -> TASK
#line 739 "stlang.y"
                          {CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
#line default
        break;
    }
#pragma warning restore 162, 1522
  }

  protected override string TerminalToString(int terminal)
  {
    if (aliases != null && aliases.ContainsKey(terminal))
        return aliases[terminal];
    else if (((Tokens)terminal).ToString() != terminal.ToString(CultureInfo.InvariantCulture))
        return ((Tokens)terminal).ToString();
    else
        return CharToString((char)terminal);
  }

#line 743 "stlang.y"
	public STLangParser(STLangScanner scanner, ErrorHandler errorHandler) : base(scanner) 
	{ 
		this.report = errorHandler;
		Expression.Report = errorHandler;
		TypeNode.Report = errorHandler;
		STLangSymbol.Report = errorHandler;
		errorHandler.Scanner = scanner;
		this.structNestingDepth = 0;
		this.forLoopVarKind = 0;
		this.loopNestingDepth = 0;
		this.functionValueDef = new List<bool>(){false};
		this.forLoopVarTable = new List<Hashtable>();
		this.forLoopDataList = new List<ForLoopData>();
		this.attributeStack = new SemanticStack(errorHandler);
		constantTable = new Dictionary<string, Expression>();
		this.rwMemoryManager = new RWMemoryLayoutManager();
		this.symbolTable = new STLangSymbolTable(errorHandler);
		this.caseLabelStack = null;
		this.isFunctionDecl = false;
		this.isProgramDecl  = false;
		this.isFunctionBlockDecl = false;
		this.variablePosition = 0;
		this.isTypeDecl = false;
		this.isIndexExpr = false;
		this.isSubrangeDecl = false;
		this.subrangeDataType = TypeNode.Error;
	}

	public int Errors
    {
        get { return this.report.Errors; }
    }

    public int Warnings
    {
        get { return this.report.Warnings; }
    }

    public IEnumerable<string> Messages
    {
        get { return this.report.ErrorMessages; }
    }

	private STVarType variableType;

	private STVarQualifier variableQualifier;

	private int structNestingDepth;

	private int forLoopVarKind;

	private int loopNestingDepth;

	private static Dictionary<string, Expression> constantTable;

	private readonly List<Hashtable> forLoopVarTable;

	private readonly List<bool> functionValueDef;

	private readonly ErrorHandler report;

	private readonly STLangSymbolTable symbolTable;

	private readonly SemanticStack attributeStack;

	private RWMemoryLayoutManager rwMemoryManager;

	private List<List<CaseLabel>> caseLabelStack;

	private List<ForLoopData> forLoopDataList;

	private List<CaseLabel> caseLabelList;

	private int variablePosition;

	private bool isProgramDecl;

	private bool isFunctionDecl;

	private bool isFunctionBlockDecl;

	private bool isTypeDecl;

	private bool isIndexExpr;

	private string derivedTypeName;

	private TypeNode subrangeDataType;

	private bool isSubrangeDecl;

	private void ReInitializeParser()
	{
		this.structNestingDepth = 0;
		this.forLoopVarKind = 0;
		this.loopNestingDepth = 0;
		this.forLoopVarTable.Clear();
		this.attributeStack.Clear();
		this.functionValueDef.Clear();
		this.functionValueDef.Add(false);
		constantTable = new Dictionary<string, Expression>();
		this.symbolTable.ReInitialize();
		this.isFunctionDecl = false;
		this.isProgramDecl  = false;
		this.isFunctionBlockDecl = false;
		this.variablePosition = 0;
		this.isTypeDecl = false;
		this.isIndexExpr = false;
		this.isSubrangeDecl = false;
		this.subrangeDataType = TypeNode.Error;
		this.rwMemoryManager = new RWMemoryLayoutManager();
	}

	private DataTypeSpec MakeDataTypeSpec(TypeNode dataType, STDeclQualifier declQualifier, LexLocation location)
	{
		if (declQualifier != STDeclQualifier.NONE)
		{
			if (dataType != TypeNode.Error && dataType != TypeNode.Bool)
			{
				this.report.SemanticError(120, location);
				declQualifier = STDeclQualifier.NONE;
			}
			if (this.structNestingDepth > 0)
			{
				this.report.SemanticError(121, location);
				declQualifier = STDeclQualifier.NONE;
			}
		}
		return new DataTypeSpec(dataType, declQualifier, dataType.DefaultValue);
	}

	private DataTypeSpec MakeDataTypeSpec(TypeNode dataType, STDeclQualifier declQualifier, Expression initialValue, LexLocation location)
	{
		if (declQualifier != STDeclQualifier.NONE)
		{
			if (dataType != TypeNode.Bool)
			{
				this.report.SemanticError(120, location);
				declQualifier = STDeclQualifier.NONE;
			}
			if (this.structNestingDepth > 0)
			{
				this.report.SemanticError(121, location);
				declQualifier = STDeclQualifier.NONE;
			}
		}
		this.Pop();
		return new DataTypeSpec(dataType, declQualifier, initialValue);
	}

	private List<string> MakeIdentifierList(string ident, LexLocation location)
	{
		List<string> identList = new List<string>();
		if (this.symbolTable.IsValidUserDefinedSymbol(ident, location))
			identList.Add(ident);
		return identList;
	}

	private List<string> AddIdentToList(List<string> identList, string ident, LexLocation location)
	{
		if (identList == null)
			return this.MakeIdentifierList(ident, location);
		else if (! identList.IsUnique(ident))
			this.report.SemanticError(2, ident, location);
		else if (this.symbolTable.IsValidUserDefinedSymbol(ident, location))
			identList.Add(ident);
		return identList;
	}

	// void RegisterForLoopVariable(InstanceSymbol symbol, ForLoopVariableType loopVarType)
	//
	// Keeps track of variables used as control variables, start-, stop-values and increments in for-loops.
	// This information is used to check that these variables aren't changed inside the loop.
	//
	private void RegisterForLoopVariable(InstanceSymbol symbol, ForLoopVariableType loopVarType, LexLocation location)
	{
		if (loopVarType == ForLoopVariableType.CONTROL_VARIABLE)
		{
			// Make sure that the variable isn't already used as a control 
			// variable, start-value or stop-value in any outer for-loop.

			foreach (Hashtable loopVarTable in this.forLoopVarTable)
			{
				if (loopVarTable.Contains(symbol))
				{
					ForLoopVariableType forLoopVarType;
					forLoopVarType = (ForLoopVariableType)loopVarTable[symbol];
					if ((forLoopVarType & ForLoopVariableType.CONTROL_VARIABLE) != 0)
						this.report.SemanticError(125, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.START_VARIABLE) != 0)
						this.report.SemanticError(126, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.STOP_VARIABLE) != 0)
						this.report.SemanticError(127, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.INCR_VARIABLE) != 0)
						this.report.Warning(15, symbol.Name, location);
				}
			}
			Hashtable currentLoopVarTable = new Hashtable();
			currentLoopVarTable[symbol] = ForLoopVariableType.CONTROL_VARIABLE;
			this.forLoopVarTable.Add(currentLoopVarTable);
		}
		else {
			Hashtable loopVarTable = this.forLoopVarTable.Last();
			if (loopVarTable == null)
				throw new STLangCompilerError("For-loop variable table is empty.");
			else if (! loopVarTable.Contains(symbol))
				loopVarTable[symbol] = loopVarType;
			else {
				ForLoopVariableType forLoopVarType;

				forLoopVarType = (ForLoopVariableType)loopVarTable[symbol];
				if ((forLoopVarType & ForLoopVariableType.CONTROL_VARIABLE) == 0)
				{
					forLoopVarType |= loopVarType;
					loopVarTable[symbol] = forLoopVarType;
				}
				else if (loopVarType == ForLoopVariableType.START_VARIABLE)
					this.report.SemanticError(126, symbol.Name, location);
				else if (loopVarType == ForLoopVariableType.STOP_VARIABLE)
					this.report.SemanticError(127, symbol.Name, location);
				else if (loopVarType == ForLoopVariableType.INCR_VARIABLE)
					this.report.Warning(15, symbol.Name, location);
			}
		}
	}


	private void PopForLoopVariables()
	{
		if (this.forLoopVarTable.Count > 0)
		{
			Hashtable currentLoopVars = this.forLoopVarTable.Last();
			this.forLoopVarTable.Remove(currentLoopVars);
			ForLoopData forLoopData = this.forLoopDataList.Last();
			this.forLoopDataList.Remove(forLoopData);
			forLoopData.ControlVariable.Symbol.IsForLoopCtrlVar = false;
		}
	}

	private void Push(Expression expression)
	{
		if (expression == null)
			this.attributeStack.Push(TypeNode.Error);
		else
			this.attributeStack.Push(expression.DataType);
	}

	private void PushTop()
	{
		if (this.functionValueDef.Count == 0)
			throw new STLangCompilerError("Function value stack is empty.");
		else {
			bool topValue = this.functionValueDef.Last();
			this.functionValueDef.Add(topValue);
		}
	}

	private void PushCaseLabelList()
	{
		if (this.caseLabelStack == null)
		{
			this.caseLabelStack = new List<List<CaseLabel>>();
			this.caseLabelList = new List<CaseLabel>();
			this.caseLabelStack.Add(this.caseLabelList);
		}
		else {
			this.caseLabelStack.Add(this.caseLabelList);
			this.caseLabelList = new List<CaseLabel>();
		}
	}

	private void PopCaseLabelList()
	{
		if (this.caseLabelStack.Count == 0)
			throw new STLangCompilerError("PopCaseLabelList(): Case label stack is empty.");
		else {
			int lastIndex = this.caseLabelStack.Count - 1;
			this.caseLabelStack.RemoveAt(lastIndex);
			if (this.caseLabelStack.Count > 0)
                this.caseLabelList = this.caseLabelStack.Last();
            else {
				this.caseLabelStack = null;
				this.caseLabelList = null;
			} 
		}
	}

	private void CopyValue(bool funcValueDefined)
	{
		if (this.functionValueDef.Count == 0)
			throw new STLangCompilerError("CopyValue(): Function value stack is empty.");
		else {
			bool currentValue = this.functionValueDef.Last();
			if (funcValueDefined && ! currentValue)
			{
				int topIndex = this.functionValueDef.Count - 1;
				this.functionValueDef[topIndex] = true;
			}
		}
	}

	private void PopTop()
	{
		if (this.functionValueDef.Count == 0)
			throw new STLangCompilerError("Function value stack is empty.");
		else if (this.functionValueDef.Count > 1)
		{
			int topIndex = this.functionValueDef.Count - 1;
			this.functionValueDef.RemoveAt(topIndex);
		}
	}

	private void CheckFunctionValueIsDefined(LexLocation location)
	{
		if (this.functionValueDef.Count == 0)
			throw new STLangCompilerError("Function value stack is empty.");
		else {
			bool functionValueIsDefined = this.functionValueDef.Last();
			if (! functionValueIsDefined)
				this.report.SemanticError(13, location);
		}
	}

	private StatementList CheckFunctionValueDefinition(StatementList statementList, LexLocation loc)
	{
		this.CheckFunctionValueIsDefined(loc);
		if (statementList == null)
			statementList = StatementList.Empty;
		return statementList;
	}

	private void SaveFunctionDefinition(POUVarDeclarations varDecls, StatementList functionBody)
	{
		this.symbolTable.Pop();
		if (! functionBody.POUReturns)
			functionBody.Add(new ReturnStatement());  // Make sure the function returns
		this.rwMemoryManager.SetSegmentAlignment(sizeof(double));
		varDecls.SetDeclarationSize(this.rwMemoryManager);
		this.symbolTable.SaveFunctionDefinition(functionBody, constantTable, this.rwMemoryManager);
	}

	private void SaveFunctionBlockDeclaration(POUVarDeclarations fbVarDecls, StatementList functionBlockBody)
	{
		this.symbolTable.Pop();
		if (! functionBlockBody.POUReturns)
			functionBlockBody.Add(new ReturnStatement()); // Make sure the function block returns
		this.rwMemoryManager.SetSegmentAlignment(sizeof(double));
		fbVarDecls.SetDeclarationSize(this.rwMemoryManager);
		this.symbolTable.SaveFunctionBlockBody(functionBlockBody, constantTable, this.rwMemoryManager);
	}

	private void CheckIfArrayType(LexLocation location)
	{
		this.attributeStack.CheckIfArrayType(location);
	}

	private void PushArrayElemType(LexLocation location)
	{
		this.attributeStack.PushArrayElementType(location);
	}

	private void Push(TypeNode dataType)
	{
		this.attributeStack.Push(dataType);
	}

	private void Pop()
	{
		this.attributeStack.Pop();
	}

	private TypeNode LargestDataType(Expression expr1, Expression expr2)
	{
		return expr1.DataType.Size > expr2.DataType.Size ? expr1.DataType : expr2.DataType;
	}

	private StructMemberInit MakeStructMemberInit(string name, Expression initValue)
	{
		TypeNode fieldDataType = this.attributeStack.Top;
		this.Pop();
		if (initValue == null)
			return new StructMemberInit(name, fieldDataType.DefaultValue);
		else
			return new StructMemberInit(name, initValue);
	}

	private InitializerList MakeInitializerSequence(Expression initializer, LexLocation loc)
	{
		TypeNode dataType = this.attributeStack.Top;
		InitializerSequence initSequence = new InitializerSequence(dataType);
		initSequence.Add(initializer, loc);
		return initSequence;
	}

	private InitializerList AddInitializerToSequence(InitializerList initSequence, Expression initializer, LexLocation loc)
	{
		if (initSequence != null)
			initSequence.Add(initializer, loc);
		return initSequence;
	}

	private TypeNode MakeInitializerDataType(uint elementCount, TypeNode elementType)
	{
		string typeID;
		TypeNode arrayType;
		
		typeID = string.Format("[0..{0}]{1}", elementCount - 1, elementType.TypeID);
		if (TypeNode.LookUpType(typeID, out arrayType))
			return arrayType;
		else {
			int upper = (int)elementCount - 1;
			long byteCount = elementCount * elementType.Size;
			Expression size =  MakeIntConstant(byteCount);
			string typeName = string.Format("ARRAY [0..{0}] OF {1}", upper, elementType.Name);
			return new ArrayType(typeName, 0, upper, (uint)byteCount, size, elementType, elementType, typeID);
		}
	}

	private InitializerList MakeArrayOfStructInitializer(TypeNode array, FieldSymbol firstField, uint elementCount)
	{
		TypeNode dataType;
		TypeNode fieldDataType;
        InitializerList arrayInit;
		FieldSymbol field = firstField;
		Expression size   = MakeIntConstant(array.Size);
		ArrayOfStructInitializer arrayOfStructInitializer;

		arrayOfStructInitializer = new ArrayOfStructInitializer(array, size);
		while (field != null)
		{
			fieldDataType = field.DataType;
			if (fieldDataType.IsElementaryType || fieldDataType.IsAnyStringType)
			{
				dataType = this.MakeInitializerDataType(elementCount, fieldDataType);
				size = MakeIntConstant((long)dataType.Size);
				arrayInit = new ArrayInitializer(dataType, size);
			}
			else if (fieldDataType.IsStructType)
			{
				StructType struct2 = (StructType)fieldDataType.BaseType;
				FieldSymbol firstField2 = struct2.FirstField;
				dataType = this.MakeInitializerDataType(elementCount, fieldDataType);
				arrayInit = this.MakeArrayOfStructInitializer(dataType, firstField2, elementCount);
			}
			else if (fieldDataType.IsArrayType)
			{
				ArrayType array2 = (ArrayType)fieldDataType.BaseType;
				TypeNode elementType = array2.BasicElementType;
				uint elemCount2 = (array2.Size/elementType.Size)*elementCount;
				dataType = this.MakeInitializerDataType(elemCount2, elementType);
				if (elementType.IsElementaryType || elementType.IsAnyStringType)
				{
					size = MakeIntConstant((long)dataType.Size);
					arrayInit = new ArrayInitializer(dataType, size);
				}
                else if (elementType.IsStructType)
                {
                    StructType struct2 = (StructType)elementType.BaseType;
					FieldSymbol firstField2 = struct2.FirstField;
                    arrayInit = this.MakeArrayOfStructInitializer(dataType, firstField2, elemCount2);
                }
				else if (elementType.IsFunctionBlockType)
                {
					//
					// IEC 61131-3 does not allow arrays of function blocks (yet).
					//
                    size = MakeIntConstant((long)elementType.Size);
					arrayInit = new ArrayInitializer(fieldDataType, size); 
                }
				else if (elementType == TypeNode.Error)
				{
					size = MakeIntConstant((long)elementType.Size);
					arrayInit = new ArrayInitializer(elementType, size);
				}
                else
                {
                    string msg = "MakeArrayOfStructInitializer(): Unknown ";
                    msg += "type of array element " + elementType.Name;
                    throw new STLangCompilerError(msg);
                }
			}
			else if (fieldDataType.IsFunctionBlockType)
			{
				//
				// IEC 61131-3 does not allow arrays of function blocks (yet).
				//
				size = MakeIntConstant((long)fieldDataType.Size);
				arrayInit = new ArrayInitializer(fieldDataType, size); 
			}
			else if (fieldDataType == TypeNode.Error)
			{
				size = MakeIntConstant((long)fieldDataType.Size);
				arrayInit = new ArrayInitializer(fieldDataType, size);
			}
			else {
				string msg;
				msg = "MakeArrayOfStructInitializer(): Unknown type " + fieldDataType.Name;
				throw new STLangCompilerError(msg);
			}
			arrayOfStructInitializer.AddInitializer(field.Name, arrayInit);
			field = field.Next;
		}
		return arrayOfStructInitializer;
	}

	private InitializerList MakeArrayInitializer(Expression initializer, LexLocation location)
	{
		InitializerList arrayInitList;
		TypeNode dataType = this.attributeStack.Top2;
		if (initializer == null || ! dataType.IsArrayType)
		{
			Expression size = MakeIntConstant((long)1000);
			arrayInitList = new ArrayInitializer(TypeNode.Error, size);
			arrayInitList.Add(initializer, location);
			return arrayInitList;
		}
		else {
			ArrayType array = (ArrayType)dataType;
			TypeNode elementType = array.BasicElementType;
		
			if (elementType.IsElementaryType || elementType.IsAnyStringType)
			{
				Expression size = MakeIntConstant((long)dataType.Size);
				arrayInitList = new ArrayInitializer(dataType, size);
				arrayInitList.Add(initializer, location);
				return arrayInitList;
			}
			else if (elementType.IsFunctionBlockType)
			{
				//
				// IEC 61131-3 does not allow arrays of function blocks (yet).
				//
				Expression size = MakeIntConstant((long)dataType.Size);
				arrayInitList = new ArrayInitializer(dataType, size);
				return arrayInitList; 
			}
			else if (elementType.IsStructType)
			{
				uint elemCount = array.Size/elementType.Size;
				StructType structure = (StructType)elementType.BaseType;
				FieldSymbol firstField = structure.FirstField;
				arrayInitList = this.MakeArrayOfStructInitializer(array, firstField, elemCount);
				arrayInitList.Add(initializer, location);
				return arrayInitList;
			}
		}
		throw new STLangCompilerError(Resources.MAKEARRAYINITLIST2);
	}

	private InitializerList AddArrayInitializer(InitializerList arrayInitList, Expression initializer, LexLocation loc)
	{
		if (arrayInitList == null)
		{
			TypeNode dataType = this.attributeStack.Top2;
			initializer = dataType.DefaultValue;
		}
		arrayInitList.Add(initializer, loc);
		return arrayInitList;
	}

	private InitializerList WrapUpArrayInitList(InitializerList arrayInitList, LexLocation location)
	{
		this.attributeStack.Pop();
		if (arrayInitList == null)
			return arrayInitList;
		else if (arrayInitList.DataType == TypeNode.Error)
			return arrayInitList;
		else {
			arrayInitList.CheckInitListSize(location);
			if (! arrayInitList.IsConstant)
				return arrayInitList;
			else {
				string key = arrayInitList.GetKey();
				if (! constantTable.ContainsKey(key))
				{
					constantTable[key] = arrayInitList;
					return arrayInitList;
				}
				else {
					Expression initializer;
					initializer = (Expression)constantTable[key];
					if (initializer is ArrayInitializer)
					{
						ArrayInitializer arrayInitList2;
						arrayInitList2 = (ArrayInitializer)initializer;
						if (arrayInitList2.DataType == arrayInitList.DataType)
							return arrayInitList2;
					}
					else if (initializer is ArrayOfStructInitializer)
					{
						ArrayOfStructInitializer arrayInitList2;
						arrayInitList2 = (ArrayOfStructInitializer)initializer;
						if (arrayInitList2.DataType == arrayInitList.DataType)
							return arrayInitList2;
					}
					throw new STLangCompilerError(Resources.WRAPUPARRAYINILIST);
				} 
			}
		}
	}

	private InitializerList WrapUpStructInitList(InitializerList structInitList, LexLocation location)
	{
		if (structInitList == null)
			return structInitList;
		else if (structInitList.DataType == TypeNode.Error)
			return structInitList;
		else {
			structInitList.CheckInitListSize(location);
			if (! structInitList.IsConstant)
				return structInitList;
			else {
				string key = structInitList.GetKey();
				if (! constantTable.ContainsKey(key))
				{
					constantTable[key] = structInitList;
					return structInitList;
				}
				else {
					Expression initializer;
					initializer = (Expression)constantTable[key];
					if (initializer is StructInitializer)
					{
						StructInitializer structInitList2;
						structInitList2 = (StructInitializer)initializer;
						if (structInitList2.DataType == structInitList.DataType)
							return structInitList2;
					}
					throw new STLangCompilerError(Resources.WRAPUPARRAYINILIST);
				}
			}
		}
	}

	private InitializerList MakeStructInitializer(Expression initializer, LexLocation location)
	{
		TypeNode dataType = this.attributeStack.Top;
		Expression size = MakeIntConstant((long)dataType.Size);
		if (dataType.IsStructType)
		{
			StructInitializer structInitList = new StructInitializer(dataType, size);
			structInitList.Add(initializer, location);
			return structInitList;
		}
		else if (dataType.IsFunctionBlockType)
		{
			FunctionBlockInitializer functionBlockInitList;
			functionBlockInitList = new FunctionBlockInitializer(dataType, size);
			functionBlockInitList.Add(initializer, location);
			return functionBlockInitList;
		}
		else 
		{
			if (dataType != TypeNode.Error)
				this.report.SemanticError(65, dataType.Name, location);
			return new StructInitializer(TypeNode.Error, size);
		}
	}

	private InitializerList AddStructMemberInitializer(InitializerList structInitList, Expression initializer, LexLocation loc)
	{
		if (structInitList != null)
			structInitList.Add(initializer, loc);
		return structInitList;
	}

	private StructDeclaration MakeStructMemberList(StructMemberDeclaration member)
	{	
		StructDeclaration structure = new StructDeclaration();
		if (member != null)
		{
			if (! structure.Add(member))
				this.report.SemanticError(62, member.Name, member.Location);
		}
		return structure;
	}
	
	private StructDeclaration AddStructMemberDecl(StructDeclaration structure, StructMemberDeclaration member, LexLocation loc)
	{
		if (structure != null && member != null)
		{
			if (! structure.Add(member))
				this.report.SemanticError(62, member.Name, member.Location);
		}
		return structure;
	}

	private StructMemberDeclaration MakeStructMemberDecl(string name, DataTypeSpec member, LexLocation loc)
	{
		return new StructMemberDeclaration(name, member.DataType, member.InitialValue, loc);
	}

	private int BitCount(ulong value)
	{
		int count = 0;
		while (value > 0)
		{
			count++;
			value >>= 1;
		}
		return count;
	}

	private ulong IntPower(ulong value, int power)
	{
		if (power == 0)
			return 1;
		else if ((power & 1) == 0)
			return this.IntPower(value*value, power >> 1);
		else if ((value & 1) == 0)
			return this.IntPower(value >> 1, power) << power;
		else
			return value * IntPower(value, power - 1);
	}

	private long IntPower(long value, int power)
	{
		if (power == 0)
			return 1;
		else if ((power & 1) == 0)
			return this.IntPower(value*value, power >> 1);
		else if ((value & 1) == 0)
			return this.IntPower(value >> 1, power) << power;
		else
			return value * IntPower(value, power - 1);
	}

	private bool IsPowerOf2(ulong value, out int power)
	{
		power = 0;
		if (value <= 1)
			return false;
		else {
			while ((value & 1) == 0)
			{
				power++;
				value >>= 1;
			}
			return value == 1;
		}
	}

	private Expression CheckForLoopIncr(Expression expr, LexLocation location)
	{
		if (expr == null)
			return Expression.Error;
		else if (expr is FunctionName)
		{
			this.report.SemanticError(148, expr.ToString(), location);
			return Expression.Error;
		}
		else if (expr.DataType == TypeNode.Error)
			return expr;
		else if (expr.DataType.IsSignedIntType)
			return expr;
		else {
			this.report.SemanticError(135, expr.ToString(), location);
			return Expression.Error;
		}
	}

	private Expression MakeIntConstant(TokenInt token)
	{
		ulong value = token.Value;
		string lexeme = token.ToString();
		if ((value & 0x8000000000000000) != 0)
			return new ULIntConstant(value, lexeme);
		else if (TypeNode.SInt.IsInRange((long)value))
			return new SIntConstant((sbyte)value, lexeme);
		else if (TypeNode.Int.IsInRange((long)value))
			return new IntConstant((short)value, lexeme);
		else if (TypeNode.DInt.IsInRange((long)value))
			return new DIntConstant((int)value, lexeme);
		else
			return new LIntConstant((long)value, lexeme);
	}

	private Expression MakeIntConstant(ulong value)
	{
		string strValue = value.ToString();
		if (constantTable.ContainsKey(strValue))
			return (Expression)constantTable[strValue];
		else {
			Expression intConst;
			if (TypeNode.USInt.IsInRange(value))
				intConst = new USIntConstant((byte)value, strValue);
			else if (TypeNode.UInt.IsInRange(value))
				intConst = new UIntConstant((ushort)value, strValue);
			else if (TypeNode.UDInt.IsInRange(value))
				intConst = new UDIntConstant((uint)value, strValue);
			else 
				intConst = new ULIntConstant((ulong)value, strValue);
			constantTable[strValue] = intConst;
			return intConst;
		}
	}

	public static Expression MakeIntConstant(long value)
	{
		string strValue = value.ToString();
		if (constantTable.ContainsKey(strValue))
			return (Expression)constantTable[strValue];
		else {
			Expression intConst;
			if (TypeNode.SInt.IsInRange(value))
				intConst = new SIntConstant((sbyte)value, strValue);
			else if (TypeNode.Int.IsInRange(value))
				intConst = new IntConstant((short)value, strValue);
			else if (TypeNode.DInt.IsInRange(value))
				intConst = new DIntConstant((int)value, strValue);
			else
				intConst = new LIntConstant((long)value, strValue);
			constantTable[strValue] = intConst;
			return intConst;
		}
	}

	private Expression MakeConstant(ulong value, TypeNode bitStringType)
	{
		if (bitStringType == TypeNode.Bool)
			return this.MakeConstant(value != 0);
		else {
			string typeName = bitStringType.Name;
			string strValue = typeName + "#" + value.ToString();
			if (constantTable.ContainsKey(strValue))
				return (Expression)constantTable[strValue];
			else {
				Expression bitStringConst;
				if (TypeNode.Byte.IsInRange(value))
					bitStringConst = new ByteConstant((byte)value, strValue);
				else if (TypeNode.Word.IsInRange(value))
					bitStringConst = new WordConstant((ushort)value, strValue);
				else if (TypeNode.DInt.IsInRange(value))
					bitStringConst = new DWordConstant((uint)value, strValue);
				else
					bitStringConst = new LWordConstant((ulong)value, strValue);
				constantTable[strValue] = bitStringConst;
				return bitStringConst;
			}
		}
	}

	private Expression MakeConstant(bool value)
	{
		string stringValue = value.ToString();
		string keyValue = stringValue.ToUpper();
		if (constantTable.ContainsKey(keyValue))
			return (Expression)constantTable[keyValue];
		else
		{
			Expression expr = new BoolConstant(value, stringValue);
			constantTable[keyValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(bool value, string boolStr)
	{
		string keyValue = boolStr.ToUpper();
		if (constantTable.ContainsKey(keyValue))
			return (Expression)constantTable[keyValue];
		else
		{
			Expression expr = new BoolConstant(value, boolStr);
			constantTable[keyValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(string stringValue, LexLocation location)
	{
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			long length = stringValue.Length;
			Expression size = MakeIntConstant(length);
			TypeNode stringType = this.MakeStringType(size, location);
			Expression expr = new StringConstant(stringValue, stringType);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeWString(string stringValue, LexLocation location)
	{
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			long length = stringValue.Length;
			Expression size = MakeIntConstant(length);
			TypeNode stringType = this.MakeWStringType(size, location);
			Expression expr = new StringConstant(stringValue, stringType);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenTypedInt token, LexLocation location)
	{
		string lexeme = token.ToString();
		string keyValue = lexeme.RemoveChar('_').ToUpper();
		ulong value = token.Value;
		if (constantTable.ContainsKey(keyValue))
			return (Expression)constantTable[keyValue];
		else {
			Expression constant = null;
			switch (token.IntType)
			{
			case Tokens.INT:
				constant = new IntConstant((short)value, lexeme);
				break;
			case Tokens.SINT:
				constant = new SIntConstant((sbyte)value, lexeme);
				break;
			case Tokens.DINT:
				constant = new DIntConstant((int)value, lexeme);
				break;
			case Tokens.LINT:
				constant = new LIntConstant((long)value, lexeme);
				break;
			case Tokens.USINT:
				constant = new USIntConstant((byte)value, lexeme);
				break;
			case Tokens.UINT:
				constant = new UIntConstant((ushort)value, lexeme);
				break;
			case Tokens.UDINT:
				constant = new UDIntConstant((uint)value, lexeme);
				break;
			case Tokens.ULINT:
				constant = new ULIntConstant(value, lexeme);
				break;
			case Tokens.BOOL:
				constant = new BoolConstant(value != 0, lexeme);
				break;
			case Tokens.BYTE:
				constant = new ByteConstant((byte)value, lexeme);
				break;
			case Tokens.WORD:
				constant = new WordConstant((ushort)value, lexeme);
				break;
			case Tokens.DWORD:
				constant = new DWordConstant((uint)value, lexeme);
				break;
			case Tokens.LWORD:
				constant = new LWordConstant(value, lexeme);
				break;
			case Tokens.REAL:
				constant = new RealConstant((float)value);
				break;
			case Tokens.LREAL:
				constant = new LRealConstant((double)value);
				break;
			case Tokens.IDENT:
				{
					STLangSymbol symbol;
					string typeName = token.TypeName;
					if (! this.symbolTable.Lookup(typeName, out symbol, location))
					{
						this.report.SemanticError(1, typeName, location);
						return Expression.Error;
					}
					else if (! (symbol is TypeNameSymbol))
					{
						this.report.SemanticError(24, typeName, location);
						return Expression.Error;
					}
					else if (! symbol.DataType.IsElementaryType)
					{
						this.report.SemanticError(114, value, symbol.DataType.Name, location);
						return Expression.Error;
					}
					else {
						TypeNode dataType = symbol.DataType;
						keyValue = dataType.Name + "#" + value;
						keyValue = keyValue.RemoveChar('_').ToUpper();
						if (constantTable.ContainsKey(keyValue))
							return (Expression)constantTable[keyValue];
						else if (dataType == TypeNode.SInt)
							constant = new SIntConstant((sbyte)value, lexeme);
						else if (dataType == TypeNode.Int)
							constant = new IntConstant((short)value, lexeme);
						else if (dataType == TypeNode.DInt)
							constant = new DIntConstant((int)value, lexeme);
						else if (dataType == TypeNode.LInt)
							constant = new LIntConstant((long)value, lexeme);
						else if (dataType == TypeNode.USInt)
							constant = new USIntConstant((byte)value, lexeme);
						else if (dataType == TypeNode.UInt)
							constant = new UIntConstant((ushort)value, lexeme);
						else if (dataType == TypeNode.UDInt)
							constant = new UDIntConstant((uint)value, lexeme);
						else if (dataType == TypeNode.ULInt)
							constant = new ULIntConstant((ulong)value, lexeme);
						else if (dataType == TypeNode.Bool)
							constant = new BoolConstant(value != 0, lexeme);
						else if (dataType == TypeNode.Byte)
							constant = new ByteConstant((byte)value, lexeme);
						else if (dataType == TypeNode.Word)
							constant = new WordConstant((ushort)value, lexeme);
						else if (dataType == TypeNode.DWord)
							constant = new DWordConstant((uint)value, lexeme);
						else if (dataType == TypeNode.LWord)
							constant = new LWordConstant((ulong)value, lexeme);
						else if (dataType == TypeNode.Real)
							constant = new RealConstant((float)value);
						else if (dataType == TypeNode.LReal)
							constant = new LRealConstant((double)value);
						else {
							this.report.SemanticError(114, value, dataType.Name, location);
							return Expression.Error;
						}

					}
				}
				break;
			case Tokens.DATE:
			case Tokens.DATE_AND_TIME:
			case Tokens.DT:
			case Tokens.TIME:
			case Tokens.TIME_OF_DAY:
			case Tokens.TOD:
			case Tokens.STRING:
			case Tokens.WSTRING:
			default:
				this.report.SemanticError(114, value, token.IntType.ToString(), location);
				return Expression.Error;
			}
			if (constant != null)
			{
				TypeNode dataType = constant.DataType;
				constantTable[keyValue] = constant;
				return constant;
			}
		}
		return Expression.Error;
	}

	private Expression MakeConstant(TokenTypedReal token, LexLocation location)
	{
		string lexeme = token.ToString();
		double value = token.Value;
		string keyValue = lexeme.RemoveChar('_').ToUpper();
		if (constantTable.ContainsKey(keyValue))
			return (Expression)constantTable[keyValue];
		else {
			Expression constant = null;
			switch (token.RealType)
			{
			case Tokens.REAL:
				constant = new RealConstant((float)value, lexeme);
				break;
			case Tokens.LREAL:
				constant = new LRealConstant(value);
				break;
			case Tokens.INT:
				constant = new IntConstant((short)value, lexeme);
				break;
			case Tokens.SINT:
				constant = new SIntConstant((sbyte)value, lexeme);
				break;
			case Tokens.DINT:
				constant = new DIntConstant((int)value, lexeme);
				break;
			case Tokens.LINT:
				constant = new LIntConstant((long)value, lexeme);
				break;
			case Tokens.USINT:
				constant = new USIntConstant((byte)value, lexeme);
				break;
			case Tokens.UINT:
				constant = new UIntConstant((ushort)value, lexeme);
				break;
			case Tokens.UDINT:
				constant = new UDIntConstant((uint)value, lexeme);
				break;
			case Tokens.ULINT:
				constant = new ULIntConstant((ulong)value, lexeme);
				break;
			case Tokens.BOOL:
				constant = new BoolConstant(value != 0, lexeme);
				break;
			case Tokens.BYTE:
				constant = new ByteConstant((byte)value, lexeme);
				break;
			case Tokens.WORD:
				constant = new WordConstant((ushort)value, lexeme);
				break;
			case Tokens.DWORD:
				constant = new DWordConstant((uint)value, lexeme);
				break;
			case Tokens.LWORD:
				constant = new LWordConstant((ulong)value, lexeme);
				break;
			case Tokens.IDENT:
			{
				STLangSymbol symbol;
				string typeName = token.TypeName;
				if (! this.symbolTable.Lookup(typeName, out symbol, location))
				{
					this.report.SemanticError(1, typeName, location);
					return MakeConstant(value);
				}
				else if (! (symbol is TypeNameSymbol))
				{
					this.report.SemanticError(24, typeName, location);
					return MakeConstant(value);
				}
				else {
					TypeNode dataType = symbol.DataType;
					lexeme = dataType.Name + "#" + value;
					keyValue = lexeme.RemoveChar('_').ToUpper();
					if (constantTable.ContainsKey(keyValue))
						return (Expression)constantTable[keyValue];
					else if (dataType == TypeNode.SInt)
						constant = new SIntConstant((sbyte)value, lexeme);
					else if (dataType == TypeNode.Int)
						constant = new IntConstant((short)value, lexeme);
					else if (dataType == TypeNode.DInt)
						constant = new DIntConstant((int)value, lexeme);
					else if (dataType == TypeNode.LInt)
						constant = new LIntConstant((long)value, lexeme);
					else if (dataType == TypeNode.USInt)
						constant = new USIntConstant((byte)value, lexeme);
					else if (dataType == TypeNode.UInt)
						constant = new UIntConstant((ushort)value, lexeme);
					else if (dataType == TypeNode.UDInt)
						constant = new UDIntConstant((uint)value, lexeme);
					else if (dataType == TypeNode.ULInt)
						constant = new ULIntConstant((ulong)value, lexeme);
					else if (dataType == TypeNode.Bool)
						constant = new BoolConstant(value != 0.0, lexeme);
					else if (dataType == TypeNode.Byte)
						constant = new ByteConstant((byte)value, lexeme);
					else if (dataType == TypeNode.Word)
						constant = new WordConstant((ushort)value, lexeme);
					else if (dataType == TypeNode.DWord)
						constant = new DWordConstant((uint)value, lexeme);
					else if (dataType == TypeNode.LWord)
						constant = new LWordConstant((ulong)value, lexeme);
					else if (dataType == TypeNode.Real)
						constant = new RealConstant((float)value, lexeme);
					else if (dataType == TypeNode.LReal)
						constant = new LRealConstant(value, lexeme);
					else {
						this.report.SemanticError(114, value, dataType.Name, location);
						return Expression.Error;
					}
				}
			}
			break;
			default:
				this.report.SyntaxError(111, token.TypeName, location);
				return Expression.Error;
			}
			if (constant != null)
			{
				TypeNode dataType = constant.DataType;
				constantTable[keyValue] = constant;
				return constant;
			}
		}
		return Expression.Error;
	}

	private Expression MakeConstant(TokenTypedEnum enumConst, LexLocation location)
	{
		if (enumConst.TypeToken != Tokens.IDENT || enumConst.ValueToken != Tokens.IDENT)
			return Expression.Error;
		else {
			STLangSymbol symbol;
			string qualifiedName = enumConst.ToString();
			string keyValue = qualifiedName.ToUpper();
			if (constantTable.ContainsKey(keyValue))
				return (Expression)constantTable[keyValue];
			else if (this.symbolTable.Lookup(qualifiedName, out symbol, location))
			{
				Expression constant = symbol.MakeSyntaxTreeNode(location);
				constantTable[keyValue] = constant;
				return constant;
			}
			else {
				STLangSymbol enumSymbol;
				string enumTypeName = enumConst.TypeName;
				string enumValue = enumConst.Value;
				this.report.SemanticError(0, qualifiedName, location);
				if (! this.symbolTable.Lookup(enumTypeName, out symbol, location))
					this.report.SemanticError(0, enumTypeName, location);
				else if (! (symbol is TypeNameSymbol))
					this.report.SemanticError(24, enumTypeName, location);
				else if (! symbol.DataType.IsEnumeratedType)
					this.report.SemanticError(-7, enumTypeName, location);
				if (! this.symbolTable.Lookup(enumValue, out enumSymbol, location))
					this.report.SemanticError(0, enumValue, location);
				else if (! (enumSymbol is EnumSymbol))
					this.report.SemanticError(-8, enumValue, location);
				return Expression.Error;
			}
		}
	}

	private SubRange MakeEnumSubRange(Expression lower, Expression upper, LexLocation location)
	{
		int lowerBound = Convert.ToInt32(lower.Evaluate());
		int upperBound = Convert.ToInt32(upper.Evaluate());
		if (lowerBound > upperBound)
		{
			string interval = lower + ".." + upper;
			this.report.SemanticError(16, interval, location);
			int tmp = lowerBound;
			lowerBound = upperBound;
			upperBound = tmp;
		}
		return new EnumSubrange((ushort)lowerBound, (ushort)upperBound, lower.DataType);
	}

	private SubRange MakeIntSubRange(Expression lower, Expression upper, LexLocation location)
	{
		long lowerBound = Convert.ToInt64(lower.Evaluate());
		long upperBound = Convert.ToInt64(upper.Evaluate());
		if (lowerBound > upperBound)
		{
			string interval = lower.ToString() + ".." + upper.ToString();
			this.report.SemanticError(16, interval, location);
			long tmp = lowerBound;
			lowerBound = upperBound;
			upperBound = tmp;
		}
		TypeNode dataType = this.LargestDataType(lower, upper);
		return new IntSubrange(lower, upper, dataType);
	}

	private SubRange MakeUIntSubRange(Expression lower, Expression upper, LexLocation location)
	{
		ulong lowerBound = Convert.ToUInt64(lower.Evaluate());
		ulong upperBound = Convert.ToUInt64(upper.Evaluate());
		if (lowerBound > upperBound)
		{
			string interval = lower.ToString() + ".." + upper.ToString();
			this.report.SemanticError(16, interval, location);
			ulong tmp = lowerBound;
			lowerBound = upperBound;
			upperBound = tmp;
		}
		TypeNode dataType = this.LargestDataType(lower, upper);
		return new UIntSubrange(lower, upper, dataType);
	}

	private SubRange MakeBitStringSubRange(Expression lower, Expression upper, LexLocation location)
	{
		ulong lowerBound = Convert.ToUInt64(lower.Evaluate());
		ulong upperBound = Convert.ToUInt64(upper.Evaluate());
		if (lowerBound > upperBound)
		{
			string interval = lower.ToString() + ".." + upper.ToString();
			this.report.SemanticError(16, interval, location);
			ulong tmp = lowerBound;
			lowerBound = upperBound;
			upperBound = tmp;
		}
		TypeNode dataType = this.LargestDataType(lower, upper);
		return new BitStringSubrange(lower, upper, dataType);
	}

private SubRange MakeSubrange(Expression lower, Expression upper, LexLocation loc1, LexLocation loc2)
{
		if (lower == null || upper == null)
			return SubRange.Error;
		else {
			TypeNode lowerDataType = lower.DataType;
			TypeNode upperDataType = upper.DataType;
		
			if (lowerDataType == TypeNode.Error || upperDataType == TypeNode.Error)
				return SubRange.Error;
			else if (! lower.IsConstant)
			{
				this.report.SemanticError(95, lower.ToString(), loc1);
				if (! upper.IsConstant)
					this.report.SemanticError(95, upper.ToString(), loc2);
				if (! lowerDataType.IsOrdinalType)
					this.report.SemanticError(-1, lower.ToString(), loc1);
				if (! upperDataType.IsOrdinalType)
					this.report.SemanticError(-1, upper.ToString(), loc2);
				return SubRange.Error;
			}
			else if (! upper.IsConstant)
			{
				this.report.SemanticError(95, upper.ToString(), loc2);
				if (! lowerDataType.IsOrdinalType)
					this.report.SemanticError(-1, lower.ToString(), loc1);
				if (! upperDataType.IsOrdinalType)
					this.report.SemanticError(-1, upper.ToString(), loc2);
				return SubRange.Error;
			}
			else if (! lowerDataType.IsOrdinalType)
			{
				this.report.SemanticError(-1, lower.ToString(), loc1);
				if (! upperDataType.IsOrdinalType)
					this.report.SemanticError(-1, upper.ToString(), loc2);
				return SubRange.Error;
			}
			else if (! upperDataType.IsOrdinalType)
			{
				this.report.SemanticError(-1, upper.ToString(), loc2);
				return SubRange.Error;
			}
			else if (lowerDataType.IsSignedIntType)
			{
				if (upperDataType.IsSignedIntType)
					return this.MakeIntSubRange(lower, upper, loc1);
			}
			else if (lowerDataType.IsUnsignedIntType)
			{
				if (upperDataType.IsUnsignedIntType)
					return this.MakeUIntSubRange(lower, upper, loc1);
			}
			else if (lowerDataType.IsBitStringType)
			{
				if (upperDataType.IsBitStringType)
					return this.MakeBitStringSubRange(lower, upper, loc1);
			}
			else if (lowerDataType.BaseType != upperDataType.BaseType)
			{
				string subRange = lower + ".." + upper;
				this.report.SemanticError(94, subRange, loc1);
				return SubRange.Error;
			}
			else if (lowerDataType.IsEnumeratedType)
				return this.MakeEnumSubRange(lower, upper, loc1);
		}
		string interval = lower + ".." + upper;
		this.report.SemanticError(94, interval, loc1);
		return SubRange.Error;
	}

	private void SubrangeTypeStart(TypeNode subrangeType)
	{
		this.isSubrangeDecl = true;
		this.subrangeDataType = subrangeType;
	}

	private TypeNode MakeSubrangeType(TypeNode baseType, SubRange subrange, LexLocation loc)
	{
		TypeNode subRangeType;
		this.isSubrangeDecl = false;            
		this.subrangeDataType = TypeNode.Error;
		string typeID = baseType.TypeID + "(" + subrange + ")";
		if (TypeNode.LookUpType(typeID, out subRangeType))
			return subRangeType;
		else {
			string typeName = baseType.Name + "(" + subrange + ")";
			return baseType.MakeSubrange(typeName, subrange, loc);
		}
	}	

	private List<SubRange> MakeSubRangeList(SubRange subrange, LexLocation location)
	{
		if (subrange.DataType.IsSignedIntType)
			return new List<SubRange>{subrange};
		else {
			this.report.SemanticError(15, subrange.ToString(), location);
			return new List<SubRange>{new IntSubrange(0, 100, TypeNode.Int)};
		}
	}

	private List<SubRange> AddSubRange(List<SubRange> subRangeList, SubRange subrange, LexLocation location)
	{
		if (subRangeList.Count == STLangParameters.MAX_ARRAY_SUBSCRIPTS)
			this.report.SemanticError(50, location);
		if (subrange.DataType.IsIntegerType)
			subRangeList.Add(subrange);
		else {
			if (subrange.DataType != TypeNode.Error)
				this.report.SemanticError(15, subrange.ToString(), location);
			subRangeList.Add(new IntSubrange(0, 100, TypeNode.Int));
		}
		return subRangeList;
	}

	private List<string> MakeEnumIdentList(string enumIdent, LexLocation location)
	{
		List<string> enumIdentList = new List<string>();
		if (enumIdent.Length > 0)
		{
			if (this.isTypeDecl)
			{
				if (this.symbolTable.IsValidTypedEnumSymbol(enumIdent, location))
					enumIdentList.Add(enumIdent);
			}
			else if (this.symbolTable.IsValidUserDefinedSymbol(enumIdent, location))
				enumIdentList.Add(enumIdent);
		}
		return enumIdentList;
	}

	private List<string> AddToEnumIdentList(List<string> enumIdentList, string enumIdent, LexLocation location)
	{
		if (enumIdent.Length == 0)
			return enumIdentList;
		else if (enumIdentList == null)
			return this.MakeEnumIdentList(enumIdent, location);
		else if (!enumIdentList.IsUnique(enumIdent))
			this.report.SemanticError(1, enumIdent, location);
		else if (this.isTypeDecl)
		{
			if (this.symbolTable.IsValidTypedEnumSymbol(enumIdent, location))
				enumIdentList.Add(enumIdent);
		}
		else if (this.symbolTable.IsValidUserDefinedSymbol(enumIdent, location))
			enumIdentList.Add(enumIdent);
		return enumIdentList;
	}

	private EnumeratedType MakeEnumeratedType(List<string> identList)
	{
		EnumeratedType enumType = new EnumeratedType(identList);
		if (this.isTypeDecl)
			this.symbolTable.InstallEnumeratedConstants(enumType, this.derivedTypeName);
		else
			this.symbolTable.InstallEnumeratedConstants(enumType);
		//
		// Install selection functions SEL and MUX for this enumerated type in the symboltable.
		//
		STLangSymbolTable.InstallStandardFunction("SEL", enumType, StandardLibraryFunction.SELECT, TypeNode.Bool, enumType, enumType);
		STLangSymbolTable.InstallExtensibleFunction("MUX", enumType, StandardLibraryFunction.MUX, TypeNode.AnyInt, enumType, enumType);
		return enumType;
	}

	private List<object> MakeArrayInitList(object initElem)
	{
		List<object> initList = new List<object>();
		if (initElem != null)
		{
			if (initElem is List<object>)
				initList.AddRange((List<object>)initElem);
			else
				initList.Add(initElem);
		}
		return initList;
	}

	private void AddArrayInitElem(List<object> initList, object initElem)
	{
		if (initElem != null)
		{
			if (initElem is List<object>)
				initList.AddRange((List<object>)initElem);
			else
				initList.Add(initElem);
		}
	}

	private List<object> MakeStructInitList(object initElem)
	{
		List<object> initList = new List<object>();
		if (initElem != null)
		{
			if (initElem is List<object>)
				initList.AddRange((List<object>)initElem);
			else
				initList.Add(initElem);
		}
		return initList;
	}

	private void AddStructInitElem(List<object> initList, object initElem)
	{
		if (initElem != null)
		{
			if (initElem is List<object>)
				initList.AddRange((List<object>)initElem);
			else
				initList.Add(initElem);
		}
	}

	private string MakeTypeName(List<SubRange> subRanges, TypeNode elemDataType)
	{
		string intervalList = "";

		foreach (SubRange subrange in subRanges)
		{
			if (intervalList.Length > 0)
				intervalList += ",";
			intervalList += subrange;
		}
		return "ARRAY [" + intervalList + "] OF " + elemDataType.Name;
	}

	private List<SubRange> GetSubRanges(ArrayType array)
	{
		int lower,upper;
		TypeNode elementType = array;
		List<SubRange> subRanges = new List<SubRange>();
		
		while (elementType.IsArrayType)
	    {
			array = (ArrayType)elementType;
			lower = array.LowerBound;
			upper = array.UpperBound;
			elementType = array.ElementType;
			subRanges.Add(new IntSubrange(lower, upper, TypeNode.DInt));
		}
		while (elementType.IsArrayType);
		return subRanges;
	}

	private TypeNode MakeArrayType(List<SubRange> subRanges, TypeNode elemDataType, LexLocation loc1, LexLocation loc2) 
	{
		if (elemDataType.IsFunctionBlockType)
		{
			//
			// Error. IEC 61131-3 does not allow arrays of function blocks.
			//
			this.report.SemanticError(164, loc2);
			return TypeNode.Error;
		}
		else {
			string typeID = "";
			TypeNode arrayDataType;
			foreach (SubRange subrange in subRanges)
			{
				typeID +=  "[" + subrange + "]";
			} 
			typeID += elemDataType.TypeID;
			if (TypeNode.LookUpType(typeID, out arrayDataType))
				return arrayDataType;
			else {
				Expression defaultValue = elemDataType.DefaultValue;
				return this.MakeArrayType(subRanges, elemDataType, defaultValue, loc1);
			}
		}
	}

	private TypeNode MakeArrayType(List<SubRange> subranges, TypeNode basicElementType, Expression initializer, LexLocation loc) 
	{
		if (subranges.Count == 0)
			return basicElementType;
		else {
			SubRange subrange = subranges[0];
			if (! (subrange is IntSubrange))
				return TypeNode.Error;
			else {
				TypeNode arrayDataType;
				TypeNode elementType    = this.MakeArrayType(subranges.Succ(), basicElementType, initializer, loc);
				string typeID           = "[" + subrange + "]" + elementType.TypeID;
			    IntSubrange intSubrange = (IntSubrange)subrange;
				long lower              = intSubrange.LowerBound;
				long upper              = intSubrange.UpperBound;
				string typeName         = this.MakeTypeName(subranges, basicElementType);
				long elementCount       = (upper - lower + 1)*(elementType.Size / basicElementType.Size);
				long byteCount          = elementCount * basicElementType.Size;
				if (byteCount > STLangParameters.MAX_ARRAY_SIZE)
					this.report.SemanticError(113, loc);
				if (TypeNode.LookUpType(typeID, out arrayDataType))
					return arrayDataType;
				else if (basicElementType.IsElementaryType || basicElementType.IsAnyStringType)
				{
					Expression size = MakeIntConstant(byteCount);
					return new ArrayType(typeName, (int)lower, (int)upper, (uint)byteCount, size, elementType, basicElementType, initializer, typeID);
				}
				else if (basicElementType.IsArrayType)
				{
					List<SubRange> subranges2 = new List<SubRange>();
					ArrayType array = (ArrayType)basicElementType.BaseType;
					subranges2.AddRange(subranges);
					subranges2.AddRange(this.GetSubRanges(array));
					return this.MakeArrayType(subranges2, array.BasicElementType, initializer, loc);
				}
				else if (basicElementType.IsStructType)
				{
					string key;
					ArrayType array;
					StructType structure = (StructType)basicElementType.BaseType;
					FieldSymbol field = structure.FirstField;
					Dictionary<string, InitializerList> flattenedInitLists;
					flattenedInitLists = new Dictionary<string, InitializerList>();
					while (field != null)
					{
						key = field.Name.ToUpper();
						array = (ArrayType)this.MakeFlattenedArrayType(elementCount, field.DataType, field.InitialValue);
						flattenedInitLists.Add(key, (InitializerList)array.DefaultValue);
						field = field.Next;
					}
					Expression size = MakeIntConstant(byteCount);
					return new ArrayType(typeName, (int)lower, (int)upper, (uint)byteCount, size, elementType, basicElementType, flattenedInitLists, typeID);
				}
				string msg = "Illegal array element type: " + basicElementType.Name;
				throw new STLangCompilerError(msg);
			}
		}
	}

	private TypeNode MakeFlattenedArrayType(long elementCount, TypeNode elementType, Expression initializer)
	{
		if (elementType.IsElementaryType || elementType.IsAnyStringType)
		{
			string typeID;
			TypeNode arrayDataType;
			int upper = (int)elementCount - 1;

			typeID = "[0.." + upper + "]" + elementType.TypeID;
			if (TypeNode.LookUpType(typeID, out arrayDataType))
				return arrayDataType;
			else {
				long byteCount = elementCount * elementType.Size;
				Expression size = MakeIntConstant(byteCount);
				string typeName = "ARRAY [0.." + upper + "] OF " + elementType.Name;
				return new ArrayType(typeName, 0, upper, (uint)byteCount, size, elementType, elementType, initializer, typeID);
			}
		}
		else if (elementType.IsArrayType)
		{
			ArrayType array2 = (ArrayType)elementType.BaseType;
			TypeNode elementType2 = array2.BasicElementType;
			long elementCount2 = elementCount*(array2.Size/elementType2.Size);
			return this.MakeFlattenedArrayType(elementCount2, elementType2, initializer);
		}
		else if (elementType.IsStructType)
		{
			TypeNode arrayDataType;
			int upper = (int)elementCount - 1;
			string typeID = "[0.." + upper + "]" + elementType.TypeID;
			
			if (TypeNode.LookUpType(typeID, out arrayDataType))
				return arrayDataType;
			else {
				string key;
				ArrayType array;
				StructType structure = (StructType)elementType.BaseType;
				FieldSymbol field = structure.FirstField;
				Dictionary<string, InitializerList> flattenedInitLists;
				flattenedInitLists = new Dictionary<string, InitializerList>();
				while (field != null)
				{
					key = field.Name.ToUpper();
					array = (ArrayType)this.MakeFlattenedArrayType(elementCount, field.DataType, field.InitialValue);
					flattenedInitLists.Add(key, (InitializerList)array.DefaultValue);
					field = field.Next;
				}
				long byteCount = elementCount * elementType.Size;
				Expression size = MakeIntConstant(byteCount);
				string typeName = "ARRAY [0.." + upper + "] OF " + elementType.Name;
				return new ArrayType(typeName, 0, upper, (uint)byteCount, size, elementType, elementType, flattenedInitLists, typeID);
			}
		}
		else
		{
			Expression size = MakeIntConstant(0);
			string typeID = "[0..1]" + elementType.TypeID;
			string typeName = "ARRAY [0..1] OF " + elementType.Name;
			return new ArrayType(typeName, 0, 1, 0, size, elementType, elementType, initializer, typeID);
		}
	}

	private string MakeTypeName(StructDeclaration structure)
	{
		string typeName = string.Empty;
		if (structure.MemberCount < 4)
		{
			foreach (StructMemberDeclaration member in structure.Members)
			{
				if (typeName.Length == 0)
					typeName = "STRUCT (" + member.Name + " : " + member.DataType.Name;
				else 
					typeName += "; " + member.Name + " : " + member.DataType.Name;
			}
		}
		else {
			StructMemberDeclaration member = structure.Members.ElementAt(0);
			typeName = "STRUCT (" + member.Name + " : " + member.DataType.Name;
            member = structure.Members.ElementAt(1);
			typeName += "; " + member.Name + " : " + member.DataType.Name;
            member = structure.Members.ElementAt(structure.MemberCount - 1);
			typeName += "; ... ; " + member.Name + " : " + member.DataType.Name;
		}
		typeName += ")";
		return typeName;
	}

	private TypeNode MakeStructDataType(StructDeclaration structure)
	{
		this.structNestingDepth--;
		if (structure == null || structure.MemberCount == 0)
			return TypeNode.Error;
		else {
			TypeNode structType;
			string typeID = string.Empty;
			
			foreach (StructMemberDeclaration member in structure.Members)
			{
				if (typeID.Length > 0)
					typeID += ",";
				typeID += member.Name.ToUpper() + ":" + member.DataType.TypeID;
			}
			typeID = "(" + typeID + ")";
			if (TypeNode.LookUpType(typeID, out structType))
				return structType;
			else {
				string key;
				uint byteCount = 0;
				FieldSymbol field = null;
				FieldSymbol prevField = null;
				FieldSymbol firstField = null;
				bool isContiguouslyStored = true;
				Dictionary<string, FieldSymbol> members;
				
				members = new Dictionary<string, FieldSymbol>();
				foreach (StructMemberDeclaration member in structure.Members)
				{
					prevField = field;
					field = new FieldSymbol(member.Name, member.DataType, member.InitValue);
					key = member.Name.ToUpper();
					members.Add(key, field);
					if (prevField == null)
                        firstField = field;
					else {
                        prevField.Next = field;
						if (prevField.DataType != field.DataType)
							isContiguouslyStored = false;
					}
					byteCount += member.DataType.Size;
				}
				string typeName = this.MakeTypeName(structure);
				Expression size = MakeIntConstant((long)byteCount);
				return new StructType(members, firstField, byteCount, size, isContiguouslyStored, typeName, typeID);
			}
		}
	}

	private InitializerList ExpandInitializerSequence(TokenInt tokenInt, InitializerList initSequence, LexLocation loc)
	{
		int repetitionFactor = (int)tokenInt.Value;
		if (repetitionFactor == 0)
		{
			this.report.SemanticError(89, loc);
			return initSequence; 
		}
		else if (initSequence != null)
			return initSequence.Expand(repetitionFactor, this.report);
		else {
			TypeNode dataType = this.attributeStack.Top;
			Expression defaultValue = dataType.DefaultValue;
			initSequence = new InitializerSequence(dataType);
			for (int i = repetitionFactor; i > 0; i--)
			{
				initSequence.Add(defaultValue, loc);
			}
			return initSequence;
		}
	}

	private TypeNode GetDerivedType(string typeName, LexLocation location)
	{
		STLangSymbol symbol;

		if (! this.symbolTable.Lookup(typeName, out symbol, location))
		{
			// Error: Undefined identifier

			this.report.SemanticError(151, typeName, location);
			return TypeNode.Error;
		}
		else if (! (symbol.IsDerivedType || symbol.IsFunctionBlock))
		{
			// Error: identifier is not a type name or function block.

			this.report.SemanticError(24, typeName, symbol.TypeName, location);
			return TypeNode.Error;
		}
		else if (symbol.IsFunctionBlock)
		{
			// Check that structure members are not function blocks.

			if (this.structNestingDepth > 0)
				this.report.SemanticError(165, location);
			if (this.isFunctionDecl)
			{
				// Check that the function block can be used in functions. 
				// Function blocks such as timers, counters or edge detectors
				// are illegal because they contain data that are declared 
				// retentive or R_EDGE/F_EDGE.

				StandardFunctionBlockSymbol functionBlockSymbol;
				functionBlockSymbol = (StandardFunctionBlockSymbol)symbol;
				if (functionBlockSymbol.HasRetentiveData) 
					this.report.SemanticError(162, typeName, location);
				if (functionBlockSymbol.HasRFEdgeDetection)
					this.report.SemanticError(163, typeName, location);
			}
		}
		return symbol.DataType;
	}

	private TypeNode MakeStringType(Expression size, LexLocation location)
	{
		if (size == null)
			return TypeNode.String;
		else if (! size.IsConstant && location != null)
		{
			this.report.SemanticError(22, location);
			if (! size.DataType.IsSignedIntType)
				this.report.SemanticError(-5, location);
			return TypeNode.String;
		}
		else if (! size.DataType.IsIntegerType)
		{
			this.report.SemanticError(-5, location);
			return TypeNode.String;
		}
		else {
			int length = Convert.ToInt32(size.Evaluate());
			if (length < 1)
			{
				this.report.SemanticError(22, location);
				return TypeNode.String;
			}
			else if (length > STLangParameters.MAX_STRING_LENGTH)
			{
				this.report.SemanticError(-6, length, location);
				return TypeNode.String;
			}
			else {
				TypeNode stringType;
				string baseTypeID = TypeNode.String.TypeID;
				string typeID = baseTypeID + "[" + length + "]";
				if (TypeNode.LookUpType(typeID, out stringType))
					return stringType;
				else {
					string typeName = "STRING[" + length + "]";
					return new StringType(typeName, length + 1, typeID);
				}
			}
		}
	}

	private TypeNode MakeWStringType(Expression size, LexLocation location)
	{
		if (size == null)
			return TypeNode.WString;
		else if (! size.IsConstant && location != null)
		{
			this.report.SemanticError(22, location);
			if (! size.DataType.IsIntegerType)
				this.report.SemanticError(-5, location);
			return TypeNode.WString;
		}
		else if (! size.DataType.IsIntegerType)
		{
			this.report.SemanticError(-5, location);
			return TypeNode.WString;
		}
		else {
			int length = Convert.ToInt32(size.Evaluate());
			if (length < 1)
			{
				this.report.SemanticError(22, location);
				return TypeNode.WString;
			}
			else if (length > STLangParameters.MAX_WSTRING_LENGTH)
			{
				this.report.SemanticError(-6, length, location);
				return TypeNode.WString;
			}
			else {
				TypeNode stringType;
				string baseTypeID = TypeNode.String.TypeID;
				string typeID = baseTypeID + "[" + length + "]";
				if (TypeNode.LookUpType(typeID, out stringType))
					return stringType;
				else {
					string typeName = "WSTRING[" + length + "]";
					return new WStringType(typeName, length + 1, typeID);
				}
			}
		}
	}

	private Expression MakeTODConstant(TimeSpan timeOfDay)
	{
		if (timeOfDay < TimeSpan.Zero)
			timeOfDay += new TimeSpan(0, 23, 59, 59, 999);
		if (timeOfDay.Days != 0)
			timeOfDay -= new TimeSpan(timeOfDay.Days, 0, 0, 0);
		string stringValue = timeOfDay.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new TimeOfDayConstant(timeOfDay);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenTOD token)
	{
		string stringValue = token.Value.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new TimeOfDayConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TimeSpan time)
	{
		string stringValue = time.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new TimeConstant(time);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenTime token)
	{
		string stringValue = token.Value.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new TimeConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	public static Expression MakeConstant(double value)
	{
		string stringValue = "LREAL#" + value.GetBinaryString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new LRealConstant(value);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	public static Expression MakeConstant(float value)
	{
		string stringValue = "REAL#" + value.GetBinaryString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new RealConstant(value);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenDouble token)
	{
		string stringValue = "LREAL#" + token.Value.GetBinaryString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new LRealConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenInt token)
	{
		string stringValue = token.Value.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = this.MakeIntConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenDate token)
	{
		string stringValue = token.Value.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new DateConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(DateTime dateTime)
	{
		string stringValue = dateTime.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new DateTimeConstant(dateTime);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenDateTime token)
	{
		string stringValue = token.Value.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new DateTimeConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private void PushFieldType(string field, LexLocation location)
	{
		this.attributeStack.PushFieldType(field, location);
	}

	private void CheckNestingDepth(LexLocation location)
	{
		this.structNestingDepth++;
		if (this.structNestingDepth == STLangParameters.MAX_STRUCT_NESTING_DEPTH + 1)
			this.report.SemanticError(115, location);
	}

	private SubrangeLabel CheckSubRangeTypes(TypeNode selectorDataType, SubRange subRange, LexLocation loc)
	{
		SubRange selectorSubrange = selectorDataType.GetSubrange();
		if (selectorSubrange.Contains(subRange))
			return new SubrangeLabel(subRange);
		else if (selectorSubrange.AreDisjoint(subRange))
		{
			this.report.SemanticError(-3, subRange.ToString(), selectorDataType.Name, loc);
			return new SubrangeLabel(subRange);
		}
		else {
			this.report.Warning(14, subRange.ToString(), loc);
			return new SubrangeLabel(subRange);
		}
	}

	private NumericLabel CheckSubRangeTypes(TypeNode selectorDataType, Expression caseLabel, LexLocation loc)
	{
		SubRange selectorSubrange = selectorDataType.GetSubrange();
		if (selectorSubrange.Contains(caseLabel))
			return new NumericLabel(caseLabel);
		else {
			this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, loc);
			return null;
		}
	}

	private Expression CheckCtrlExpression(LexLocation location, Expression expression = null)
	{
		if (expression == null)
		{
			this.Push(Expression.Error);
			expression = Expression.Error;
		}
		else if (expression is FunctionName)
		{
			this.Push(Expression.Error);
			expression = Expression.Error;
			this.report.SemanticError(148, expression.ToString(), location);
		}
		else {
			TypeNode ctrlExpressionType = expression.DataType;
			if (ctrlExpressionType == TypeNode.Error)
				this.Push(Expression.Error);
			else if (ctrlExpressionType.IsOrdinalType)
				this.Push(expression);
			else {
				this.report.SemanticError(147, location);
				this.Push(Expression.Error);
			}
		}
		this.PushCaseLabelList();
		this.CheckForEndOfCaseStatList();
		return expression;
	}

	private NumericLabel CheckCaseLabel(Expression caseLabel, LexLocation location)
	{
		if (caseLabel == null)
			return null;
		else if (caseLabel is FunctionName)
		{
			this.report.SemanticError(32, caseLabel.ToString(), location);
			return null;
		}
		else if (caseLabel.DataType == TypeNode.Error)
			return null;
		else if (! caseLabel.IsConstant)
		{
			this.report.SemanticError(32, caseLabel.ToString(), location);
			if (! caseLabel.DataType.IsOrdinalType)
				this.report.SemanticError(31, caseLabel.ToString(), location);
			return null;
		}
		else {
			TypeNode labelDataType = caseLabel.DataType;
			TypeNode selectorDataType = this.attributeStack.Top;	

			if (labelDataType == TypeNode.Error)
				return null;
			else if (! labelDataType.IsOrdinalType)
			{
				this.report.SemanticError(31, caseLabel.ToString(), location);
				return null;
			}
			else if (selectorDataType == TypeNode.Error)
				return new NumericLabel(caseLabel);
			else if (selectorDataType == labelDataType)
			{
				if (selectorDataType.IsSubrangeType)
				{
					if (selectorDataType.IsSignedIntType)
					{
						long numericValue = Convert.ToInt64(caseLabel.Evaluate());
						if (! selectorDataType.IsInRange(numericValue))
						{
							string strValue = caseLabel.ToString();
							string typeName = selectorDataType.Name;
							this.report.SemanticError(171, strValue, typeName, location);
						}
					}
					else {
						ulong numericValue = Convert.ToUInt64(caseLabel.Evaluate());
						if (! selectorDataType.IsInRange(numericValue))
						{
							string strValue = caseLabel.ToString();
							string typeName = selectorDataType.Name;
							this.report.SemanticError(171, strValue, typeName, location);
						}
					}
				}
				return new NumericLabel(caseLabel);
			}
			else if (selectorDataType.IsSignedIntType && labelDataType.IsSignedIntType)
			{
				if (selectorDataType.Size < labelDataType.Size)
					this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
				else {
					// Convert case label type to selector type

					long value = Convert.ToInt64(caseLabel.Evaluate());
					if (selectorDataType == TypeNode.Int)
						caseLabel = new IntConstant((short)value);
					else if (selectorDataType == TypeNode.DInt)
						caseLabel = new DIntConstant((int)value);
					else
						caseLabel = new LIntConstant(value);
				}
				return new NumericLabel(caseLabel);
			}
			else if (selectorDataType.IsUnsignedIntType && labelDataType.IsUnsignedIntType)
			{
				if (selectorDataType.Size < labelDataType.Size)
					this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
				else {
					// Convert case label type to selector type

					ulong value = Convert.ToUInt64(caseLabel.Evaluate());
					if (selectorDataType == TypeNode.UInt)
						caseLabel = new UIntConstant((ushort)value);
					else if (selectorDataType == TypeNode.DInt)
						caseLabel = new UDIntConstant((uint)value);
					else
						caseLabel = new ULIntConstant(value);
				}
				return new NumericLabel(caseLabel);
			}
			else if (selectorDataType.IsUnsignedIntType && labelDataType.IsSignedIntType)
			{
				if (selectorDataType.Size < labelDataType.Size)
					this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
				else {
					// Convert case label type to selector type

					long value = Convert.ToInt64(caseLabel.Evaluate());
					if (value < 0)
						this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
					else if (selectorDataType == TypeNode.UInt)
						caseLabel = new UIntConstant((ushort)value);
					else if (selectorDataType == TypeNode.DInt)
						caseLabel = new UDIntConstant((uint)value);
					else
						caseLabel = new ULIntConstant((ulong)value);
				}
				return new NumericLabel(caseLabel);
			}
			else if (selectorDataType.IsBitStringType && labelDataType.IsBitStringType)
			{
				if (selectorDataType.Size < labelDataType.Size)
					this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
				else {
					// Convert case label type to selector type

					ulong value = Convert.ToUInt64(caseLabel.Evaluate());
					if (selectorDataType == TypeNode.Word)
						caseLabel = new WordConstant((ushort)value);
					else if (selectorDataType == TypeNode.DWord)
						caseLabel = new DWordConstant((uint)value);
					else
						caseLabel = new LWordConstant(value);
				}
				return new NumericLabel(caseLabel);
			}
			else if (selectorDataType.IsBitStringType && labelDataType.IsIntegerType)
			{
				if (selectorDataType.Size < labelDataType.Size)
					this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
				else {
					// Convert case label type to selector type

					long value = Convert.ToInt64(caseLabel.Evaluate());
					if (value < 0)
						this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
					else if (selectorDataType == TypeNode.Word)
						caseLabel = new UIntConstant((ushort)value);
					else if (selectorDataType == TypeNode.DWord)
						caseLabel = new DWordConstant((uint)value);
					else
						caseLabel = new LWordConstant((ulong)value);
				}
				return new NumericLabel(caseLabel);
			}
			this.report.SemanticError(86, caseLabel.ToString(), labelDataType.Name, selectorDataType.Name, location);
			return null;
		}
	}

	private SubrangeLabel CheckCaseLabel(SubRange subRange, LexLocation location)
	{
		if (subRange == null)
			return null;
		else {
			TypeNode selectorDataType = this.attributeStack.Top;
			TypeNode labelDataType = subRange.DataType;
			if (labelDataType == TypeNode.Error)
				return null;
			else if (! labelDataType.IsOrdinalType)
			{
				this.report.SemanticError(31, subRange.ToString(), location);
				return null;
			}
			else if (selectorDataType == TypeNode.Error)
				return new SubrangeLabel(subRange);
			else if (! selectorDataType.IsOrdinalType)
				return new SubrangeLabel(subRange);
			else if (selectorDataType == labelDataType)
			{
                SubRange selectorSubRange = selectorDataType.GetSubrange();
                if (selectorSubRange.AreDisjoint(subRange))
                {
					string subRangeStr = subRange.ToString();
                    string selDataTypeName = selectorDataType.Name;
                    this.report.SemanticError(172, subRangeStr, selDataTypeName, location);
                }
				else if (! selectorSubRange.Contains(subRange))
                {
                    string subRangeStr = subRange.ToString();
                    string selDataTypeName = selectorDataType.Name;
                    this.report.Warning(14, subRangeStr, selDataTypeName, location);
                }
                return new SubrangeLabel(subRange);
            }
			else if (selectorDataType.IsSignedIntType && (subRange is IntSubrange))
			{
				if (selectorDataType.Size == labelDataType.Size)
					return CheckSubRangeTypes(selectorDataType, subRange, location);
				else if (selectorDataType.Size < labelDataType.Size)
				{
					this.report.SemanticError(108, subRange.ToString(), selectorDataType.Name, location);
					return null;
				}
				else {
					// Convert subrange type to selector type
					IntSubrange intSubrange = (IntSubrange)subRange;
					long lowerBound = intSubrange.LowerBound;
					long upperBound = intSubrange.UpperBound;
					intSubrange     = new IntSubrange(lowerBound, upperBound, selectorDataType);
					return new SubrangeLabel(intSubrange);
				}
			}
			else if (selectorDataType.IsUnsignedIntType && (subRange is UIntSubrange))
			{
				if (selectorDataType.Size == labelDataType.Size)
					return CheckSubRangeTypes(selectorDataType, subRange, location);
				else if (selectorDataType.Size < labelDataType.Size)
				{
					this.report.SemanticError(108, subRange.ToString(), selectorDataType.Name, location);
					return null;
				}
				else {
				    // Convert subrange type to selector type
					UIntSubrange uintSubrange = (UIntSubrange)subRange;
					ulong lowerBound = uintSubrange.LowerBound;
					ulong upperBound = uintSubrange.UpperBound;
					uintSubrange     = new UIntSubrange(lowerBound, upperBound, selectorDataType);
					return new SubrangeLabel(uintSubrange);
				}
			}
			else if (selectorDataType.IsUnsignedIntType && labelDataType.IsSignedIntType)
			{
				if (selectorDataType.Size < labelDataType.Size)
				{
					this.report.SemanticError(108, subRange.ToString(), selectorDataType.Name, location);
					return null;
				}
				else {
				    IntSubrange intSubrange = (IntSubrange)subRange;
					long lowerBound = intSubrange.LowerBound;
					long upperBound = intSubrange.UpperBound;
					UIntSubrange uintSubrange = new UIntSubrange((ulong)lowerBound, (ulong)upperBound, selectorDataType); 
					if (selectorDataType.Size > labelDataType.Size)
						return new SubrangeLabel(uintSubrange);
					else
						return CheckSubRangeTypes(selectorDataType, uintSubrange, location);
				}
			}
			else if (selectorDataType.IsBitStringType && labelDataType.IsBitStringType)
			{
				if (selectorDataType.Size == labelDataType.Size)
					return CheckSubRangeTypes(selectorDataType, subRange, location);
				else if (selectorDataType.Size < labelDataType.Size)
				{
					this.report.SemanticError(108, subRange.ToString(), selectorDataType.Name, location);
					return null;
				}
				else {
					// Convert subrange type to selector type
					BitStringSubrange bitStringSubrange = (BitStringSubrange)subRange;
					ulong lowerBound  = bitStringSubrange.LowerBound;
					ulong upperBound  = bitStringSubrange.UpperBound;
					bitStringSubrange = new BitStringSubrange(lowerBound, upperBound, selectorDataType);
					return new SubrangeLabel(bitStringSubrange);
				}
			}
			else if (selectorDataType.IsBitStringType && (subRange is UIntSubrange))
			{
				if (selectorDataType.Size < labelDataType.Size)
				{
					this.report.SemanticError(108, subRange.ToString(), selectorDataType.Name, location);
					return null;
				}
				else {
					UIntSubrange uintSubrange = (UIntSubrange)subRange;
					ulong lowerBound = uintSubrange.LowerBound;
					ulong upperBound = uintSubrange.UpperBound;
					uintSubrange     = new UIntSubrange(lowerBound, upperBound, selectorDataType); 
					if (selectorDataType.Size > labelDataType.Size)
						return new SubrangeLabel(uintSubrange);
					else
						return CheckSubRangeTypes(selectorDataType, uintSubrange, location);
				}
			}
			else if (selectorDataType.IsEnumeratedType && labelDataType.IsEnumeratedType)
			{
				SubRange selectorSubrange = selectorDataType.GetSubrange();
				if (selectorSubrange.Contains(subRange))
					return new SubrangeLabel(subRange);
				else if (selectorSubrange.AreDisjoint(subRange))
				{
					this.report.SemanticError(-3, subRange.ToString(), selectorDataType.Name, location);
					return new SubrangeLabel(subRange);
				}
				else {
					this.report.Warning(14, subRange.ToString(), location);
					return new SubrangeLabel(subRange);
				}
			}
			else {
				this.report.SemanticError(86, selectorDataType.Name, subRange.ToString(), location);
				return null;
			}
		}
	}

	private void InstallDerivedType(string typeName, DataTypeSpec typeSpec, LexLocation location)
	{
		if (this.symbolTable.IsValidUserDefinedSymbol(typeName, location))
		{
			TypeNode baseType = typeSpec.DataType;
			Expression initialValue = typeSpec.InitialValue;
			this.symbolTable.InstallDerivedType(typeName, baseType, initialValue);
		}
		this.derivedTypeName = "";
	}

	private Expression MakeRealAddOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			float leftValue = Convert.ToSingle(left.Evaluate());
			if (leftValue == 0.0f)
				return right;
			else if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				float sum = leftValue + rightValue;
					
				if (float.IsPositiveInfinity(sum) || float.IsNegativeInfinity(sum))
				{
					sum = float.NaN;
					string text = left.ToString() + " + " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(sum);
			}
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return left;
			else if (rightValue < 0.0f)
			{
				right = MakeConstant(-rightValue);
				return new RealSubOperator(left, right);
			}
		}
		else if (right is RealUnaryMinusOperator)
		{
			right = ((UnaryOperator)right).Operand;
			Expression expr = new RealSubOperator(left, right);
		}
		return new RealAddOperator(left, right);
	}

	private Expression MakeLRealAddOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (Math.Abs(leftValue) == 0.0d)
				return right;
			else if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				double sum = leftValue + rightValue;
					
				if (double.IsPositiveInfinity(sum) || double.IsNegativeInfinity(sum))
				{
					sum = double.NaN;
					string text = left.ToString() + " + " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(sum);
			}
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (Math.Abs(rightValue) == 0.0d)
				return left;
			else if (rightValue < 0.0d)
			{
				right = MakeConstant(-rightValue);
				return new RealSubOperator(left, right);
			}
		}
		else if (right is LRealUnaryMinusOperator)
		{
			UnaryOperator unaryMinus = (UnaryOperator)right;
			return new LRealSubOperator(left, unaryMinus.Operand);
		}
		return new LRealAddOperator(left, right);
	}

	private Expression MakeIntAddOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (leftValue == 0)
				return right;
			else if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				if (rightValue == 0)
					return left;
				else {
					long sum = leftValue + rightValue;
					return MakeIntConstant(sum);
				}
			}
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return left;
		}
		else if (right is IntUnaryMinusOperator)
		{
			UnaryOperator unaryMinus = (UnaryOperator)right;
			return this.MakeIntSubOp(left, unaryMinus.Operand);
		}
		if (left.DataType == right.DataType)
			return new IntAddOperator(left, right, left.DataType);
		else if (left.DataType == TypeNode.LInt)
			return new IntAddOperator(left, this.MakeInt2LInt(right), TypeNode.LInt);
		else if (right.DataType == TypeNode.LInt)
			return new IntAddOperator(this.MakeInt2LInt(left), right, TypeNode.LInt);
		else {
			TypeNode resDataType = this.LargestDataType(left, right);
			return new IntAddOperator(left, right, resDataType);
		}	
	}

	private Expression MakeUIntAddop(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (leftValue == 0)
				return right;
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				if (rightValue == 0)
					return left;
				else {
					ulong sum = leftValue + rightValue;
					return this.MakeIntConstant(sum);
				}
			}
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return left;
		}
		TypeNode resultDataType = this.LargestDataType(left, right);
		return new UIntAddOperator(left, right, resultDataType);		
	}

	private Expression MakeIntUIntAddop(Expression left, Expression right, LexLocation location)
	{
		TypeNode resultDataType;
		if (left.DataType.Size > right.DataType.Size)
			resultDataType = left.DataType;
		else if (right.DataType == TypeNode.USInt)
			resultDataType = TypeNode.Int;
		else if (right.DataType == TypeNode.UInt)
			resultDataType = TypeNode.DInt;
		else if (right.DataType == TypeNode.UDInt)
			resultDataType = TypeNode.LInt;
		else {
			this.report.SemanticError(14, "+", left.DataType.Name, right.DataType.Name, location);
			return Expression.Error;
		}
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (leftValue == 0)
				return right;
			else if (right.IsConstant)
			{
				uint rightValue = Convert.ToUInt32(right.Evaluate());
				long sum = leftValue + rightValue;
				return MakeIntConstant(sum);
			}
		}
		else if (right.IsConstant)
		{
			uint rightValue = Convert.ToUInt32(right.Evaluate());
			if (rightValue == 0)
				return left;
		}
		return new IntAddOperator(left, right, resultDataType);
	}

	private Expression MakeLeftShiftOp(Expression expression, int power)
	{
		if (expression == null)
			return Expression.Error;
		else if (! expression.IsConstant)
			return new LeftShiftOperator(expression, power);
		else if (expression.DataType.IsSignedIntType)
		{
			long intValue = Convert.ToInt64(expression.Evaluate());
			return MakeIntConstant(intValue << power);
		}
		else {
			ulong intValue = Convert.ToUInt64(expression.Evaluate());
			return this.MakeIntConstant(intValue << power);
		}
	}

	private Expression MakeReal2LReal(Expression expression)
	{
		if (expression == null)
			return Expression.Error;
		else if (expression.DataType != TypeNode.Real)
			throw new STLangCompilerError("MakeReal2LReal() expects Real argument: " + expression);
		else if (! expression.IsConstant)
			return new Real2LRealOperator(expression);
		else
		{
			double value = Convert.ToDouble(expression.Evaluate());
			return MakeConstant(value);
		}
	}

	private Expression MakeLReal2Real(Expression expression)
	{
		if (expression == null)
			return Expression.Error;
		else if (expression.DataType != TypeNode.LReal)
			throw new STLangCompilerError("MakeLReal2Real() expects LReal argument: " + expression);
		else if (! expression.IsConstant)
			return new LReal2RealOperator(expression);
		else
		{
			float value = Convert.ToSingle(expression.Evaluate());
			return MakeConstant(value);
		}
	} 

	private Expression MakeInt2Real(Expression expression)
	{
		if (expression == null)
			return Expression.Error;
		else if (! expression.DataType.IsIntegerType)
			throw new STLangCompilerError("MakeInt2Real() expects integer argument: " + expression);
		else if (expression.IsConstant)
		{
			float value = Convert.ToSingle(expression.Evaluate());
			return MakeConstant(value);
		}
		else if (expression.DataType.Size == TypeNode.LInt.Size)
			return new LInt2RealOperator(expression);
		else
			return new Int2RealOperator(expression);
	}

	private Expression MakeInt2LReal(Expression expression)
	{
		if (expression == null)
			return Expression.Error;
		else if (! expression.DataType.IsIntegerType)
			throw new STLangCompilerError("MakeInt2LReal() expects integer argument: " + expression);
		else if (expression.IsConstant)
		{
			double value = Convert.ToDouble(expression.Evaluate());
			return MakeConstant(value);
		}
		else if (expression.DataType.Size == TypeNode.LInt.Size)
			return new LInt2LRealOperator(expression);
		else
			return new Int2LRealOperator(expression);
	}

	private Expression MakeInt2LInt(Expression expression)
	{
		if (expression == null)
			return Expression.Error;
		else if (! expression.DataType.IsIntegerType)
			throw new STLangCompilerError("MakeInt2LInt() expects integer argument: " + expression);
		else if (expression.IsConstant)
		{
			long value = Convert.ToInt64(expression.Evaluate());
			return new LIntConstant(value);
		}
		else if (expression.DataType.Size <= TypeNode.DInt.Size)
			return new Int2LIntOperator(expression);
		else
			return expression;
	}

	private Expression MakeTTAddOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			if (leftValue == TimeSpan.Zero)
				return right;
			else if (right.IsConstant)
			{
				TimeSpan rightValue = (TimeSpan)right.Evaluate();
				if (rightValue == TimeSpan.Zero)
					return left;
				else {
					TimeSpan sum; 
					try {
						sum = leftValue.Add(rightValue);
					}
					catch (System.OverflowException)
					{
						sum = TimeSpan.Zero;
						string text = left.ToString() + " + " + right.ToString();
						this.report.SemanticError(117, text, location);
					}
					return this.MakeConstant(sum);
				}
			}
		}
		else if (right.IsConstant)
		{
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			if (rightValue == TimeSpan.Zero)
				return left;
		}
		return new TTAddOperator(left, right);
	}

	private Expression MakeDTTimeAddOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			DateTime leftValue = Convert.ToDateTime(left.Evaluate());
			if (right.IsConstant)
			{
				TimeSpan rightValue = (TimeSpan)right.Evaluate();
				if (rightValue == TimeSpan.Zero)
					return left;
				else {
					DateTime sum; 
					try {
						sum = leftValue.Add(rightValue);
					}
					catch (System.ArgumentOutOfRangeException )
					{
						sum = DateTime.MinValue;
						string text = left.ToString() + " + " + right.ToString();
						this.report.SemanticError(117, text, location);
					}
					return this.MakeConstant(sum);
				}
			}
		}
		else if (right.IsConstant)
		{
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			if (rightValue == TimeSpan.Zero)
				return left;
		}
		return new DTTAddOperator(left, right);
	}

	private Expression MakeTTODAddOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			if (leftValue == TimeSpan.Zero)
				return right;
			else if (right.IsConstant)
			{
				TimeSpan timeOfDay; 
				TimeSpan rightValue = (TimeSpan)right.Evaluate();
				if (leftValue.Days != 0)
					leftValue -= new TimeSpan(leftValue.Days, 0, 0, 0);
				try {
					TimeSpan sum = leftValue.Add(rightValue);
					if (sum < TimeSpan.Zero)
						sum = sum.Add(new TimeSpan(0, 23, 59, 59, 999));
					int hours = sum.Hours;
					int minutes = sum.Minutes;
					int seconds = sum.Seconds;
					if (sum.Milliseconds == 0)
						timeOfDay = new TimeSpan(hours, minutes, seconds);
					else
						timeOfDay = new TimeSpan(hours, minutes, seconds, sum.Milliseconds);
				}
				catch (System.OverflowException)
				{
					timeOfDay = TimeSpan.Zero;
					string text = left.ToString() + " + " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeTODConstant(timeOfDay);
			}
		}
		else if (right.IsConstant)
		{
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			if (rightValue == TimeSpan.Zero)
				return left;
		}
		return new TTODAddOperator(left, right);
	}

	private Expression MakeIntSubOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				long difference = leftValue - rightValue;
				return MakeIntConstant(difference);
			}
			else if (leftValue == 0)
			{
				if (right is IntUnaryMinusOperator)
					return ((UnaryOperator)right).Operand;
				else 
					return new IntUnaryMinusOperator(right);
			}
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return left;
			else if (rightValue < 0)
			{
				right = MakeIntConstant(-rightValue);
				return this.MakeIntAddOp(left, right);
			}
		}
		else if (right is IntUnaryMinusOperator)
		{
			right = ((UnaryOperator)right).Operand;
			return this.MakeIntAddOp(left, right);
		}
		if (left.DataType == right.DataType)
			return new IntSubOperator(left, right, left.DataType);
		else if (left.DataType == TypeNode.LInt)
			return new IntSubOperator(left, this.MakeInt2LInt(right), TypeNode.LInt);
		else if (right.DataType == TypeNode.LInt)
			return new IntSubOperator(this.MakeInt2LInt(left), right, TypeNode.LInt);
		else {
			TypeNode resDataType = this.LargestDataType(left, right);
			return new IntSubOperator(left, right, resDataType);
		}	
	}

	private Expression MakeIntUIntSubOp(Expression left, Expression right, LexLocation location)
	{
		TypeNode resultDataType;
	
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				uint rightValue = Convert.ToUInt32(right.Evaluate());
				long difference = leftValue - rightValue;
				return MakeIntConstant(difference);
			}
		}
		if (left.DataType.Size > right.DataType.Size)
			resultDataType = left.DataType;
		else if (right.DataType == TypeNode.USInt)
			resultDataType = TypeNode.Int;
		else if (right.DataType == TypeNode.UInt)
			resultDataType = TypeNode.DInt;
		else if (right.DataType == TypeNode.UDInt)
			resultDataType = TypeNode.LInt;
		else {
			this.report.SemanticError(14, "-", left.DataType.Name, right.DataType.Name, location);
			return Expression.Error;
		}
		 return new UIntAddOperator(left, right, resultDataType);
	}

	private Expression MakeUIntSubOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (leftValue == 0)
				return right;
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				if (rightValue == 0)
					return left;
				else {
					ulong difference = leftValue - rightValue;
					return this.MakeIntConstant(difference);
				}
			}
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return left;
		}
		TypeNode resultDataType = this.LargestDataType(left, right);
		return new UIntSubOperator(left, right, resultDataType);		
	}

	private Expression MakeRealSubOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			float leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				float diff = leftValue - rightValue;
				if (float.IsPositiveInfinity(diff) || float.IsNegativeInfinity(diff))
				{
					diff = float.NaN;
					string text = left.ToString() + " - " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(diff);
			}
			else if (leftValue == 0.0f)
				return new RealUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return left;
		}
		else if (left is RealUnaryMinusOperator)
		{
			if (right is RealUnaryMinusOperator)
			{
				right = ((UnaryOperator)right).Operand;
				return new RealSubOperator(right, left);
			}
			else {
				left = ((UnaryOperator)left).Operand;
				Expression expr = new RealAddOperator(left, right);
				return new RealUnaryMinusOperator(expr);
			}
		}
		else if (right is RealUnaryMinusOperator)
		{
			right = ((UnaryOperator)right).Operand;
			return new RealAddOperator(left, right);
		}
		return new RealSubOperator(left, right);
	}

	private Expression MakeLRealSubOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				double diff = leftValue - rightValue;
				if (double.IsPositiveInfinity(diff) || double.IsNegativeInfinity(diff))
				{
					diff = double.NaN;
					string text = left.ToString() + " - " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(diff);
			}
			else if (leftValue == 0.0d)
				return new LRealUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return left;
		}
		else if (left is LRealUnaryMinusOperator)
		{
			if (right is LRealUnaryMinusOperator)
			{
				right = ((UnaryOperator)right).Operand;
				return new LRealSubOperator(right, left);
			}
			else {
				left = ((UnaryOperator)left).Operand;
				Expression expr = new LRealAddOperator(left, right);
				return new LRealUnaryMinusOperator(expr);
			}
		}
		else if (right is LRealUnaryMinusOperator)
		{
			right = ((UnaryOperator)right).Operand;
			return new LRealAddOperator(left, right);
		}
		return new LRealSubOperator(left, right);
	}

	private Expression MakeTimeSubOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			if (right.IsConstant)
			{
				TimeSpan difference;
				try {
					TimeSpan rightValue = (TimeSpan)right.Evaluate();
					difference = leftValue.Subtract(rightValue);
				}
				catch (System.OverflowException)
				{
					difference = TimeSpan.Zero;
					string text = left.ToString() + " - " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeConstant(difference);
			}
			else if (leftValue == TimeSpan.Zero)
				return new TimeUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			if (rightValue == TimeSpan.Zero)
				return left;
		}
		return new TimeSubOperator(left, right);
	}

	private Expression MakeDateTimeTimeSubOp(Expression left, Expression right, LexLocation location)
	{
		 if (! left.IsConstant || ! right.IsConstant)
			return new DTTimeSubOperator(left, right);
		else {
			DateTime difference;
			DateTime dateTime = Convert.ToDateTime(left.Evaluate());
			try {
				TimeSpan timeSpan =(TimeSpan)right.Evaluate();
				difference = dateTime.Subtract(timeSpan);
			}
			catch (System.ArgumentOutOfRangeException)
			{
				difference = DateTime.MinValue;
				string text = left.ToString() + " - " + right.ToString();
				this.report.SemanticError(118, text, location);
			}
			return this.MakeConstant(difference);
		}
	}

	private Expression MakeDateTimeSubOp(Expression left, Expression right, LexLocation location)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new DateTimeSubOperator(left, right);
		else {
			TimeSpan difference;
			DateTime leftValue = Convert.ToDateTime(left.Evaluate());
			try {
				DateTime rightValue = Convert.ToDateTime(right.Evaluate());
				difference = leftValue.Subtract(rightValue);
			}
			catch (System.ArgumentOutOfRangeException)
			{
				difference = TimeSpan.Zero;
				string text = left.ToString() + " - " + right.ToString();
				this.report.SemanticError(118, text, location);
			}
			return this.MakeConstant(difference);
		}
	}

	private Expression MakeDateSubOp(Expression left, Expression right, LexLocation location)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new DateSubOperator(left, right);
		else {
			TimeSpan difference;
			DateTime leftValue = Convert.ToDateTime(left.Evaluate());
			try {
				DateTime rightValue = Convert.ToDateTime(right.Evaluate());
				difference = leftValue.Subtract(rightValue);
			}
			catch (System.ArgumentOutOfRangeException)
			{
				difference = TimeSpan.Zero;
				string text = left.ToString() + " - " + right.ToString();
				this.report.SemanticError(118, text, location);
			}
			return this.MakeConstant(difference);
		}
	}

	private Expression MakeTimeOfDaySubOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant && right.IsConstant)
		{
			TimeSpan difference;
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			
			try {
				TimeSpan rightValue = (TimeSpan)right.Evaluate();
				difference = leftValue.Subtract(rightValue);
			}
			catch (System.OverflowException)
			{
				difference = TimeSpan.Zero;
				string text = left.ToString() + " - " + right.ToString();
				this.report.SemanticError(119, text, location);
			}
			return this.MakeConstant(difference);
		}
		return new TimeOfDaySubOperator(left, right);
	}

	private Expression MakeTimeOfDayTimeSubOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			if (leftValue == TimeSpan.Zero)
				return right;
			else if (right.IsConstant)
			{
				TimeSpan difference;
			
				try {
					TimeSpan rightValue = (TimeSpan)right.Evaluate();
					difference = leftValue.Subtract(rightValue);
				}
				catch (System.OverflowException)
				{
					difference = TimeSpan.Zero;
					string text = left.ToString() + " - " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeConstant(difference);
			}
		}
		return new TODTimeSubOperator(left, right);
	}

	private Expression MakeIntMulOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			
			if (leftValue == 0)
				return MakeIntConstant(0);
			else if (leftValue == 1)
				return right;
			else if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				long product = leftValue * rightValue;
				return MakeIntConstant(product);
			}
			else if (leftValue == -1)
				return new IntUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return MakeIntConstant(0);
			else if (rightValue == 1)
				return left;
			else if (rightValue == -1)
				return new IntUnaryMinusOperator(left);
		}
		else if ((left is IntUnaryMinusOperator) && (right is IntUnaryMinusOperator))
		{
			left = ((UnaryOperator)left).Operand;
			right = ((UnaryOperator)right).Operand;
		}
		if (left.DataType == right.DataType)
			return new IntMulOperator(left, right, left.DataType);
		else if (left.DataType == TypeNode.LInt)
			return new IntMulOperator(left, this.MakeInt2LInt(right), TypeNode.LInt);
		else if (right.DataType == TypeNode.LInt)
			return new IntMulOperator(this.MakeInt2LInt(left), right, TypeNode.LInt);
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			return new IntMulOperator(left, right, resultDataType);
		}
	}

	private Expression MakeUIntMulop(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			
			if (leftValue == 0)
				return MakeIntConstant((ulong)0);
			else if (leftValue == 1)
				return right;
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				ulong product = leftValue * rightValue;
				return this.MakeIntConstant(product);
			}
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return this.MakeIntConstant((ulong)0);
			else if (rightValue == 1)
				return left;
		}
		if (left.DataType == right.DataType)
			return new UIntMulOperator(left, right, left.DataType);
		else if (left.DataType == TypeNode.LInt)
			return new UIntMulOperator(left, this.MakeInt2LInt(right), TypeNode.LInt);
		else if (right.DataType == TypeNode.LInt)
			return new UIntMulOperator(this.MakeInt2LInt(left), right, TypeNode.LInt);
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			return new UIntMulOperator(left, right, resultDataType);
		}
	}

	private Expression MakeIntUIntMulop(Expression left, Expression right, LexLocation location)
	{
		TypeNode resultDataType;
		if (left.DataType.Size > right.DataType.Size)
			resultDataType = left.DataType;
		else if (right.DataType == TypeNode.USInt)
			resultDataType = TypeNode.Int;
		else if (right.DataType == TypeNode.UInt)
			resultDataType = TypeNode.DInt;
		else if (right.DataType == TypeNode.UDInt)
			resultDataType = TypeNode.LInt;
		else {
			this.report.SemanticError(14, "*", left.DataType.Name, right.DataType.Name, location);
			return Expression.Error;
		}
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (leftValue == 0)
				return MakeIntConstant(0);
			else if (leftValue == 1)
				return right;
			else if (right.IsConstant)
			{
				uint rightValue = Convert.ToUInt32(right.Evaluate());
				long product = leftValue * rightValue;
				return MakeIntConstant(product);
			}
			else if (leftValue == -1)
				return right;
		}
		else if (right.IsConstant)
		{
			uint rightValue = Convert.ToUInt32(right.Evaluate());
			if (rightValue == 0)
				return MakeIntConstant(0);
			else if (rightValue == 1)
				return left;
		}
		return new IntMulOperator(left, right, resultDataType);
	}

	private Expression MakeRealMulOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			float leftValue = Convert.ToSingle(left.Evaluate());
			if (leftValue == 0.0f)
				return MakeConstant(0.0f);
			else if (leftValue == 1.0f)
				return right;
			else if (right.IsConstant)
			{
				float product;

				try {
					float rightValue = Convert.ToSingle(right.Evaluate());
					product = leftValue * rightValue;
				}
				catch (System.OverflowException)
				{
					product = float.NaN;
					string text = left.ToString() + " * " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(product);
			}
			else if (leftValue == -1.0f)
				return new RealUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return MakeConstant(0.0f);
			else if (rightValue == 1.0f)
				return left;
			else if (rightValue == -1.0f)
				return new RealUnaryMinusOperator(left);
		}
		return new RealMulOperator(left, right);
	}

	private Expression MakeLRealMulOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (leftValue == 0.0d)
				return MakeConstant(0.0d);
			else if (leftValue == 1.0d)
				return right;
			else if (right.IsConstant)
			{
				double product;

				try {
					double rightValue = Convert.ToDouble(right.Evaluate());
					product = leftValue * rightValue;
				}
				catch (System.OverflowException)
				{
					product = double.NaN;
					string text = left.ToString() + " * " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(product);
			}
			else if (leftValue == -1.0d)
				return new LRealUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return MakeConstant(0.0d);
			else if (rightValue == 1.0d)
				return left;
			else if (rightValue == -1.0d)
				return new LRealUnaryMinusOperator(left);
		}
		return new LRealMulOperator(left, right);
	}

	private Expression MakeIntTimeMulOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan timeSpan = (TimeSpan)left.Evaluate();
			
			if (timeSpan == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
			else if (right.IsConstant)
			{
				long factor = Convert.ToInt64(right.Evaluate());
				long ticks = timeSpan.Ticks * factor;
				if (ticks < TimeSpan.MinValue.Ticks || ticks > TimeSpan.MaxValue.Ticks)
				{
					ticks = 0;
					string text = left.ToString() + " * " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeConstant(new TimeSpan(ticks));
			}
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return this.MakeConstant(TimeSpan.Zero);
			else if (rightValue == 1)
				return left;
			else if (rightValue == -1)
				return new TimeUnaryMinusOperator(left);
		}
		return new IntTimeMulOperator(left, right);
	}

	private Expression MakeRealTimeMulOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan timeSpan = (TimeSpan)left.Evaluate();
			
			if (timeSpan == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
			else if (right.IsConstant)
			{
				Single factor = Convert.ToSingle(right.Evaluate());
				long ticks = (long)(timeSpan.Ticks * factor);
				if (ticks < TimeSpan.MinValue.Ticks || ticks > TimeSpan.MaxValue.Ticks)
				{
					ticks = 0;
					string text = left.ToString() + " * " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeConstant(new TimeSpan(ticks));
			}
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return this.MakeConstant(TimeSpan.Zero);
			else if (rightValue == 1.0f)
				return left;
			else if (rightValue == -1.0f)
				return new TimeUnaryMinusOperator(left);
		}
		return new RealTimeMulOperator(left, right);
	}

	private Expression MakeLRealTimeMulOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan timeSpan = (TimeSpan)left.Evaluate();
			
			if (timeSpan == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
			else if (right.IsConstant)
			{
				double factor = Convert.ToDouble(right.Evaluate());
				long ticks = (long)(timeSpan.Ticks * factor);
				if (ticks < TimeSpan.MinValue.Ticks || ticks > TimeSpan.MaxValue.Ticks)
				{
					ticks = 0;
					string text = left.ToString() + " * " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeConstant(new TimeSpan(ticks));
			}
		}
		else if (right.IsConstant)
		{
			double factor = Convert.ToDouble(right.Evaluate());
			if (factor == 0.0d)
				return this.MakeConstant(TimeSpan.Zero);
			else if (factor == 1.0d)
				return left;
			else if (factor == -1.0d)
				return new TimeUnaryMinusOperator(left);
		}
		return new LRealTimeMulOperator(left, right);
	}

	private Expression MakeIntDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				if (rightValue == 0)
				{
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
				else {
					long quotient = leftValue / rightValue;
					return MakeIntConstant(quotient);
				}
			}
			else if (leftValue == 0)
				return MakeIntConstant((long)0);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1)
				return left;
			else if (rightValue == -1)
				return new IntUnaryMinusOperator(left);
			else {
				int power;
				if (this.IsPowerOf2((ulong)Math.Abs(rightValue), out power))
				{
					Expression expr = new LeftShiftOperator(left, power);
					if (rightValue < 0)
						expr = new IntUnaryMinusOperator(expr);
					return expr;
				}
			}
		}
		if (left.DataType == right.DataType)
			return new IntDivOperator(left, right, left.DataType);
		else if (left.DataType == TypeNode.LInt)
			return new IntDivOperator(left, this.MakeInt2LInt(right), TypeNode.LInt);
		else if (right.DataType == TypeNode.LInt)
			return new IntDivOperator(this.MakeInt2LInt(left), right, TypeNode.LInt);
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			return new IntDivOperator(left, right, resultDataType);
		}
	}

	private Expression MakeTimeIntDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				if (rightValue == 0)
				{
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
				else {
					long ticks = leftValue.Ticks/rightValue;
					return this.MakeConstant(new TimeSpan(ticks));
				}
			}
			else if (leftValue == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1)
				return left;
			else if (rightValue == -1)
				return new TimeUnaryMinusOperator(left);
		}
		return new TimeIntDivOperator(left, right);		
	}

	private Expression MakeTimeRealDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				if (rightValue == 0.0f)
				{
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
				else {
					double ticks = leftValue.Ticks/(double)rightValue;
					return this.MakeConstant(new TimeSpan((long)ticks));
				}
			}
			else if (leftValue == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1.0f)
				return left;
			else if (rightValue == -1.0f)
				return new TimeUnaryMinusOperator(left);
		}
		return new TimeLRealDivOperator(left, right);		
	}

	private Expression MakeTimeLRealDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				if (rightValue == 0.0d)
				{
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
				else {
					double ticks = leftValue.Ticks/rightValue;
					return this.MakeConstant(new TimeSpan((long)ticks));
				}
			}
			else if (leftValue == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1.0f)
				return left;
			else if (rightValue == -1.0f)
				return new TimeUnaryMinusOperator(left);
		}
		return new TimeRealDivOperator(left, right);		
	}

	private Expression MakeRealDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			float leftValue = Convert.ToSingle(left.Evaluate());
			
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				float quotient = leftValue / rightValue;
				if (! float.IsInfinity(quotient))
					return MakeConstant(quotient);
				else {
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
			}
			if (leftValue == 0.0f)
				return MakeConstant(0.0f);
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1.0f)
				return left;
			else if (rightValue == -1.0f)
				return new RealUnaryMinusOperator(left);
		}
		return new RealDivOperator(left, right);		
	}

	private Expression MakeLRealDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				double quotient   = leftValue / rightValue;
				if (! double.IsInfinity(quotient))
					return MakeConstant(quotient);
				else {
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
			}
			else if (leftValue == 0.0d)
				return MakeConstant(0.0d);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1.0d)
				return left;
			else if (rightValue == -1.0d)
				return new LRealUnaryMinusOperator(left);
		}
		return new LRealDivOperator(left, right);		
	}

	private Expression MakeIntUnaryMinusOp(Expression expression)
	{
		if (expression.IsConstant)
		{
			long value = Convert.ToInt64(expression.Evaluate());
			return MakeIntConstant(-value);
		}
		else if (expression is IntUnaryMinusOperator)
			return ((UnaryOperator)expression).Operand;
		else
			return new IntUnaryMinusOperator(expression);
	}

	private Expression MakeIntPowerOp(Expression left, Expression right)
	{
		if (right.IsConstant)
		{
			int exponent = Convert.ToInt32(right.Evaluate());
			if (exponent < 0)
				return MakeConstant(0);
			else if (exponent == 0)
				return MakeConstant(1);
			else if (exponent == 1)
				return left;
			else if (left.IsConstant)
			{
				if (left.DataType.IsSignedIntType)
				{
					long base_ = Convert.ToInt64(left.Evaluate());
					long result = this.IntPower(base_, exponent);
					return MakeIntConstant(result); 
				}
				else {
					ulong base_ = Convert.ToUInt64(left.Evaluate());
					ulong result = this.IntPower(base_, exponent);
					return this.MakeIntConstant(result); 
				}
			}
		}
		return new IntPowerOperator(left, right, left.DataType);
	}

	private Expression MakeRealPowerOp(Expression left, Expression right)
	{
		if (! right.IsConstant)
		{
			if (right.DataType.IsIntegerType)
				return new RealPowerOperator(left, new Int2RealOperator(right));
			else if (right.DataType == TypeNode.Real)
				return new RealPowerOperator(left, right);
			else {
				string msg;
				msg = "MakeRealPowerOp(): Real type exponent expected.";
				throw new STLangCompilerError(msg);
			}
		}
		else if (right.DataType.IsIntegerType)
		{
			int exponent = Convert.ToInt32(right.Evaluate());
			
			if (exponent == 0)
				return MakeConstant(1.0f);
			else if (exponent == 1)
				return left;
			else if (left.IsConstant)
			{
				double base_ = Convert.ToDouble(left.Evaluate());
				float result = (float)Math.Pow(base_, exponent);
				return MakeConstant(result);
			}
			else if (Math.Abs(exponent) > 4)
				right = MakeConstant((float)exponent);
		}
		else if (right.DataType == TypeNode.Real)
		{
			float exponent = Convert.ToSingle(right.Evaluate());
			if (exponent == 0.0f)
				return MakeConstant(1.0f);
			else if (exponent == 1.0f)
				return left;
			else if (left.IsConstant)
			{
				double base_ = Convert.ToDouble(left.Evaluate());
				float result = (float)Math.Pow(base_, exponent);
				return MakeConstant(result);
			}
		}
		return new RealPowerOperator(left, right);
	}

	private Expression MakeLRealPowerOp(Expression left, Expression right)
	{
		if (! right.IsConstant)
		{
			if (right.DataType.IsIntegerType)
				return new LRealPowerOperator(left, new Int2LRealOperator(right));
			else if (right.DataType == TypeNode.LReal)
				return new LRealPowerOperator(left, right);
			else {
				string msg;
				msg = "MakeRealPowerOp(): LReal type exponent expected.";
				throw new STLangCompilerError(msg);
			}
		}
		else if (right.DataType.IsIntegerType)
		{
			int exponent = Convert.ToInt32(right.Evaluate());
			
			if (exponent == 0)
				return MakeConstant(1.0d);
			else if (exponent == 1)
				return left;
			else if (left.IsConstant)
			{
				double base_ = Convert.ToDouble(left.Evaluate());
				double result = Math.Pow(base_, exponent);
				return MakeConstant(result);
			}
			else if (Math.Abs(exponent) > 4)
				right = MakeConstant((double)exponent);
		}
		else if (right.DataType == TypeNode.LReal)
		{
			double exponent = Convert.ToDouble(right.Evaluate());
			if (exponent == 0.0d)
				return MakeConstant(1.0d);
			else if (exponent == 1.0d)
				return left;
			else if (left.IsConstant)
			{
				double base_ = Convert.ToDouble(left.Evaluate());
				double result = Math.Pow(base_, exponent);
				return MakeConstant(result);
			}
		}
		return new LRealPowerOperator(left, right);
	}

	private Expression MakeIntModOp(Expression left, Expression right, LexLocation location)
	{
		if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (left.IsConstant)
			{
				ulong leftValue = Convert.ToUInt64(left.Evaluate());
				ulong result = leftValue % rightValue;
				if (left.DataType.IsUnsignedIntType || right.DataType.IsUnsignedIntType)
					return this.MakeIntConstant(result);
				else
					return MakeIntConstant((long)result);
			}
			else {
				int power;

				if (this.IsPowerOf2(rightValue, out power))
				{
					long bitMask = 1;
					bitMask <<= power;
					bitMask -= 1;
					right = MakeIntConstant(bitMask);
					return new BitAndOperator(left, right, right.DataType);
				}
			}
		}
		return new ModOperator(left, right);
	}

	private Expression MakeAddOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;

			if (leftDataType == TypeNode.Error || rightDataType == TypeNode.Error)
				return Expression.Error;
			else if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntAddOp(left, right);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeIntUIntAddop(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealAddOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealAddOp(this.MakeInt2LReal(left), right, location);
			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntUIntAddop(right, left, location);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntAddop(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealAddOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealAddOp(this.MakeInt2LReal(left), right, location);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealAddOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealAddOp(this.MakeReal2LReal(left), right, location);
				else if (rightDataType.IsIntegerType)
					return this.MakeRealAddOp(left, this.MakeInt2Real(right), location);
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealAddOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealAddOp(left, this.MakeReal2LReal(right), location);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealAddOp(left, this.MakeInt2LReal(right), location);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTTAddOp(left, right, location);
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTTODAddOp(left, right, location);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.Time)
				return this.MakeTTODAddOp(right, left, location);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.Time)
				return this.MakeDTTimeAddOp(left, right, location);
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.DateAndTime)
				return this.MakeDTTimeAddOp(right, left, location);
			//
			// Error. Incompatible operand types of operator +
			//
			this.report.SemanticError(14, "+", leftDataType.Name, rightDataType.Name, location);
			return Expression.Error;
		}
	}

	private Expression MakeSubOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;

			if (leftDataType == TypeNode.Error || rightDataType == TypeNode.Error)
				return Expression.Error;
			else if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntSubOp(left, right);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeIntUIntSubOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealSubOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealSubOp(this.MakeInt2LReal(left), right, location);
			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntUIntSubOp(right, left, location);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntSubOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealSubOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealSubOp(this.MakeInt2LReal(left), right, location);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealSubOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealSubOp(this.MakeReal2LReal(left), right, location);
				else if (rightDataType.IsIntegerType)
					return this.MakeRealSubOp(left, this.MakeInt2Real(right), location);
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealSubOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealSubOp(left, this.MakeReal2LReal(right), location);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealSubOp(left, this.MakeInt2LReal(right), location);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeSubOp(left, right, location);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDaySubOp(left, right, location);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.Time)
				return this.MakeTimeOfDayTimeSubOp(right, left, location);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.Time)
				return this.MakeDateTimeTimeSubOp(left, right, location);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeSubOp(right, left, location);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateSubOp(right, left, location);
			//
			// Error. Incompatible operand types of operator -
			//
			this.report.SemanticError(14, "-", leftDataType.Name, rightDataType.Name, location);
			return Expression.Error;
		}
	}

	private Expression MakeMulOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;

			if (leftDataType == TypeNode.Error || rightDataType == TypeNode.Error)
				return Expression.Error;
			else if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntMulOp(left, right);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeIntUIntMulop(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealMulOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealMulOp(this.MakeInt2LReal(left), right, location);
				else if (rightDataType == TypeNode.Time)
					return this.MakeIntTimeMulOp(right, left, location);
			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntUIntMulop(right, left, location);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntMulop(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealMulOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealMulOp(this.MakeInt2LReal(left), right, location);
				else if (rightDataType == TypeNode.Time)
					return this.MakeIntTimeMulOp(right, left, location);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealMulOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealMulOp(this.MakeReal2LReal(left), right, location);
				else if (rightDataType.IsIntegerType)
					return this.MakeRealMulOp(left, this.MakeInt2Real(right), location);
				else if (rightDataType == TypeNode.Time)
					return this.MakeRealTimeMulOp(right, left, location);
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealMulOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealMulOp(left, this.MakeReal2LReal(right), location);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealMulOp(left, this.MakeInt2LReal(right), location);
				else if (rightDataType == TypeNode.Time)
					return this.MakeLRealTimeMulOp(right, left, location);
			}
			else if (leftDataType == TypeNode.Time)
			{
				if (rightDataType.IsIntegerType)
					return this.MakeIntTimeMulOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealTimeMulOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealTimeMulOp(right, left, location);
			}
			//
			// Error. Incompatible operand types of operator *
			//
			this.report.SemanticError(14, "*", leftDataType.Name, rightDataType.Name, location);
			return Expression.Error;
		}
	}

	private Expression MakeDivOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;

			if (leftDataType == TypeNode.Error || rightDataType == TypeNode.Error)
				return Expression.Error;
			else if (leftDataType.IsIntegerType)
			{
				if (rightDataType.IsIntegerType)
					return this.MakeIntDivOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealDivOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealDivOp(this.MakeInt2LReal(left), right, location);
			}         
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealDivOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealDivOp(this.MakeReal2LReal(left), right, location);
				else if (rightDataType.IsIntegerType)
					return this.MakeRealDivOp(left, this.MakeInt2Real(right), location);
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealDivOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealDivOp(left, this.MakeReal2LReal(right), location);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealDivOp(left, this.MakeInt2LReal(right), location);
			}
			else if (leftDataType == TypeNode.Time)
			{
				if (rightDataType.IsIntegerType)
					return this.MakeTimeIntDivOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeTimeRealDivOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeTimeLRealDivOp(right, left, location);
			}
			//
			// Error. Incompatible operand types of operator /
			//
			this.report.SemanticError(14, "/", leftDataType.Name, rightDataType.Name, location);
			return Expression.Error;
		}
	}

	private Expression MakeRealUnaryMinusOp(Expression expression)
	{
		if (! expression.IsConstant)
			return new RealUnaryMinusOperator(expression);
		else {
			float realValue = -(float)expression.Evaluate();
			return MakeConstant(realValue);
		}
	}

	private Expression MakeLRealUnaryMinusOp(Expression expression)
	{
		if (! expression.IsConstant)
			return new LRealUnaryMinusOperator(expression);
		else {
			double doubleValue = -(double)expression.Evaluate();
			return MakeConstant(doubleValue);
		}
	}

	private Expression MakeTimeUnaryMinusOp(Expression expression)
	{
		if (! expression.IsConstant)
			return new LRealUnaryMinusOperator(expression);
		else {
			double doubleValue = -(double)expression.Evaluate();
			return MakeConstant(doubleValue);
		}
	}

	private Expression MakeUnaryMinusOperator(Expression expression, LexLocation location)
	{
		if (expression == null)
			return Expression.Error;
		else {
			TypeNode dataType = expression.DataType;
			if (dataType == TypeNode.Error)
				return expression;
			else if (dataType.IsSignedIntType)
				return this.MakeIntUnaryMinusOp(expression);
			else if (dataType.IsUnsignedIntType)
			{
				// unary minus applied to unsigned int type has no effect
				this.report.Warning(8, dataType.Name, location);
				return expression;
			}
			else if (dataType == TypeNode.Real)
				return this.MakeRealUnaryMinusOp(expression);
			else if (dataType == TypeNode.LReal)
				return this.MakeLRealUnaryMinusOp(expression);
			else if (dataType == TypeNode.Time)
				return this.MakeTimeUnaryMinusOp(expression);
			else {
				this.report.SemanticError(-14, "-", dataType.Name, location);
				return Expression.Error;
			}
		}
	}

	private Expression MakeUnaryPlusOperator(Expression expression, LexLocation location)
	{
		if (expression == null)
			return Expression.Error;
		else {
			TypeNode dataType = expression.DataType;
			if (dataType == TypeNode.Error)
				return expression;
			else if (dataType.IsNumericalType)
				return expression;
			else if (dataType == TypeNode.Time)
				return expression;
			else {
				this.report.SemanticError(-14, "+", dataType.Name, location);
				return Expression.Error;
			}
		}
	}

	private bool IsBitWiseType(Expression expression)
	{
		TypeNode dataType = expression.DataType;
		return dataType.IsBitStringType || (dataType.IsIntegerType && expression.IsConstant);
	}

	private Expression MakeAndOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else if (! this.IsBitWiseType(left) || ! this.IsBitWiseType(right))
		{
			string dataTypeName1 = left.DataType.Name;
			string dataTypeName2 = right.DataType.Name;
			this.report.SemanticError(14, "AND", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			if (left.IsConstant)
			{
				ulong leftValue = Convert.ToUInt64(left.Evaluate());
				if (leftValue == 0)
					return this.MakeConstant(leftValue, resultDataType);
				else if (this.BitCount(leftValue) == resultDataType.BitCount)
					return right;
				else if (right.IsConstant)
				{
					ulong rightValue = Convert.ToUInt64(right.Evaluate());
					ulong result = leftValue & rightValue;
					return this.MakeConstant(result, resultDataType);
				}
			}
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				if (rightValue == 0)
					return this.MakeConstant(rightValue, resultDataType);
				else if (this.BitCount(rightValue) == resultDataType.BitCount)
					return left;
			}
			if (resultDataType != TypeNode.Bool)
				return new BitAndOperator(left, right, resultDataType);
			else if (left is AndOperator)
			{
				((AndOperator)left).Add(right);
				return left;
			}
			else if (right is AndOperator)
			{
				((AndOperator)right).AddLeft(left);
				return right;
			}
			return new AndOperator(left, right);
		}
	}

	private Expression MakeIOrOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else if (! this.IsBitWiseType(left) || ! this.IsBitWiseType(right))
		{
			string dataTypeName1 = left.DataType.Name;
			string dataTypeName2 = right.DataType.Name;
			this.report.SemanticError(14, "OR", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			if (left.IsConstant)
			{
				ulong leftValue = Convert.ToUInt64(left.Evaluate());
				if (leftValue == 0)
					return right;
				else if (this.BitCount(leftValue) == resultDataType.BitCount)
					return left;
				else if (right.IsConstant)
				{
					ulong rightValue = Convert.ToUInt64(right.Evaluate());
					ulong result = leftValue | rightValue;
					return this.MakeConstant(result, resultDataType);
				}
			}
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				if (rightValue == 0)
					return left;
				else if (this.BitCount(rightValue) == resultDataType.BitCount)
					return right;
			}
			if (resultDataType != TypeNode.Bool)
				return new BitIOrOperator(left, right, resultDataType);
			else if (left is IOrOperator)
			{
				((IOrOperator)left).Add(right);
				return left;
			}
			else if (right is IOrOperator)
			{
				((IOrOperator)right).AddLeft(left);
				return right;
			}
			return new IOrOperator(left, right);
		}
	}

	private Expression MakeXOrOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else if (! this.IsBitWiseType(left) || ! this.IsBitWiseType(right))
		{
			string DataTypeName1 = left.DataType.Name;
			string DataTypeName2 = right.DataType.Name;
			this.report.SemanticError(14, "XOR", DataTypeName1, DataTypeName2, location);
			return Expression.Error;
		}
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			if (left.IsConstant)
			{
				ulong leftValue = Convert.ToUInt64(left.Evaluate());
				if (leftValue == 0)
					return right;
				else if (right.IsConstant)
				{
					ulong rightValue = Convert.ToUInt64(right.Evaluate());
					ulong result = leftValue ^ rightValue;
					return this.MakeConstant(result, resultDataType);
				}
			}
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				if (rightValue == 0)
					return left;
			}
			if (resultDataType != TypeNode.Bool)
				return new BitXOrOperator(left, right, resultDataType);
			else {
				Expression leftTree = left.DeMorgan();
				Expression rightTree = right.DeMorgan();
				if (leftTree is AndOperator)
					((AndOperator)leftTree).Add(right);
				else
					leftTree = new AndOperator(leftTree, right);
				if (rightTree is AndOperator)
					((AndOperator)rightTree).Add(left);
				else
					rightTree = new AndOperator(left, rightTree);
				return new IOrOperator(leftTree, rightTree);
			}	
		}
	}

	private Expression MakeNotOperator(Expression expression, LexLocation location)
	{
		if (expression == null)
			return Expression.Error;
		else if (expression is FunctionName)
		{
			this.report.SemanticError(148, expression.ToString(), location);
			return Expression.Error;
		}
		else if (expression.DataType == TypeNode.Error)
			return Expression.Error;
		else if (! this.IsBitWiseType(expression))
		{
			string dataTypeName = expression.DataType.Name;
			this.report.SemanticError(-14, "NOT", dataTypeName, location);
			return Expression.Error;
		}
		else if (expression.IsConstant)
		{
			ulong value = Convert.ToUInt64(expression.Evaluate());
			return this.MakeConstant(~value, expression.DataType);
		}
		if (expression.DataType == TypeNode.Bool)
			return expression.DeMorgan();
		else
			return new BitNotOperator(expression);
	}

	private Expression MakePowOperator(Expression base_, Expression exponent, LexLocation location)
	{
		if (base_ == null || exponent == null)
			return Expression.Error;
        else if (base_ is FunctionName)
		{
			this.report.SemanticError(148, base_.ToString(), location);
			return Expression.Error;
		}
		else if (exponent is FunctionName)
		{
			this.report.SemanticError(148, exponent.ToString(), location);
			return Expression.Error;
		}
		else if (base_.DataType == TypeNode.Error || exponent.DataType == TypeNode.Error)
			return Expression.Error;
		else if (base_.DataType == TypeNode.LReal)
		{
			if (exponent.DataType == TypeNode.LReal)
				return this.MakeLRealPowerOp(base_, exponent);
			else if (exponent.DataType == TypeNode.Real)
				return this.MakeLRealPowerOp(base_, this.MakeReal2LReal(exponent));
			else if (exponent.DataType.IsIntegerType)
				return this.MakeLRealPowerOp(base_, exponent);
		}
		else if (base_.DataType == TypeNode.Real)
		{
			if (exponent.DataType == TypeNode.Real)
				return this.MakeRealPowerOp(base_, exponent);
			else if (exponent.DataType == TypeNode.LReal)
				return this.MakeRealPowerOp(this.MakeReal2LReal(base_), exponent);
			else if (exponent.DataType.IsIntegerType)
				return this.MakeRealPowerOp(base_, exponent);
		}
		else if (base_.DataType.IsIntegerType)
		{
			if (exponent.DataType.IsIntegerType)
				return this.MakeIntPowerOp(base_, exponent);
			else if (exponent.DataType == TypeNode.LReal)
				return this.MakeLRealPowerOp(this.MakeInt2LReal(base_), exponent);
			else if (exponent.DataType == TypeNode.Real)
				return this.MakeRealPowerOp(this.MakeInt2Real(base_), exponent);
		}
		//
		// Error. Incompatible operand types of operator **
		//
		string dataTypeName1 = base_.DataType.Name;
		string dataTypeName2 = exponent.DataType.Name;
		this.report.SemanticError(14, " ** ", dataTypeName1, dataTypeName2, location);
		return Expression.Error;
	}

	private Expression MakeModOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else if (left.DataType.IsIntegerType && right.DataType.IsIntegerType)
			return this.MakeIntModOp(left, right, location);
		else {
			//
			// Error. Incompatible operand types of operator MOD
			//
			string dataTypeName1 = left.DataType.Name;
			string dataTypeName2 = right.DataType.Name;
			this.report.SemanticError(14, " MOD ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeIntGtrOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue > rightValue);
			}
			else if (leftValue == 0)
				return new IntLesOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntGtrOperator(left, right, true);
		}
		return new IntGtrOperator(left, right);
	}

	private Expression MakeUIntGtrOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				return this.MakeConstant(leftValue > rightValue);
			}
			else if (leftValue == 0)
				return new IntLesOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntGtrOperator(left, right, true);
		}
		return new IntGtrOperator(left, right);
	}

	private Expression MakeRealGtrOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				Single rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue > rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatLesOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatGtrOperator(left, right, true);
		}
		return new FloatGtrOperator(left, right);
	}

	private Expression MakeLRealGtrOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue > rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealLesOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealGtrOperator(left, right, true);
		}
		return new LRealGtrOperator(left, right);
	}

	private Expression MakeTimeGtrOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeGtrOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeDateTimeGtrOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeGtrOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeStringGtrOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringGtrOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) > 0);
		}
	}

	private Expression MakeWStringGtrOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringGtrOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) > 0);
		}
	}

	private Expression MakeTimeOfDayGtrOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new TimeOfDayGtrOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeIntLesOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue < rightValue);
			}
			else if (leftValue == 0)
				return new IntGtrOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntLesOperator(left, right, true);
		}
		return new IntLesOperator(left, right);
	}

	private Expression MakeUIntLesOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				return this.MakeConstant(leftValue < rightValue);
			}
			else if (leftValue == 0)
				return new IntGtrOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntLesOperator(left, right, true);
		}
		return new IntLesOperator(left, right);
	}

	private Expression MakeRealLesOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				Single rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue < rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatGtrOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatLesOperator(left, right, true);
		}
		return new FloatLesOperator(left, right);
	}

	private Expression MakeLRealLesOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue < rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealGtrOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealLesOperator(left, right, true);
		}
		return new LRealLesOperator(left, right);
	}

	private Expression MakeTimeLesOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeLesOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeDateTimeLesOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeLesOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeStringLesOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringLesOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) > 0);
		}
	}

	private Expression MakeWStringLesOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringLesOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) > 0);
		}
	}

	private Expression MakeTimeOfDayLesOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new TimeOfDayLesOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeUIntEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new IntEqlOperator(left, right);
		else {
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeIntEqlOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue == rightValue);
			}
			else if (leftValue == 0)
				return new IntEqlOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntEqlOperator(left, right, true);
		}
		return new IntEqlOperator(left, right);
	}

	private Expression MakeRealEqlOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue == rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatEqlOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatEqlOperator(left, right, true);
		}
		return new FloatEqlOperator(left, right);
	}

	private Expression MakeLRealEqlOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue == rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealEqlOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealEqlOperator(left, right, true);
		}
		return new LRealEqlOperator(left, right);
	}

	private Expression MakeTimeEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeEqlOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeDateTimeEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeEqlOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeStringEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringEqlOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeWStringEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringEqlOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeTimeOfDayEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeOfDayEqlOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeIntNeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue != rightValue);
			}
			else if (leftValue == 0)
				return new IntNeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntNeqOperator(left, right, true);
		}
		return new IntNeqOperator(left, right);
	}

	private Expression MakeUIntNeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				return this.MakeConstant(leftValue != rightValue);
			}
			else if (leftValue == 0)
				return new IntNeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntNeqOperator(left, right, true);
		}
		return new IntNeqOperator(left, right);
	}

	private Expression MakeRealNeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue != rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatNeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatNeqOperator(left, right, true);
		}
		return new FloatNeqOperator(left, right);
	}

	private Expression MakeLRealNeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue != rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealNeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealNeqOperator(left, right, true);
		}
		return new LRealNeqOperator(left, right);
	}

	private Expression MakeTimeNeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeNeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue != rightValue);
		}
	}

	private Expression MakeDateTimeNeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeNeqOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue != rightValue);
		}
	}

	private Expression MakeStringNeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringNeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) != 0);
		}
	}

	private Expression MakeWStringNeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringNeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) != 0);
		}
	}

	private Expression MakeTimeOfDayNeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new TimeOfDayGeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue != rightValue);
		}
	}

	private Expression MakeIntGeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue >= rightValue);
			}
			else if (leftValue == 0)
				return new IntGeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntGeqOperator(left, right, true);
		}
		return new IntGeqOperator(left, right);
	}

	private Expression MakeUIntGeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				return this.MakeConstant(leftValue >= rightValue);
			}
			else if (leftValue == 0)
				return new IntLeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntGeqOperator(left, right, true);
		}
		return new IntGeqOperator(left, right);
	}

	private Expression MakeRealGeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue >= rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatLeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatGeqOperator(left, right, true);
		}
		return new FloatGeqOperator(left, right);
	}

	private Expression MakeLRealGeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue >= rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealLeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealGeqOperator(left, right, true);
		}
		return new LRealGeqOperator(left, right);
	}

	private Expression MakeTimeGeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeGeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue >= rightValue);
		}
	}

	private Expression MakeDateTimeGeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeGeqOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue >= rightValue);
		}
	}

	private Expression MakeStringGeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringGeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) >= 0);
		}
	}
	
	private Expression MakeWStringGeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringGeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) >= 0);
		}
	}


	private Expression MakeTimeOfDayGeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new TimeOfDayGeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue >= rightValue);
		}
	}

	private Expression MakeIntLeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue <= rightValue);
			}
			else if (leftValue == 0)
				return new IntGeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntLeqOperator(left, right, true);
		}
		return new IntLeqOperator(left, right);
	}

	private Expression MakeUIntLeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				return this.MakeConstant(leftValue <= rightValue);
			}
			else if (leftValue == 0)
				return new IntGeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntLeqOperator(left, right, true);
		}
		return new IntLeqOperator(left, right);
	}

	private Expression MakeRealLeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue <= rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatGeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatLeqOperator(left, right, true);
		}
		return new FloatLeqOperator(left, right);
	}

	private Expression MakeLRealLeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue <= rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealGeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealLeqOperator(left, right, true);
		}
		return new LRealLeqOperator(left, right);
	}

	private Expression MakeTimeLeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeLeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue <= rightValue);
		}
	}

	private Expression MakeDateTimeLeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeLeqOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue <= rightValue);
		}
	}

	private Expression MakeStringLeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringLeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) <= 0);
		}
	}

	private Expression MakeWStringLeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringLeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) <= 0);
		}
	}

	private Expression MakeTimeOfDayLeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new TimeOfDayLeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue <= rightValue);
		}
	}

	private Expression MakeGtrOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, ">", location);
					return this.MakeIntGtrOp(left, right);
				}
				else if (rightDataType.IsSignedIntType)
					return this.MakeIntGtrOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealGtrOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGtrOp(this.MakeInt2LReal(left), right);

			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, ">", location);
					return this.MakeUIntGtrOp(left, right);
				}
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntGtrOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealGtrOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGtrOp(this.MakeInt2LReal(left), right);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealGtrOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGtrOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealGtrOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGtrOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealGtrOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealGtrOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntGtrOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntGtrOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeGtrOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayGtrOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeGtrOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeGtrOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringGtrOp(left, right);
			else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringGtrOp(left, right);
			//
			// Error. Incompatible operand types of operator >
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " > ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeLesOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, "<", location);
					return this.MakeIntLesOp(left, right);
				}
				else if (rightDataType.IsSignedIntType)
					return this.MakeIntLesOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealLesOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLesOp(this.MakeInt2LReal(left), right);

			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, "<", location);
					return this.MakeUIntLesOp(left, right);
				}
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntLesOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealLesOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLesOp(this.MakeInt2LReal(left), right);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealLesOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLesOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealLesOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLesOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealLesOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealLesOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntLesOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntLesOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeLesOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayLesOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeLesOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeLesOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringLesOp(left, right);
			else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringLesOp(left, right);
			//
			// Error. Incompatible operand types of operator <
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " < ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeEqlOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntEqlOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealEqlOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealEqlOp(this.MakeInt2LReal(left), right);
				else if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, "=", location);
					return this.MakeIntEqlOp(left, right);
				}
			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
					return this.MakeIntEqlOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealEqlOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealEqlOp(this.MakeInt2LReal(left), right);
				else if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, "=", location);
					return this.MakeIntEqlOp(left, right);
				}
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealEqlOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealEqlOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealEqlOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealEqlOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealEqlOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealEqlOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntEqlOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntEqlOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeEqlOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayEqlOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeEqlOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeEqlOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringEqlOp(left, right);
			else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringEqlOp(left, right);
			//
			// Error. Incompatible operand types of operator =
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " = ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeNeqOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, "<>", location);
					return this.MakeIntNeqOp(left, right);
				}
				else if (rightDataType.IsSignedIntType)
					return this.MakeIntNeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealNeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealNeqOp(this.MakeInt2LReal(left), right);

			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, "<>", location);
					return this.MakeUIntNeqOp(left, right);
				}
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntNeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealNeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealNeqOp(this.MakeInt2LReal(left), right);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealNeqOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealNeqOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealNeqOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealNeqOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealNeqOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealNeqOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntNeqOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntNeqOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeNeqOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayNeqOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeNeqOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeNeqOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringNeqOp(left, right);
		    else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringNeqOp(left, right);
			//
			// Error. Incompatible operand types of operator <>
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " <> ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeGeqOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, ">=", location);
					return this.MakeIntGeqOp(left, right);
				}
				else if (rightDataType.IsSignedIntType)
					return this.MakeIntGeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealGeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGeqOp(this.MakeInt2LReal(left), right);

			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, "<>", location);
					return this.MakeUIntGeqOp(left, right);
				}
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntGeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealGeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGeqOp(this.MakeInt2LReal(left), right);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealGeqOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGeqOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealGeqOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGeqOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealGeqOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealGeqOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntGeqOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntGeqOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeGeqOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayGeqOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeGeqOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeGeqOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringGeqOp(left, right);
			else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringGeqOp(left, right);
			//
			// Error. Incompatible operand types of operator >=
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " >= ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeLeqOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, ">=", location);
					return this.MakeIntLeqOp(left, right);
				}
				else if (rightDataType.IsSignedIntType)
					return this.MakeIntLeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealLeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLeqOp(this.MakeInt2LReal(left), right);

			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, "<>", location);
					return this.MakeUIntLeqOp(left, right);
				}
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntLeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealLeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLeqOp(this.MakeInt2LReal(left), right);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealLeqOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLeqOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealLeqOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLeqOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealLeqOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealLeqOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntLeqOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntLeqOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeLeqOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayLeqOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeLeqOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeLeqOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringLeqOp(left, right);
			else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringLeqOp(left, right);
			//
			// Error. Incompatible operand types of operator <=
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " <= ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private ProgramOrganizationUnitCall MakePOUCall(string name, LexLocation location)
	{
		STLangSymbol symbol;
		if (! this.symbolTable.Lookup(name, out symbol, location))
		{
			STLangSymbol undefinedPOU;
			this.report.SemanticError(0, name, location);
			undefinedPOU = this.symbolTable.InstallUndefinedFunction(name, 10);
			return new STLangFunctionCall(undefinedPOU, location);
		}
		else if (symbol.IsFunction)
			return new STLangFunctionCall(symbol, location);
		else if (symbol.IsFunctionBlockInstance)
			return new STLangFunctionBlockCall(symbol, location);
		else
		{
			this.report.SemanticError(5, symbol.TypeName, name, location);
			return null;
		}
	}

	private ProgramOrganizationUnitCall MakePOUCall(string name, POUParameter argument, LexLocation location)
	{
		STLangSymbol symbol;
		if (! this.symbolTable.Lookup(name, out symbol, location))
		{
			STLangSymbol undefinedPOU;
			this.report.SemanticError(0, name, location);
			undefinedPOU = this.symbolTable.InstallUndefinedFunction(name, 10);
			return new STLangFunctionCall(undefinedPOU, argument, location);
		}
		else if (symbol.IsFunction)
		{
			if (argument.DataType == TypeNode.Bool && ! (symbol is SELFunctionSymbol))
			{
				if (argument.IsInputParameter && argument.RValue.IsCompoundExpression)
				{
					Expression input = new LoadBoolValueOperator(argument.RValue);
					LexLocation loc = argument.LexicalLocation;
					string inputName = argument.FormalName;
					argument = new InputParameter(inputName, input, loc);
				}
			}
			return new STLangFunctionCall(symbol, argument, location);
		}
		else if (symbol.IsFunctionBlockInstance)
		{
			FunctionBlockType dataType = symbol.DataType as FunctionBlockType;
			this.CheckFunctionBlockParameter(name, dataType, argument, location);
			if (argument.DataType == TypeNode.Bool && argument.RValue.IsCompoundExpression)
			{
				if (argument.IsInputParameter)
				{
					Expression input = new LoadBoolValueOperator(argument.RValue);
					LexLocation loc = argument.LexicalLocation;
					string inputName = argument.FormalName;
					argument = new InputParameter(inputName, input, loc);
				}
			}
			return new STLangFunctionBlockCall(symbol, argument, location);
		}
		else
		{
			this.report.SemanticError(5, symbol.TypeName, name, location);
			return null;
		}
	}

	private ProgramOrganizationUnitCall AddPOUParameter(ProgramOrganizationUnitCall pou, POUParameter argument)
	{
		if (pou == null)
			return null;
		else {
			if (pou.IsInputArgAssignment && ! argument.IsInputArgAssignment)
				this.report.SemanticError(185, argument.ToString(), argument.LexicalLocation);
			else if (! pou.IsInputArgAssignment && argument.IsInputArgAssignment)
				this.report.SemanticError(185,  argument.ToString(), argument.LexicalLocation);
			if (argument.DataType == TypeNode.Bool && argument.RValue.IsCompoundExpression)
			{
				if (argument.IsInputParameter)
				{
					Expression input = new LoadBoolValueOperator(argument.RValue);
					LexLocation loc = argument.LexicalLocation;
					string inputName = argument.FormalName;
					argument = new InputParameter(inputName, input, loc);
				}
			}
			if (pou.IsFunction)
			{
				pou.Add(argument);
				return pou;
			}
			else if (pou.IsFunctionBlock)
			{
				this.CheckFunctionBlockParameter(pou, argument);
				pou.Add(argument);
				return pou;
			}
		}
		throw new STLangCompilerError("AddPOUParameter(): Unknown type of POU.");
	}

	private ProgramOrganizationUnitCall MakePOUCall(ProgramOrganizationUnitCall pou, LexLocation location)
	{
		return pou;
	}

	private Expression MakeFunctionCall(ProgramOrganizationUnitCall pou)
	{
		if (pou == null)
			return Expression.Error;
		else if (pou.IsFunctionBlock)
		{
			// Error: Function block used as a function
			//
			this.report.SemanticError(135, pou.Name, pou.Location);
			return Expression.Error;
		}
		else {
			Expression functionCall = pou.MakeSyntaxTreeNode();
			if (! this.symbolTable.IsRecursiveCall(functionCall))
				return functionCall;
			else {
				// Error: Illegal recursive call
				//
				this.report.SemanticError(90, pou.Name, pou.Location);
				return Expression.Error;
			}
		}
	}

	private Statement MakeFunctionBlockCallStatement(ProgramOrganizationUnitCall pou)
	{
		if (pou == null)
			return Statement.Empty;
		else if (pou.IsFunction)
		{
			// Warning: Function call found where function block call was expected.
			//
			this.report.Warning(16, pou.Name, pou.Location);
			return Statement.Empty;
		}
		else
		{
			Expression expression = pou.MakeSyntaxTreeNode();
			return new FunctionBlockCallStatement(expression);
		}
	}

	private POUParameter MakeParameter(Expression argument, LexLocation location)
	{
		if (argument == null)
			return new InputParameter(Expression.Error, location);
		else if (argument is FunctionName)
		{
			this.report.SemanticError(148, argument.ToString(), location);
			return new InputParameter(Expression.Error, location);
		}
		return new InputParameter(argument, location);
	}

	private POUParameter MakeParameter(string formalParam, Tokens assignToken, Expression argument, LexLocation location, bool inverted = false)
	{
		if (argument == null)
			argument = Expression.Error;
		else if (argument is FunctionName)
			this.report.SemanticError(148, argument.ToString(), location);
		if (assignToken == Tokens.OUTPUT_ASSIGN)
			return new OutputParameter(formalParam, argument, inverted, location);
		else if (assignToken == Tokens.ASSIGN)
		{
			if (inverted)
				this.report.SyntaxError(184, formalParam, location);
			return new InputParameter(formalParam, argument, location);
		}
		throw new STLangCompilerError("MakeParameter(): Unkown assignment token.");
	}

	private void CheckFunctionBlockParameter(ProgramOrganizationUnitCall pou, POUParameter argument)
	{
		FunctionBlockType functionBlock;
		functionBlock = pou.Symbol.DataType as FunctionBlockType;
		this.CheckFunctionBlockParameter(pou.Name, functionBlock, argument, pou.Location);
	}

	private void CheckFunctionBlockParameter(string pouName, FunctionBlockType functionBlock, POUParameter argument, LexLocation location)
	{
		InstanceSymbol formal;
		string formalName = argument.FormalName;

		if (formalName.Length == 0)
			this.report.SemanticError(174, pouName, argument.LexicalLocation);
		else if (! functionBlock.LookUp(formalName, out formal))
			this.report.SemanticError(141, formalName, pouName, argument.LexicalLocation);
		else if (argument.RValue != null)
		{
			argument.Position = formal.Position;
			if (argument.IsOutputParameter)
			{
				Expression lValue;

				lValue = formal.MakeSyntaxTreeNode(argument.LexicalLocation);
				argument.LValue = lValue;
			}
			Expression actual = argument.RValue;
			TypeNode actualDataType = actual.DataType;
			LexLocation formalLoc = argument.LexicalLocation;
			switch (formal.VariableType)
			{
				case STVarType.VAR_INPUT:
				break;

				case STVarType.VAR_INOUT:
					//
					// Check that the actual argument is an l-value
					//
					if (! actual.IsLValue && actualDataType != TypeNode.Error)
						this.report.SemanticError(78, pouName, formalName, formalLoc);
					if (! argument.IsInputParameter)
						this.report.SemanticError(175, formalName, formalLoc);
					break;

				case STVarType.VAR_OUTPUT:
					if (! actual.IsLValue && actualDataType != TypeNode.Error)
						this.report.SemanticError(189, pouName, formalName, formalLoc);
					if (! argument.IsOutputParameter)
					{
						if (! actual.IsLValue)
							this.report.SemanticError(176, formalName, formalLoc);
						else
							this.report.SemanticError(173, actual.ToString(), formalName, formalLoc);
					}
					break;

				default:
					this.report.SemanticError(180, formalName, formalLoc);
					break;
			}
			TypeNode formalDataType = formal.DataType;
			float conversionCost = formalDataType.ConversionCost(actual);
			if (conversionCost > 0.0 && actualDataType != TypeNode.Error)
			{
				if (actual.IsConstant)
				{
					if (formalDataType == TypeNode.LReal)
					{
						if (actualDataType == TypeNode.Real || actualDataType.IsIntegerType)
						{
							double doubleValue;
							doubleValue = Convert.ToDouble(actual.Evaluate());
							actual = MakeConstant(doubleValue);
						}
						else {
							string typeName = formalDataType.Name;
							string constValue = actual.ToString();
							this.report.SemanticError(177, formalName, constValue, typeName, location);
							actual = Expression.Error;
						}
					}
					else if (formalDataType == TypeNode.Real)
					{
						if (actualDataType.IsIntegerType)
						{
							float floatValue;
							floatValue = Convert.ToSingle(actual.Evaluate());
							actual = MakeConstant(floatValue);
						}
						else {
							string typeName = formalDataType.Name;
							string constValue = actual.ToString();
							this.report.SemanticError(177, formalName, constValue, typeName, location);
							actual = Expression.Error;
						}
					}
					else if (formalDataType.IsIntegerType)
					{
						if (actualDataType.IsIntegerType)
						{
							if (actualDataType.Size > formalDataType.Size)
							{
								string typeName = formalDataType.Name;
								string constValue = actual.ToString();
								this.report.SemanticError(178, constValue, formalName, typeName, location);
							}
						}
						else {
							string typeName = formalDataType.Name;
							string constValue = actual.ToString();
							this.report.SemanticError(177, formalName, constValue, typeName, location);
							actual = Expression.Error;
						}
					}
					else if (formalDataType.IsBitStringType)
					{
						if (actualDataType.IsBitStringType)
						{
							if (actualDataType.Size > formalDataType.Size)
							{
								string typeName = formalDataType.Name;
								string constValue = actual.ToString();
								this.report.SemanticError(178, constValue, formalName, typeName, location);
							}
						}
						else if (actualDataType.IsIntegerType)
						{
							if (actualDataType.Size > formalDataType.Size)
							{
								string typeName = formalDataType.Name;
								string constValue = actual.ToString();
								this.report.SemanticError(178, constValue, formalName, typeName, location);
							}
							else {
								ulong value = Convert.ToUInt64(actual.Evaluate());
								actual = this.MakeConstant(value, formalDataType);
							}
						}
						else {
							string typeName = formalDataType.Name;
							string constValue = actual.ToString();
							this.report.SemanticError(177, formalName, constValue, typeName, location);
							actual = Expression.Error;
						}
					}
				}
				else if (formalDataType == TypeNode.LReal)
				{
					if (actualDataType.IsIntegerType)
						actual = this.MakeInt2LReal(actual);
					else if (actualDataType == TypeNode.Real)
						actual = this.MakeReal2LReal(actual);
					else if (this.ConversionOperatorExists(TypeNode.LReal, actualDataType))
					{
						actual = Expression.Error;
						this.report.SemanticError(64, actualDataType.Name, formalDataType.Name, location);
					}
					else {
						actual = Expression.Error;
						this.report.SemanticError(150, actualDataType.Name, formalDataType.Name, location);
					}
				}
				else if (formalDataType == TypeNode.Real)
				{
					if (actualDataType.IsIntegerType)
						actual = this.MakeInt2Real(actual);
					else if (this.ConversionOperatorExists(TypeNode.Real, actualDataType))
					{
						actual = Expression.Error;
						this.report.SemanticError(64, actualDataType.Name, formalDataType.Name, location);
					}
					else {
						actual = Expression.Error;
						this.report.SemanticError(150, actualDataType.Name, formalDataType.Name, location);
					}
				}
			}
		}
	}

	private void CheckVarTypeQualUsage(STVarType variableType, STVarQualifier qualifier, LexLocation loc1, LexLocation loc2)
	{
		this.variableType = variableType;
		this.variableQualifier = qualifier;

		// Kolla att kombinationen POU-typ + variabeltyp + attribut r giltig.

		switch (variableType)
		{
		case STVarType.VAR:
			break;

		case STVarType.VAR_INPUT:
			if (qualifier == STVarQualifier.CONSTANT)
				this.report.SemanticError(158, "VAR_INPUT", "CONSTANT", loc1);
			break;

		case STVarType.VAR_OUTPUT:
			if (qualifier == STVarQualifier.CONSTANT)
				this.report.SemanticError(158, "VAR_OUTPUT", "CONSTANT", loc1);
			break;

		case STVarType.VAR_INOUT:
			if (qualifier != STVarQualifier.NONE)
				this.report.SemanticError(158, "VAR_INOUT", variableType.ToString(), loc1);
			break;

		case STVarType.VAR_GLOBAL:
			this.report.SemanticError(156, "VAR_GLOBAL", loc1);
			break;

		case STVarType.VAR_CONFIG:
			if (qualifier != STVarQualifier.NONE)
				this.report.SemanticError(158, "VAR_ACCESS", variableType.ToString(), loc1);
			break;

		case STVarType.VAR_EXTERNAL:
			if (this.isFunctionDecl)
				this.report.SemanticError(156, "VAR_EXTERNAL", loc1);
			if (qualifier == STVarQualifier.RETAIN) 
				this.report.SemanticError(158, "VAR_EXTERNAL", "RETAIN", loc1);
			else if (qualifier == STVarQualifier.NON_RETAIN)
				this.report.SemanticError(158, "VAR_EXTERNAL", "NON_RETAIN", loc1);
			break;

		case STVarType.VAR_TEMP:
			if (this.isFunctionDecl)
				this.report.SemanticError(46, "VAR_TEMP", loc1);
			if (qualifier == STVarQualifier.RETAIN) 
				this.report.SemanticError(158, "VAR_TEMP", "RETAIN", loc1);
			else if (qualifier == STVarQualifier.NON_RETAIN)
				this.report.SemanticError(158, "VAR_TEMP", "NON_RETAIN", loc1);
			break;

		case STVarType.VAR_ACCESS:
			this.report.SemanticError(156, "VAR_ACCESS", loc1);
			if (qualifier != STVarQualifier.NONE)
				this.report.SemanticError(158, "VAR_ACCESS", variableType.ToString(), loc1);
			break;

		default:
			break;
		}
	}

	private void CheckDeclQualifierUsage(TypeNode dataType, STVarQualifier varQualifier, STDeclQualifier declQualifier, LexLocation location)
	{
		switch (declQualifier)
		{
		case STDeclQualifier.NONE:
			break;

		case STDeclQualifier.READ_ONLY:
		case STDeclQualifier.WRITE_ONLY:
			if (this.variableType != STVarType.VAR_ACCESS)
			{
				string varType = this.variableType.ToString();
				string edgeQual = declQualifier.ToString();
				this.report.SemanticError(158, varType, edgeQual, location);
			}
			break;

		case STDeclQualifier.F_EDGE:
		case STDeclQualifier.R_EDGE:
			if (this.isFunctionDecl)
				this.report.SemanticError(159, declQualifier.ToString(), location);
			if (dataType != TypeNode.Bool)
				this.report.SemanticError(160, declQualifier.ToString(), location);
			break;
		}
		if (dataType.IsFunctionBlockType && varQualifier == STVarQualifier.CONSTANT)
			this.report.SemanticError(179, dataType.Name, location);
	}

	private POUType ProgOrgType
	{
		get 
		{
			if (this.isFunctionDecl)
				return POUType.FUNCTION;
			else if (this.isFunctionBlockDecl)
				return POUType.FUNCTION_BLOCK;
			else
				return POUType.PROGRAM;
		}
	}

	private DeclarationStatement MakeFormalParameterDecl(STVarType varType, STVarQualifier varQual, List<VarDeclStatement> formalParDeclList)
	{
		return new IOParameterDeclaration(varType, varQual, formalParDeclList, this.ProgOrgType);
	}

	private DeclarationStatement MakeLocalVariableDecl(STVarType varType, STVarQualifier varQual, List<VarDeclStatement> localVarDeclList)
	{
		return new LocalVarDeclaration(localVarDeclList, varType, varQual, this.ProgOrgType);
	}

	private POUVarDeclarations MakeEmptyPOUVarDecl()
	{
		return new POUVarDeclarations();
	}

	private List<VarDeclStatement> MakeEmptyVarDecl()
	{
		return new List<VarDeclStatement>();
	}

	private List<VarDeclStatement> MakeVariableDeclList(VarDeclStatement varInitDecl)
	{
		List<VarDeclStatement> varInitDeclList = new List<VarDeclStatement>();
		if (varInitDecl != null)
			varInitDeclList.Add(varInitDecl);
		return varInitDeclList;
	}

	private List<VarDeclStatement> AddToVariableDeclList(List<VarDeclStatement> varInitDeclList, VarDeclStatement varInitDecl)
	{
		if (varInitDeclList == null)
			varInitDeclList = new List<VarDeclStatement>();
		if (varInitDecl != null)
			varInitDeclList.Add(varInitDecl);
		return varInitDeclList;
	}

	private POUVarDeclarations MakePOUVarDeclList(DeclarationStatement declaration)
	{
		POUVarDeclarations pouVarDeclarations = new POUVarDeclarations();
		if (declaration != null)
			pouVarDeclarations.Add(declaration);
		return pouVarDeclarations;
	}

	private POUVarDeclarations AddPOUVarDeclToList(POUVarDeclarations pouDeclList, DeclarationStatement declaration)
	{
		if (pouDeclList == null)
			pouDeclList = new POUVarDeclarations();
		if (declaration != null)
			pouDeclList.Add(declaration);
		return pouDeclList;
	}

	private void StoreArrayInitializer(ArrayInitializer arrayInit)
	{
		TypeNode elementType = arrayInit.BasicElementType;
		int alignment = (int)elementType.Alignment;
		byte[] bytes = arrayInit.GetBytes();
		int offset = ByteCodeGenerator.StoreByteArray(bytes, alignment);
		arrayInit.AbsoluteAddress = MakeIntConstant(offset);
	}

	private VarDeclStatement MakeVarDeclStatement(List<MemoryObject> variables, TypeNode dataType, STVarType varType, 
	                                    STDeclQualifier declQual, Expression initialValue, int elementCount = 1)
	{
		Expression declSize;
		if (varType == STVarType.VAR_INOUT)
		{
		    // Store offset of variable as a DINT
			//
			int byteCount = variables.Count*(int)TypeNode.DInt.Size;
			declSize = MakeIntConstant(byteCount);
			return new ElementaryVarDeclStatement(variables, dataType, declQual, initialValue, declSize);
		}
		else if (dataType.IsElementaryType)
		{
			int byteCount = variables.Count*(int)dataType.Size;
			declSize = MakeIntConstant(byteCount);
			return new ElementaryVarDeclStatement(variables, dataType, declQual, initialValue, declSize);
		}
		else if (dataType.IsAnyStringType)
		{
            //
            // Store information about string buffer offset and size.
            //
			int stringType = dataType.IsStringType ? 0 : 1;
            foreach (MemoryObject variable in variables)
            {
                if (variable.Location is StringLocation)
                {
                    StringLocation stringLocation;

                    stringLocation = (StringLocation)variable.Location;
                    int bufferSize = (int)variable.DataType.Size;
                    int bufferOffset = stringLocation.BufferOffset;
					int index = stringLocation.Index;
					ByteCodeGenerator.StoreStringVariableData(bufferOffset, index, bufferSize, stringType);
                }
            }
			int byteCount = variables.Count*(int)dataType.Size;
			declSize = MakeIntConstant(byteCount);
			return new ElementaryVarDeclStatement(variables, dataType, declQual, initialValue, declSize);
		}
		else if (dataType.IsStructType)
		{
			VarDeclStatement memberInitStat;
			List<VarDeclStatement> memberInitCollection;
			int byteCount = variables.Count*(int)dataType.Size;
			FieldSymbol field = ((StructType)dataType.BaseType).FirstField;

			declSize = MakeIntConstant(byteCount);
			memberInitCollection = new List<VarDeclStatement>();
			if (initialValue is StructInitializer)
			{
				Expression initializer;
				List<MemoryObject> members;
				StructInitializer structInit = (StructInitializer)initialValue;
				while (field != null)
				{
					if (structInit.Contains(field.Name, out initializer))
					{
						members = this.CreateMemberList(variables, field.Name);
						memberInitStat = this.MakeVarDeclStatement(members, field.DataType, varType, declQual, initializer, elementCount);
						memberInitCollection.Add(memberInitStat);
					}
					field = field.Next;
				}
			}
			return new StructVarDeclStatement(variables, dataType, declQual, initialValue, declSize, memberInitCollection);
		}
		else if (dataType.IsFunctionBlockType)
		{
			if (initialValue is FunctionBlockInitializer)
			{
				int byteCount;
				InstanceSymbol member;
				Expression initializer;
				List<MemoryObject> members;
				VarDeclStatement memberDeclStat;
				List<VarDeclStatement> memberDeclStats;
				FunctionBlockInitializer functionBlockInit;

				byteCount = variables.Count*(int)dataType.Size;
				declSize = MakeIntConstant(byteCount);
				memberDeclStats = new List<VarDeclStatement>();
				functionBlockInit = (FunctionBlockInitializer)initialValue;
				member = ((FunctionBlockType)dataType.BaseType).FirstMember;
				while (member != null)
				{
					if (functionBlockInit.Contains(member.Name, out initializer))
					{
						members = this.CreateMemberList(variables, member.Name);
						memberDeclStat = this.MakeVarDeclStatement(members, member.DataType, varType, declQual, initializer, elementCount);
						memberDeclStats.Add(memberDeclStat);
					}
					member = member.Next;
				}
				return new FunctionBlockVarDeclStat(variables, dataType, declQual, initialValue, declSize, memberDeclStats);
			}
		}
		else if (dataType.IsArrayType)
		{
		    ArrayType array = (ArrayType)dataType;
            TypeNode elementType = array.BasicElementType;

			if (elementType.IsElementaryType || elementType.IsAnyStringType)
            {
				if (initialValue is DefaultArrayInitializer)
				{
					int initValCase;
					if (initialValue.IsZero)
					{
						initValCase = 0;
						int byteCount = variables.Count*(int)dataType.Size;
						declSize = MakeIntConstant(byteCount);
					}
					else {
						initValCase = 1;
						uint size = elementType.Size;
						long elemCount = (dataType.Size / size)*variables.Count;
						declSize = MakeIntConstant(elemCount);
					}
					if (elementType.IsAnyStringType)
					{
						int stringType = elementType.IsStringType ? 0 : 1;
						int bufferSize = (int)elementType.Size;
						int elemCount = (int)(dataType.Size / bufferSize);
						foreach (MemoryObject variable in variables)
						{
							if (variable.Location is StringLocation)
							{
								StringLocation stringLocation;

								stringLocation = (StringLocation)variable.Location;
								int bufferOffset = stringLocation.BufferOffset;
								int index = stringLocation.Index;
								ByteCodeGenerator.StoreStringVariableData(bufferOffset, index, bufferSize, stringType, elemCount);
							}
						}
					}
					return new ArrayVarDeclStatement(variables, dataType, declQual, initialValue, declSize, initValCase);
				}
				else if (initialValue is ArrayInitializer)
				{
					STVarQualifier varQual = this.variableQualifier;
					ArrayInitializer arrayInit = (ArrayInitializer)initialValue;
					if (elementType.IsAnyStringType)
					{
						int stringType = elementType.IsStringType ? 0 : 1;
						int bufferSize = (int)elementType.Size;
						int elemCount = (int)(dataType.Size / bufferSize);
						foreach (MemoryObject variable in variables)
						{
							if (variable.Location is StringLocation)
							{
								StringLocation stringLocation;

								stringLocation = (StringLocation)variable.Location;
								int bufferOffset = stringLocation.BufferOffset;
								int index = stringLocation.Index;
								ByteCodeGenerator.StoreStringVariableData(bufferOffset, index, bufferSize, stringType, elemCount);
							}
						}
					}
					if (arrayInit.IsConstant)
					{
						this.StoreArrayInitializer(arrayInit);
						declSize = MakeIntConstant((long)dataType.Size);
						if (this.IsConstantVarDecl(varQual))
							return new ArrayVarDeclStatement(variables, dataType, declQual, arrayInit, declSize, 3);
						else
							return new ArrayVarDeclStatement(variables, dataType, declQual, arrayInit, declSize, 2);
					}
					else {
						int constCount = 0;
						IEnumerable<Expression> initializerList;

						initializerList = arrayInit.FlattenedInitializerList;
						foreach (Expression initValue in initializerList)
						{
							if (initValue.IsConstant)
								constCount++;
						}
						double constRatio = (double)constCount/initializerList.Count();
						if (constRatio < 0.7)
						{
							declSize = MakeIntConstant(initializerList.Count());
							if (this.IsConstantVarDecl(varQual))
								return new ArrayVarDeclStatement(variables, dataType, declQual, initialValue, declSize, 3, constRatio);
							else
								return new ArrayVarDeclStatement(variables, dataType, declQual, initialValue, declSize, 2, constRatio);
						}
						else {
							int i,offset;
							int baseIndex; 
							Expression defaultValue;
							ArrayInitializer newArrayInit;
							List<AssignmentStat> assignStatList;
							List<Expression> constInitList,nonConstInitList;

							constInitList = new List<Expression>();
							nonConstInitList = new List<Expression>();
							defaultValue = elementType.DefaultValue;
							declSize = MakeIntConstant((long)dataType.Size);
							foreach (Expression initValue in initializerList)
							{
								if (initValue.IsConstant)
									constInitList.Add(initValue);
								else {
									constInitList.Add(defaultValue);
									nonConstInitList.Add(initValue);
								}
							}
							assignStatList = new List<AssignmentStat>();
							newArrayInit = arrayInit.CreateInitList(constInitList);
							this.StoreArrayInitializer(newArrayInit);
							foreach (MemoryObject variable in variables)
							{
								i = 0;
								offset = 0;
								baseIndex = variable.Location.Index;
								foreach (Expression initValue in initializerList)
								{
									if (! initValue.IsConstant)
									{
										Expression lValue;
										MemoryLocation location;
										AssignmentStat assignStat;
                                        string name = variable + "[" + offset + "]";
										Expression rValue = nonConstInitList[i++];
										location = new ElementaryLocation(baseIndex + offset, elementType);
										lValue = new MemoryObject(name, location, elementType, variable.Symbol, 4);
										assignStat = new SimpleAssignmentStat(lValue, rValue);
										assignStatList.Add(assignStat);
									}
									offset++;
								}
							}
							if (this.IsConstantVarDecl(varQual))
								return new ArrayVarDeclStatement(variables, dataType, declQual, newArrayInit, declSize, 3, constRatio, assignStatList);
							else
								return new ArrayVarDeclStatement(variables, dataType, declQual, newArrayInit, declSize, 2, constRatio, assignStatList);
						}
					}
				}
			}
			else if (elementType.IsStructType)
			{
				VarDeclStatement memberInitStat;
				InitializerList flattenedInitList;
				StructType structure = (StructType)elementType.BaseType;
				FieldSymbol field = structure.FirstField;
				List<VarDeclStatement> memberInitCollection;
				Expression size = MakeIntConstant((long)dataType.Size);

				memberInitCollection = new List<VarDeclStatement>();
			    if (initialValue is ArrayOfStructInitializer)
				{
					List<MemoryObject> members;
					ArrayOfStructInitializer arrayOfStructInit;
					arrayOfStructInit = (ArrayOfStructInitializer)initialValue;
					elementCount = (int)(array.Size/elementType.Size)*elementCount;

					while (field != null)
					{
						members = this.CreateMemberList(variables, field); 
						flattenedInitList = arrayOfStructInit.GetFlattenedInitializerList(field.Name);
						memberInitStat = this.MakeVarDeclStatement(members, flattenedInitList.DataType, varType, declQual, flattenedInitList, elementCount);
						memberInitCollection.Add(memberInitStat);
						field = field.Next;
					}
				}
				return new ArrayOfStructVarDeclStatement(variables, dataType, declQual, initialValue, size, memberInitCollection);
			}
			else if (elementType.IsFunctionBlockType)
			{
			}
		}
		Expression zeroSize = MakeIntConstant((long)0);
		return new ElementaryVarDeclStatement(variables, dataType, declQual, initialValue, zeroSize);
	}

	private List<MemoryObject> CreateMemberList(List<MemoryObject> variables, FieldSymbol field)
	{
		InstanceSymbol symbol;
		List<MemoryObject> members = new List<MemoryObject>();

		foreach (MemoryObject variable in variables)
		{
			symbol = variable.Symbol;
			if (symbol.IsArrayInstance)
			{
                InstanceSymbol elementSymbol;
                ArrayInstanceSymbol arraySymbol;

				arraySymbol = (ArrayInstanceSymbol)symbol;
                elementSymbol = arraySymbol.ElementSymbol;
                if (elementSymbol.IsStructInstance)
                {
                    InstanceSymbol memberSymbol;
                    StructInstanceSymbol structure;

                    structure = (StructInstanceSymbol)elementSymbol;
                    if (structure.LookUp(field.Name, out memberSymbol))
					{
						MemoryObject member;

						member = (MemoryObject)memberSymbol.MakeSyntaxTreeNode();
                        members.Add(member);
					}
                }
			}
		}
		return members;
	}

	private List<MemoryObject> CreateMemberList(List<MemoryObject> variables, string member)
	{
		InstanceSymbol symbol;
		List<MemoryObject> members = new List<MemoryObject>();

		foreach (MemoryObject variable in variables)
		{
			symbol = variable.Symbol;
            if (symbol.IsCompoundInstanceSymbol)
            {
                InstanceSymbol memberSymbol;
                CompoundInstanceSymbol compoundSymbol;

                compoundSymbol = (CompoundInstanceSymbol)symbol;
                if (compoundSymbol.LookUp(member, out memberSymbol))
				{
					MemoryObject memberObject;

					memberObject = (MemoryObject)memberSymbol.MakeSyntaxTreeNode();
                    members.Add(memberObject);
				}
            }
		}
		return members;
	}

	private VarDeclStatement InstallLocalVars(List<string> identifiers, TypeNode dataType, STDeclQualifier declQual, LexLocation location)
	{
		if (identifiers == null)
			return null;
		else if (identifiers.Count == 0)
			return null;
		else {
			STVarType varType = this.variableType;
			Expression initialValue = dataType.DefaultValue;
			STVarQualifier varQual = this.variableQualifier;
			List<InstanceSymbol> symbols = new List<InstanceSymbol>();

			this.CheckDeclQualifierUsage(dataType, varQual, declQual, location);
			foreach (string name in identifiers)
			{
				InstanceSymbol symbol;
				symbol = this.rwMemoryManager.CreateSymbol(name, dataType, varType, varQual, declQual, initialValue, this.variablePosition);
				symbols.Add(symbol);
				this.variablePosition++;
			}
			this.symbolTable.InstallLocalVariables(symbols);
			if (this.IsConstantVarDecl(varQual))
            {
                // Error. Constant variables must be assigned a value in the declaration.
                this.report.SemanticError(9, location);
				// CONSTANT variables (with constant initializers) are initialized at compile time
                if (dataType.IsElementaryType)
                    return null;
            }
            MemoryObject variable;
            List<MemoryObject> variables = new List<MemoryObject>();

            foreach (InstanceSymbol symbol in symbols)
            {
                variable = (MemoryObject)symbol.MakeSyntaxTreeNode();
                variables.Add(variable);
            }
            return this.MakeVarDeclStatement(variables, dataType, varType, declQual, initialValue);
		}
	}

	private bool IsConstantVarDecl(STVarQualifier varQual)
	{
		return varQual == STVarQualifier.CONSTANT 
		    || varQual == STVarQualifier.CONSTANT_RETAIN;
	}

	private VarDeclStatement InstallLocalVars(List<string> identifiers, TypeNode dataType, STDeclQualifier declQual, Expression initialValue, LexLocation location)
	{
		this.Pop(); // Remove datatype saved on stack.
		if (identifiers == null)
			return null;
		else if (identifiers.Count == 0)
			return null;
		else {
			STVarType varType = this.variableType;
			STVarQualifier varQual = this.variableQualifier;
			List<InstanceSymbol> symbols = new List<InstanceSymbol>();

			this.CheckDeclQualifierUsage(dataType, varQual, declQual, location);
			foreach (string name in identifiers)
			{
				InstanceSymbol symbol;
				int pos = this.variablePosition++;
				symbol = this.rwMemoryManager.CreateSymbol(name, dataType, varType, varQual, declQual, initialValue, pos);
				symbols.Add(symbol);
			}
			this.symbolTable.InstallLocalVariables(symbols);
			if (this.IsConstantVarDecl(varQual) && initialValue.IsConstant && dataType.IsElementaryType)
				return null;  // Don't reserve memory for CONSTANT variables (with constant initializers) of elementary type.
			else {
				MemoryObject variable;
				List<MemoryObject> variables = new List<MemoryObject>();

				foreach (InstanceSymbol symbol in symbols)
				{
					variable = (MemoryObject)symbol.MakeSyntaxTreeNode();
					variables.Add(variable);
				}
				if (initialValue.IsLValue && !dataType.IsElementaryType)
				{
					MemoryObject memoryObject = (MemoryObject)initialValue;

					initialValue = memoryObject.InitialValue;
				}
				return this.MakeVarDeclStatement(variables, dataType, varType, declQual, initialValue);
			}
		}
	}

	private VarDeclStatement InstallSymbolicVariable(string name, DataTypeSpec dataTypeSpec, TokenDirectVar directVar, LexLocation loc)
	{
		if (! this.symbolTable.IsValidUserDefinedSymbol(name, loc))
			return null;
		else {
			InstanceSymbol symbol;
			TypeNode dataType = dataTypeSpec.DataType;
			STDeclQualifier declQual = dataTypeSpec.DeclQualifier;
			Expression initialValue = dataTypeSpec.InitialValue;
			this.symbolTable.InstallDirectVariable(name, dataType, this.variableType, this.variableQualifier,
			                                       dataTypeSpec.DeclQualifier, directVar.Size, directVar.Location, 
												   directVar.Address, out symbol);
			Expression size = MakeIntConstant((long)dataType.Size);
			List<MemoryObject> variables = new List<MemoryObject>();
			variables.Add((MemoryObject)symbol.MakeSyntaxTreeNode());
			return new ElementaryVarDeclStatement(variables, dataType, declQual, size, initialValue);
		}
	}

	private VarDeclStatement InstallDirectVariable(TokenDirectVar directVar, DataTypeSpec dataTypeSpec, LexLocation loc)
	{
		string name = directVar.ToString();
		if (! this.symbolTable.IsValidUserDefinedSymbol(name, loc))
			return null;
		else if (! this.isProgramDecl)
		{
			this.report.SemanticError(186, name, loc);
			return null;
		}
		else {
			InstanceSymbol symbol;
			TypeNode dataType = dataTypeSpec.DataType;
			STDeclQualifier declQual = dataTypeSpec.DeclQualifier;
			Expression initialValue = dataTypeSpec.InitialValue;
			this.symbolTable.InstallDirectVariable(name, dataType, this.variableType, this.variableQualifier,
			                                       dataTypeSpec.DeclQualifier, directVar.Size, directVar.Location, 
												   directVar.Address, out symbol);
			Expression size = MakeIntConstant((long)dataType.Size);
			List<MemoryObject> variables = new List<MemoryObject>();
			variables.Add((MemoryObject)symbol.MakeSyntaxTreeNode());
			return new ElementaryVarDeclStatement(variables, dataType, declQual, size, initialValue);
		}
	}

	private Expression CheckInitialValue(Expression initialValue, LexLocation location)
	{	
		TypeNode declDataType = this.attributeStack.Top;

		if (initialValue == null)
			return declDataType.DefaultValue;
		else if (declDataType == TypeNode.Error)
			return Expression.Error;
		else if (initialValue.DataType == TypeNode.Error)
			return declDataType.DefaultValue;
		else if (initialValue is FunctionName)
		{
			this.report.SemanticError(148, initialValue.ToString(), location);
			return declDataType.DefaultValue;
		}
		else {
			TypeNode initValDataType = initialValue.DataType;

			if (initValDataType == TypeNode.Bool && initialValue.IsCompoundExpression)
				initialValue = new LoadBoolValueOperator(initialValue);
			if (declDataType == initValDataType)
			{
				if (declDataType.IsOrdinalType && declDataType.IsSubrangeType)
				{
					if (initialValue.IsConstant)
					{
						if (declDataType.IsSignedIntType)
						{
							long numericValue = Convert.ToInt64(initialValue.Evaluate());
							if (! declDataType.IsInRange(numericValue))
							{
								string strValue = initialValue.ToString();
								string typeName = declDataType.Name;
								this.report.SemanticError(171, strValue, typeName, location);
							}
						}
						else {
							ulong numericValue = Convert.ToUInt64(initialValue.Evaluate());
							if (! declDataType.IsInRange(numericValue))
							{
								string strValue = initialValue.ToString();
								string typeName = declDataType.Name;
								this.report.SemanticError(171, strValue, typeName, location);
							}
						}
					}
					else if (initValDataType.IsSubrangeType)
					{
						SubRange initSubrange = initValDataType.GetSubrange();
						SubRange declSubrange = declDataType.GetSubrange();
						if (declSubrange.AreDisjoint(initSubrange))
							this.report.SemanticError(11, declDataType.Name, initValDataType.Name, location);
					}
				}
				return initialValue;
			}
			else if (declDataType == TypeNode.LReal && initValDataType.IsIntegerType)
			{
				if (! initialValue.IsConstant)
					return new Int2LRealOperator(initialValue);
				else {
					double doubleValue = Convert.ToDouble(initialValue.Evaluate());
					return MakeConstant(doubleValue);
				}
			}
			else if (declDataType == TypeNode.LReal && initValDataType == TypeNode.Real)
			{
				if (! initialValue.IsConstant)
					return new Real2LRealOperator(initialValue);
				else {
					double doubleValue = Convert.ToDouble(initialValue.Evaluate());
					return MakeConstant(doubleValue);
				}
			}
			else if (declDataType == TypeNode.Real && initValDataType == TypeNode.LReal)
			{
				if (! initialValue.IsConstant)
					this.report.SemanticError(27, declDataType.Name, initValDataType.Name, location);
				else {
					float floatValue = Convert.ToSingle(initialValue.Evaluate());
					return MakeConstant(floatValue);
				}
			}
			else if (declDataType == TypeNode.Real && initValDataType.IsIntegerType)
			{
				if (! initialValue.IsConstant)
					return new Int2RealOperator(initialValue);
				else {
					float singleValue = Convert.ToSingle(initialValue.Evaluate());
					return MakeConstant(singleValue);
				}
			}
			else if (declDataType.IsIntegerType && initValDataType.IsIntegerType)
			{
				if (declDataType.IsUnsignedIntType && initValDataType.IsSignedIntType
				 || declDataType.IsSignedIntType && initValDataType.IsUnsignedIntType
				 || declDataType.Size < initValDataType.Size)
				{
					this.report.SemanticError(64, initValDataType.Name, declDataType.Name, location);
					initialValue = declDataType.DefaultValue;
				}
			}
			else if (declDataType.IsBitStringType && initValDataType.IsIntegerType)
			{
				if (! initialValue.IsConstant)
					this.report.SemanticError(64, initValDataType.Name, declDataType.Name, location);
				else {
					ulong value = Convert.ToUInt64(initialValue.Evaluate());
					if (declDataType.Size < initValDataType.Size)
						this.report.SemanticError(64, initValDataType.Name, declDataType.Name, location);
					return this.MakeConstant(value, declDataType);
				}
			}
			else if (declDataType.IsBitStringType && initValDataType.IsBitStringType)
			{
				if (declDataType.Size < initValDataType.Size)
					this.report.SemanticError(64, initValDataType.Name, declDataType.Name, location);
			}
			else if (declDataType.IsStringType && initValDataType.IsStringType)
			{
				if (declDataType.Size < initValDataType.Size)
					this.report.SemanticError(35, initialValue.ToString(), location);
			}
			else
				this.report.SemanticError(27, declDataType.Name, initValDataType.Name, location);
			return initialValue;
		}
	}

	private List<object> MakeExpressionList(Expression expression, LexLocation location)
	{
		if (expression == null)
			return new List<object>{Expression.Error};
		else if (expression is FunctionName)
		{
			this.report.SemanticError(148, expression.ToString(), location);
			return new List<object>{Expression.Error};
		}
		else
			return new List<object>{expression};
	}

	private List<object> MakeExpressionList(List<object> exprList, Expression expression, LexLocation location)
	{
		if (expression == null)
			exprList.Add(Expression.Error);
		else if (expression is FunctionName)
		{
			this.report.SemanticError(148, expression.ToString(), location);
			exprList.Add(Expression.Error);
		}
		else
			exprList.Add(expression);
		return exprList;
	}

	private Expression MakeSymbolicVariable(Expression expression)
	{
		if (expression == null || expression == Expression.Error)
			return Expression.Error;
		else if (! expression.IsLValue)
			return expression;
		else if (expression.DataType.IsArrayType)
		{
			ArrayType array = (ArrayType)expression.DataType;
			TypeNode elementType = array.BasicElementType;

			if (elementType.IsElementaryType || elementType.IsAnyStringType)
			{
                Expression absoluteAddress;
				Expression size = MakeIntConstant(array.Size);
                MemoryObject lValue = (MemoryObject)expression;
				absoluteAddress = this.rwMemoryManager.GetAbsoluteAddress(lValue.Symbol);
				if (lValue.Offset != null)
				{
					Expression factor = MakeIntConstant(elementType.Size);
					Expression offset = this.MakeIntMulOp(lValue.Offset, factor);
                    absoluteAddress = this.MakeIntAddOp(offset, absoluteAddress);
				}
				lValue.Location.AbsoluteAddress = absoluteAddress;
				lValue.Location.Size = size;
			}
		}
		return expression;
	}

	private Expression MakeSimpleVariable(string identifier, LexLocation location)
	{
		STLangSymbol symbol;
		if (this.isSubrangeDecl)
		{
			if (! this.symbolTable.Lookup(identifier, this.subrangeDataType, out symbol, location))
			{
				this.report.SemanticError(0, identifier, location);
				this.symbolTable.InstallUndeclaredVariable(identifier, out symbol);
			}
		}
		else if (! this.symbolTable.Lookup(identifier, out symbol, location))
		{
			this.report.SemanticError(0, identifier, location);
			this.symbolTable.InstallUndeclaredVariable(identifier, out symbol);
		}
		return symbol.MakeSyntaxTreeNode(location);
	}

	private Expression MakeSimpleVariable(Expression expression, string memberName, LexLocation location)
	{
		if (expression == null)
			return Expression.Error;
		else if (expression == Expression.Error)
			return Expression.Error;
		else if (! expression.IsLValue)
		{
			this.report.SemanticError(3, expression.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode dataType = expression.DataType;
			if (dataType.IsStructType)
			{
				MemoryObject memoryObject = (MemoryObject)expression;
				InstanceSymbol symbol = memoryObject.Symbol;
				if (symbol.IsArrayInstance)
                {
					ArrayInstanceSymbol arrayInstance;

					arrayInstance = (ArrayInstanceSymbol)symbol;
					symbol = arrayInstance.ElementSymbol;
					if (! symbol.IsStructInstance)
					{
						string msg = "MakeSimpleVariable() failed.";
						msg += " StructInstanceSymbol expected: " + symbol.Name;
						throw new STLangCompilerError(msg);
					}
                }
				InstanceSymbol member;
				StructInstanceSymbol structure = (StructInstanceSymbol)symbol;
				if (! structure.LookUp(memberName, out member))
				{
					this.report.SemanticError(4, memberName, dataType.Name, location);
					return Expression.Error;
				}
				else
				{
					int length = memoryObject.Length + 2;
					Expression offset = memoryObject.Offset;
					string stringValue = expression + "." + memberName;
					return new MemoryObject(member, offset, stringValue, length);
				}
			}
			else if (dataType == TypeNode.Error)
				return Expression.Error;
			else if (dataType.IsFunctionBlockType)
			{
				MemoryObject memoryObject = (MemoryObject)expression;
				InstanceSymbol symbol = memoryObject.Symbol;
				if (! symbol.IsFunctionBlockInstance)
				{
					string msg = "MakeSimpleVariable() failed.";
					msg += " FunctionBlockInstanceSymbol expected: " + symbol.Name;
					throw new STLangCompilerError(msg);
				}
				else
				{
					InstanceSymbol member;
					FunctionBlockInstanceSymbol functionBlock;

					functionBlock = (FunctionBlockInstanceSymbol)symbol;
					if (! functionBlock.LookUp(memberName, out member))
					{
						this.report.SemanticError(136, memberName, dataType.Name, location);
						return Expression.Error;
					}
					else if (member.IsLocalVariable)
					{
						string varType = member.VariableType.ToString();
						this.report.SemanticError(137, varType, memberName, dataType.Name, location);
						return Expression.Error;
					}
					else {
						int length = memoryObject.Length + 2;
						Expression offset = memoryObject.Offset;
						string stringValue = expression + "." + memberName;
						return new MemoryObject(member, offset, stringValue, length);
					}
				}
			}
		}
		this.report.SemanticError(3, expression.ToString(), location);
        return Expression.Error;
	}

	private void CheckArrayIndex(Expression index, ArrayType array, string varName, LexLocation location)
	{
		long indexValue = Convert.ToInt64(index.Evaluate());
		if (indexValue < array.LowerBound)
			this.report.SemanticError(123, indexValue, varName, array.LowerBound, location);
		else if (indexValue > array.UpperBound)
			this.report.SemanticError(124, indexValue, varName, array.UpperBound, location);
	}

	private Expression MakeIndexedVariable(IndexedVariable variable)
	{
		if (variable == null)
			return Expression.Error;
		else {
			string name = variable.Name + "]";
			int length = variable.Length + 1; 
			MemoryLocation location = variable.Offset;
			InstanceSymbol symbol = variable.Symbol;
			int constantPart = variable.ConstantPart;
			Expression variablePart = variable.VariablePart;
			TypeNode dataType = variable.DataType;
			this.isIndexExpr = false;
			if (variablePart == null)
				throw new STLangCompilerError("MakeIndexedVariable() failed: Offset is null.");
			else if (dataType.IsElementaryType || dataType.IsAnyStringType)
			{
				if (variablePart.IsConstant)
				{
					int varPart = Convert.ToInt32(variablePart.Evaluate());
					int offset = varPart - constantPart;
					if (! symbol.IsConstant)
					{
						int index = location.Index + offset;
						location = new ElementaryLocation(index, dataType);
						return new MemoryObject(name, location, dataType, symbol, length);
					}
					else if (symbol.InitialValue is ArrayInitializer)
					{
						// Constant array with constant array index. Get array element
						// at position 'offset' in the array initializer.
						//
						ArrayInitializer arrayInit;
						arrayInit = (ArrayInitializer)symbol.InitialValue;
						Expression rValue = arrayInit.GetElementAt(offset);
						return new MemoryObject(rValue, name, symbol, length);
					}
					else if (symbol.InitialValue is ArrayOfStructInitializer)
					{
						ArrayOfStructInitializer arrayInit;
						arrayInit = (ArrayOfStructInitializer)symbol.InitialValue;
						Expression rValue = arrayInit.GetElementAt(offset);
						return new MemoryObject(rValue, name, symbol, length);
					}
					throw new STLangCompilerError("ArrayInitializer type expected.");
				}
				else if (constantPart == 0)
					return new MemoryObject(name, location, variablePart, dataType, symbol, length);
				else 
				{
				    if (variablePart is IntAddOperator)
					{
						Expression rightOperand;
						rightOperand = ((IntAddOperator)variablePart).RightOperand;
						if (rightOperand.IsConstant)
							constantPart = Convert.ToInt32(rightOperand.Evaluate()) - constantPart;
					}
					Expression constant = MakeIntConstant(constantPart);
					Expression offset = new IntSubOperator(variablePart, constant, TypeNode.DInt);
					return new MemoryObject(name, location, offset, dataType, symbol, length);
				}
			}
			else if (dataType.IsArrayType)
			{
				ArrayType array = (ArrayType)dataType;
				long elementWidth = (long)array.Size/array.BasicElementType.Size;
				Expression elemWidth = MakeIntConstant(elementWidth);
				Expression offset = this.MakeIntMulOp(variablePart, elemWidth);
				if (constantPart != 0)
				{
					long value = constantPart*elementWidth;
					Expression constant = MakeIntConstant(value);
					offset = this.MakeIntSubOp(offset, constant);
				}
				Expression size = MakeIntConstant((long)array.Size);
				if (!offset.IsConstant)
					return new MemoryObject(name, location, offset, dataType, symbol, length);
				else
				{
					int value = Convert.ToInt32(offset.Evaluate());
					location = location.AddOffset(value);
					return new MemoryObject(name, location, dataType, symbol, length);
				}
			}
			else if (dataType.IsStructType)
			{
			}
			return Expression.Error;
		}
	}

	private IndexedVariable MakeIndexedVariable(IndexedVariable variable, Expression index, LexLocation loc1, LexLocation loc2)
	{
		if (variable == null)
			return null;
		else if (index == null)
			return variable;
		else if (! index.DataType.IsIntegerType && index.DataType != TypeNode.Error)
			this.report.SemanticError(30, index.ToString(), loc2);
		if (! variable.DataType.IsArrayType)
		{
			string parameter = variable.Name + "," + index + "]";
			this.report.SemanticError(167, parameter, loc1);
			return variable;
		}
		else {
			Expression variablePart;
			InstanceSymbol symbol = variable.Symbol;
			MemoryLocation offset = variable.Offset;
			int constantPart = variable.ConstantPart;
			string name = variable.Name + "," + index;
			int length = variable.Length + index.Length;
			ArrayType array = (ArrayType)variable.DataType;
			if (index.IsConstant)
				this.CheckArrayIndex(index, array, variable.Symbol.Name, loc2);
			else if (! index.IsLinear()  || !index.ConstantForLoopBounds(this.forLoopDataList))
				index = this.MakeRangeCheckOperator(index, array);
			else {
				int lowerBound = array.LowerBound;
				int upperBound = array.UpperBound;
				int powerSetSize = 1 << this.forLoopDataList.Count;
				for (int word = 0; word < powerSetSize; word++)
				{
					int indexValue = index.Evaluate(word, this.forLoopDataList);
					if (indexValue < lowerBound || indexValue > upperBound)
					{
						index = this.MakeRangeCheckOperator(index, array);
						break;
					}
				}
			}
			Expression factor = MakeIntConstant(array.Range);
			variablePart = this.MakeIntMulOp(variable.VariablePart, factor);
			variablePart = this.MakeIntAddOp(variablePart, index);
			constantPart = array.Range*constantPart + array.LowerBound;
			TypeNode elemType = array.ElementType;
			return new IndexedVariable(offset, elemType, variablePart, constantPart, symbol, name, length);
		}
	}

	private Expression MakeRangeCheckOperator(Expression index, ArrayType array)
	{
		Expression lowerBound = MakeIntConstant(array.LowerBound);
		Expression upperBound = MakeIntConstant(array.UpperBound);
		return new RangeCheckOperator(index, lowerBound, upperBound);
	}

	private IndexedVariable MakeIndexedVariable(Expression expression, Expression index, LexLocation loc1, LexLocation loc2)
	{
		if (expression == null || index == null)
			return null;
		else if (! index.DataType.IsIntegerType && index.DataType != TypeNode.Error)
			this.report.SemanticError(30, index.ToString(), loc2);
		if (expression.DataType == TypeNode.Error)
			return null;
		if (! expression.IsLValue)
		{
			this.report.SemanticError(2, expression.ToString(), loc1);
			return null;
		}
		else if (! expression.DataType.IsArrayType)
		{
			this.report.SemanticError(2, expression.ToString(), loc1);
			return null;
		}
		else {
			MemoryObject lValue = (MemoryObject)expression;
			MemoryLocation location = lValue.Location;
			InstanceSymbol symbol = lValue.Symbol;
			Expression offset = lValue.Offset;
			ArrayType array = (ArrayType)expression.DataType;
			TypeNode elemType = array.ElementType;
			int constPart = array.LowerBound;
			int length = index.Length + 2;
			string name = lValue + "[" + index;
			if (index.IsConstant)
				this.CheckArrayIndex(index, array, symbol.Name, loc2);
			else if (! index.IsLinear() || !index.ConstantForLoopBounds(this.forLoopDataList))
				index = this.MakeRangeCheckOperator(index, array);
			else {
				int lowerBound = array.LowerBound;
				int upperBound = array.UpperBound;
				int powerSetSize = 1 << this.forLoopDataList.Count;
				for (int word = 0; word < powerSetSize; word++)
				{
					int indexValue = index.Evaluate(word, this.forLoopDataList);
					if (indexValue < lowerBound || indexValue > upperBound)
					{
						index = this.MakeRangeCheckOperator(index, array);
						break;
					}
				}
			}
			if (offset == null)
				return new IndexedVariable(location, elemType, index, constPart, symbol, name, length);
			else if (offset is IntSubOperator)
			{
				BinaryOperator binaryOp = (BinaryOperator)offset;
				Expression variablePart = binaryOp.LeftOperand;
				Expression factor = MakeIntConstant(array.Range);
				object constantValue = binaryOp.RightOperand.Evaluate();
				int constantPart = Convert.ToInt32(constantValue);
				variablePart = this.MakeIntMulOp(variablePart, factor);
				variablePart = this.MakeIntAddOp(variablePart, index);
				constantPart = array.Range*constantPart + array.LowerBound;
				return new IndexedVariable(location, elemType, variablePart, constantPart, symbol, name, length);
			}
			return null;
		}
	}

	private Expression MakeDirectVariable(TokenDirectVar directVar, LexLocation location)
	{
		STLangSymbol symbol;
		string name = directVar.ToString();
		if (! this.symbolTable.Lookup(name, out symbol, location))
		{
			this.report.SemanticError(129, name, location);
			this.symbolTable.InstallUndeclaredDirectVariable(directVar, out symbol);
		}
		return symbol.MakeSyntaxTreeNode(location);
	}

	private List<CaseLabel> MakeCaseLabelList(CaseLabel caseLabel, LexLocation location)
	{
		List<CaseLabel> caseLabelList = new List<CaseLabel>();
		return this.AddCaseLabelToList(caseLabelList, caseLabel, location);
	}

	private CaseElement MakeCaseElement(List<CaseLabel> constList, StatementList statList)
	{
		this.PopTop();
		CaseElement caseElem = new CaseElement();
		if (constList == null)
			constList = new List<CaseLabel>();
		caseElem.LabelList = constList;
		caseElem.StatementList = statList;
		return caseElem;
	}

	private CaseElement MakeDefaultCaseElement(StatementList statList)
	{
		this.PopTop();
		CaseElement defaultCaseElem = new CaseElement();
		defaultCaseElem.StatementList = statList;
		defaultCaseElem.LabelList = null; // Empty list
		return defaultCaseElem;
	}

	private List<CaseElement> MakeCaseElementList(object caseElement)
	{
		List<CaseElement> caseElemList = new List<CaseElement>();
		if (caseElement != null)
			caseElemList.Add((CaseElement)caseElement);
		return caseElemList;
	}

	private List<CaseElement> AddCaseElementToList(List<CaseElement> caseElemList, object caseElem, LexLocation location)
	{
		if (caseElemList == null || caseElem == null)
			return caseElemList;
		else if (! (caseElem is CaseElement))
			throw new STLangCompilerError("Type of parameter caseElem must be CaseElement");
		else {
			CaseElement caseElement = (CaseElement)caseElem;
			if (caseElement.LabelList != null)
				caseElemList.Add(caseElement);
			else {
				// caseElement is a default statment. Make sure that there isn't another 
				// default statement in the list.

				CaseElement defaultStat;
				defaultStat = caseElemList.Find(caseEl => caseEl.LabelList == null);
				if (defaultStat == null)
					caseElemList.Add(caseElement);
				else
					this.report.SemanticError(146, location);
			}
			return caseElemList;
		}
	}

	private List<CaseLabel> AddCaseLabelToList(List<CaseLabel> caseLabelList, CaseLabel caseLabel, LexLocation loc)
	{
		if (caseLabel == null)
			return caseLabelList;
		else if (caseLabel is NumericLabel)
		{
			NumericLabel numericLabel = (NumericLabel)caseLabel;
			foreach (CaseLabel thisCaseLabel in this.caseLabelList)
			{
				if (! thisCaseLabel.AreDisjoint(numericLabel))
				{
					int errorCode = thisCaseLabel is NumericLabel ? 33 : 53;
					this.report.SemanticError(errorCode, numericLabel.ToString(), thisCaseLabel.ToString(), loc);
					return caseLabelList;
				}
			}
			caseLabelList.Add(caseLabel);
			this.caseLabelList.Add(caseLabel);
			return caseLabelList;
		}
		else 
		{
			SubrangeLabel subRangeLabel = (SubrangeLabel)caseLabel;
			foreach (CaseLabel thisCaseLabel in this.caseLabelList)
			{
				if (! thisCaseLabel.AreDisjoint(subRangeLabel))
				{
					int errorCode = thisCaseLabel is NumericLabel ? 53 : 52;
					this.report.SemanticError(errorCode, thisCaseLabel.ToString(), subRangeLabel.ToString(), loc);
					return caseLabelList;
				}
			}
			caseLabelList.Add(caseLabel);
			this.caseLabelList.Add(caseLabel);
			return caseLabelList;
		}
	}

	private Expression CheckIfBoolCondition(string statement, Expression expression, LexLocation location)
	{
		if (expression == null)
			return Expression.Error;
		else if (expression.DataType == TypeNode.Error)
			return Expression.Error;
		else if (expression is FunctionName)
		{
			this.report.SemanticError(148, expression.ToString(), location);
			return Expression.Error;
		}
		else if (expression.DataType == TypeNode.Bool)
			return expression;
		else {
			this.report.SemanticError(34, statement, location);
			return Expression.Error;
		}
	}

	private Statement MakeWhileStatement(Expression expression, StatementList statementList, LexLocation location)
	{
		this.PopTop();
		this.loopNestingDepth--;
		if (expression == null || statementList == null)
			return Statement.Empty;
		else {
			if (expression.IsConstant)
			{
				bool conditonIsTrue = Convert.ToBoolean(expression.Evaluate());
				if (conditonIsTrue && !statementList.ContainsExit)
					this.report.SemanticError(92, location);
			}
			return new WhileStatement(expression.InvertRelation(), statementList);
		}
	}

	private Statement MakeRepeatStatement(StatementList statementList = null, Expression expression = null, LexLocation location = null)
	{
		this.PopTop();
		this.loopNestingDepth--;
		if (statementList == null || expression == null)
			return Statement.Empty;
		else {
			if (expression.IsConstant)
			{
				bool conditonIsFalse = !Convert.ToBoolean(expression.Evaluate());
				if (conditonIsFalse && !statementList.ContainsExit)
					this.report.SemanticError(93, location);
			}
			return new RepeatStatement(statementList, expression.InvertRelation());
		}
	}

	private List<object> MakeElseIfStatement(Expression expression, StatementList statementList)
	{
		this.PopTop();
		ElseIfStatement elseIfStat;
		elseIfStat = new ElseIfStatement(expression.InvertRelation(), statementList);
		return new List<object>{ elseIfStat };
	}

	private Statement MakeIfStatement(Expression condition, StatementList thenStat, List<object> objList, StatementList elseStat)
	{
		if (objList == null)
			return new IfStatement(condition.InvertRelation(), thenStat, elseStat);
		else {
			List<ElseIfStatement> elseIfStatList;
			elseIfStatList = objList.Cast<ElseIfStatement>().ToList();
			return new IfStatement(condition.InvertRelation(), thenStat, elseStat, elseIfStatList);
		}
	}

	private List<object> AddElseIfStatementToList(List<object> elseIfList, Expression expr, StatementList statList)
	{
		if (statList == null)
			return elseIfList;
		else {
			ElseIfStatement elseIfStat;
			elseIfStat = new ElseIfStatement(expr.InvertRelation(), statList);
			elseIfList.Add(elseIfStat);
			return elseIfList;
		}
	}

	private void InstallFunctionProtoType(string name, TypeNode resultDataType, POUVarDeclarations varDecls, LexLocation loc)
	{
		this.symbolTable.InstallFunctionProtoType(name, resultDataType, varDecls, loc);
	}

	private void InstallFunctionBlockProtoType(string name, POUVarDeclarations pouVarDecls, LexLocation loc)
	{
		uint byteCount;
		FunctionBlockType dataType;
		List<InstanceSymbol> members;
		List<InstanceSymbol> instanceSymbols;

		string typeID = "{" + name + "}";
        instanceSymbols = pouVarDecls.InputParameters.ToList();
        members = instanceSymbols.Cast<InstanceSymbol>().ToList();
		byteCount = (uint)this.rwMemoryManager.RWDataSegmentSize;
        Expression size = MakeIntConstant((long)byteCount);
		pouVarDecls.Size = size;
		dataType = new FunctionBlockType(name, members, byteCount, size, typeID);
		this.symbolTable.InstallFunctionBlockProtoType(name, dataType, pouVarDecls, loc);
	}

	private ExitStatement MakeExitStatement(LexLocation location)
	{
		if (this.loopNestingDepth == 0)
			this.report.SemanticError(21, location);
		return new ExitStatement();
	}

	private ReturnStatement MakeReturnStatement(LexLocation location)
	{
		if (this.isFunctionDecl)
			this.CheckFunctionValueIsDefined(location);
		return new ReturnStatement();
	}

	private ReturnStatement MakeReturnStatement2(LexLocation location)
	{
		this.report.SyntaxError(47, location);
		return new ReturnStatement();
	}

	private void PushForLoopData(Expression expression, ForLoopData forLoopData)
	{
		if (expression != null && forLoopData != null)
		{
			Predicate<ForLoopData> searchCond;
			MemoryObject memoryObj = (MemoryObject)expression;
			searchCond = forLoop => forLoop.ControlVariable.Symbol == memoryObj.Symbol;
			if (this.forLoopDataList.Find(searchCond) == null)
			{
				memoryObj.Symbol.IsForLoopCtrlVar = true;
				forLoopData.ControlVariable = memoryObj;
				this.forLoopDataList.Add(forLoopData);
			}
		}
	}

	private MemoryObject GenerateTemporary(Expression expr)
    {
        return this.rwMemoryManager.GenerateTemporary(expr);
    }

    private MemoryObject GenerateTemporary(TypeNode dataType)
    {
        return this.rwMemoryManager.GenerateTemporary(dataType);
    }

	private Statement MakeForLoopStatement(Expression controlVar, ForLoopData forLoop, StatementList statList)
	{
		this.PopTop();
		this.loopNestingDepth--;
		this.PopForLoopVariables();
		if (controlVar == null || forLoop == null)
			return Statement.Empty;
		else {
			Expression initValue = forLoop.InitialValue;
			Expression stopValue = forLoop.StopValue;
			Expression increment = forLoop.Increment;

			if (initValue == null || stopValue == null || increment == null)
				return Statement.Empty;
			else {
				Expression condition;
				bool executeLoopOnce = false;

				if (increment.IsConstant)
				{
					if (stopValue.IsCompoundExpression)
					{
						MemoryObject temporary = this.GenerateTemporary(controlVar);
						int incr = Convert.ToInt32(increment.Evaluate());
						if (incr > 0)
							condition = new IntLeqOperator(controlVar, temporary);
						else 
							condition = new IntGeqOperator(controlVar, temporary);
						return new ForStatement((MemoryObject)controlVar, initValue, stopValue, temporary, condition, increment, statList);
					}
					else {
						int incrValue = Convert.ToInt32(increment.Evaluate());
						if (incrValue > 0)
							condition = new IntLeqOperator(controlVar, stopValue);
						else 
							condition = new IntGeqOperator(controlVar, stopValue);
						if (initValue.IsConstant && stopValue.IsConstant)
						{
							int initVal = Convert.ToInt32(initValue.Evaluate());
							int stopVal = Convert.ToInt32(stopValue.Evaluate());
							if (incrValue > 0)
								executeLoopOnce = initVal <= stopVal;
							else 
								executeLoopOnce = initVal >= stopVal;
						}
					}
				}
				else if (initValue.IsConstant && stopValue.IsConstant)
				{
					int initVal = Convert.ToInt32(initValue.Evaluate());
					int stopVal = Convert.ToInt32(stopValue.Evaluate());
					if (initVal <= stopVal)
					{
						condition = new IntLeqOperator(controlVar, stopValue);
						executeLoopOnce = initVal <= stopVal;
					}
					else {
						condition = new IntGeqOperator(controlVar, stopValue);
						executeLoopOnce = initVal >= stopVal;
					}
				}
				else if (! stopValue.IsCompoundExpression)
					condition = new IntLeqOperator(controlVar, stopValue);
				else {
					MemoryObject temporary;
					temporary = this.GenerateTemporary(controlVar);
					condition = new IntLeqOperator(controlVar, temporary);
					return new ForStatement((MemoryObject)controlVar, initValue, stopValue, temporary, condition, increment, statList);
				} 
				return new ForStatement((MemoryObject)controlVar, initValue, condition, increment, statList, executeLoopOnce);
			}
		}
	}

	private Statement MakeCaseStatement(Expression controlExpr, List<CaseElement> caseElemList, LexLocation location)
	{
		this.PopCaseLabelList();
		if (caseElemList.Count == 0)
		{
			this.report.Warning(26, location);
			return Statement.Empty;
		}
		else {
			CaseElement defaultStatement;
			
			defaultStatement = caseElemList.Find(caseElem => caseElem.LabelList == null);
			if (defaultStatement == null)
				return new CaseStatement(controlExpr, caseElemList);
			else {
				caseElemList.Remove(defaultStatement);
				if (caseElemList.Count == 0)
					this.report.Warning(27, location);
				return new CaseStatement(controlExpr, caseElemList, defaultStatement);
			}
		}
	}

	private ForLoopData MakeForLoopData(Expression initialValue, Expression stopValue, Expression increment, LexLocation loc1 = null, LexLocation loc2 = null, LexLocation loc3 = null)
	{
		ForLoopData forLoopData = new ForLoopData();
		if (initialValue == null)
			initialValue = MakeIntConstant((long)0);
		else if (initialValue is FunctionName)
		{
			this.report.SemanticError(148, initialValue.ToString(), loc1);
			initialValue = MakeIntConstant((long)0);
		}
		if (stopValue == null)
			stopValue = Expression.Error;
		else if (stopValue is FunctionName)
		{
			this.report.SemanticError(148, stopValue.ToString(), loc2);
			stopValue = Expression.Error;
		}
		if (increment == null)
			increment = MakeIntConstant((long)1);
		else if (increment is FunctionName)
		{
			this.report.SemanticError(148, increment.ToString(), loc3);
			increment = MakeIntConstant((long)1);
		}
		forLoopData.InitialValue = initialValue;
		forLoopData.StopValue = stopValue;
		forLoopData.Increment = increment;
		this.forLoopVarKind = 0x0;
		this.loopNestingDepth++;
		return forLoopData;
	}

	private Expression SaveControlVariable(Expression expr, LexLocation location)
	{
		if (expr == null)
			return Expression.Error;
		else if (expr is FunctionName)
		{
			this.report.SemanticError(148, expr.ToString(), location);
			return Expression.Error;
		}
		else if (! expr.IsLValue)
		{
			// Error: expr is not an L-Value
			this.report.SemanticError(54, expr.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode dataType = expr.DataType;
			MemoryObject variable = (MemoryObject)expr;
			InstanceSymbol varSymbol = variable.Symbol;
			if (variable.IsConstant)
				this.report.SemanticError(8, expr.ToString(), location);
			if ((dataType.IsSignedIntType || dataType == TypeNode.Error) && variable.IsSimpleVariable)
				this.RegisterForLoopVariable(varSymbol, ForLoopVariableType.CONTROL_VARIABLE, location);
			else {
				if (! variable.IsSimpleVariable)
					this.report.SemanticError(49, varSymbol.Name, location); // Control variable can't be an element of an array or struct
				if (! dataType.IsSignedIntType && dataType != TypeNode.Error)
					this.report.SemanticError(132, varSymbol.Name, location); // Control variable must be of a signed integer type
			}
			return expr;
		}
	}

	private void CheckIfForLoopVar(Expression expr, LexLocation location)
	{
		if (expr == null)
			return;
		else if (expr is MemoryObject && this.forLoopVarKind != 0)
		{
			ForLoopVariableType loopVarKind;
			MemoryObject memObject = (MemoryObject)expr;

			if (this.forLoopVarKind == 0x1)
				loopVarKind = ForLoopVariableType.CONTROL_VARIABLE;
			else if (this.forLoopVarKind == 0x2)
				loopVarKind = ForLoopVariableType.START_VARIABLE;
			else if (this.forLoopVarKind == 0x4)
				loopVarKind = ForLoopVariableType.STOP_VARIABLE;
			else if (this.forLoopVarKind == 0x8)
				loopVarKind = ForLoopVariableType.INCR_VARIABLE;
			else
				loopVarKind = ForLoopVariableType.NONE;
			this.RegisterForLoopVariable(memObject.Symbol, loopVarKind, location);
		}
	}

	private bool ConversionOperatorExists(TypeNode fromType, TypeNode toType)
	{
		if (fromType == TypeNode.Error || toType == TypeNode.Error)
			return false;
		else if (!fromType.IsElementaryType || !toType.IsElementaryType)
			return false;
		else if (fromType.IsSubrangeType || toType.IsSubrangeType)
			return true;
		else {
			STLangSymbol symbol;
			string conversionOp;

			conversionOp = string.Format("{0}_TO_{1}", fromType.Name, toType.Name);
			return this.symbolTable.Lookup(conversionOp, out symbol, null);
		}
	}

	private Statement MakeAssignmentStatement(STLangSymbol lSymbol, STLangSymbol rSymbol, Expression lIndex = null, Expression rIndex = null)
	{
		TypeNode dataType = lSymbol.DataType;
		if (dataType.IsStructType)
		{
			if (! lSymbol.IsStructInstance || ! rSymbol.IsStructInstance)
				throw new STLangCompilerError(Resources.MAKEASSGNSTAT1);
			else {
				Statement assignmentStat;
				CompoundAssignmentStat compoundAssignStat;		
				StructInstanceSymbol lStruct = (StructInstanceSymbol)lSymbol;
				StructInstanceSymbol rStruct = (StructInstanceSymbol)rSymbol;
				InstanceSymbol lMember = lStruct.FirstMember;
				InstanceSymbol rMember = rStruct.FirstMember;

				compoundAssignStat = new CompoundAssignmentStat();
				while (lMember != null && rMember != null)
				{
					assignmentStat = this.MakeAssignmentStatement(lMember, rMember, lIndex, rIndex);
					compoundAssignStat.Add(assignmentStat);
					lMember = lMember.Next;
					rMember = rMember.Next;
				}
				return compoundAssignStat;
			}
		}
		else if (dataType.IsArrayType)
		{
			if (! lSymbol.IsArrayInstance || ! rSymbol.IsArrayInstance)
				throw new STLangCompilerError(Resources.MAKEASSGNSTAT2);
			else {
				ArrayType array = (ArrayType)dataType;
				TypeNode elementType = array.BasicElementType;

				if (elementType.IsStructType || elementType.IsArrayType)
				{
					ArrayInstanceSymbol lArray = (ArrayInstanceSymbol)lSymbol;
					ArrayInstanceSymbol rArray = (ArrayInstanceSymbol)rSymbol;
					STLangSymbol lElement = lArray.ElementSymbol;
					STLangSymbol rElement = rArray.ElementSymbol;
					return this.MakeAssignmentStatement(lElement, rElement, lIndex, rIndex);
				}
				else {
					long sizeOfDataType = dataType.Size;
					Expression size = MakeIntConstant(sizeOfDataType);
					this.rwMemoryManager.SetAbsoluteAddress(lSymbol);
					this.rwMemoryManager.SetAbsoluteAddress(rSymbol);
					Expression lValue = lSymbol.MakeSyntaxTreeNode();
					Expression rValue = rSymbol.MakeSyntaxTreeNode();
					((MemoryObject)lValue).Location.Size = size;
					((MemoryObject)rValue).Location.Size = size;
					return new SimpleAssignmentStat(lValue, rValue);
				}
			}
		}
		else if (dataType.IsElementaryType || dataType.IsAnyStringType)
		{
	        // Obs! Om man allokerar mer minne fr att spara undan vrdet av ett 
		    // deluttryck efter ett anrop av SetAbsoluteAddress() kan absolutad- 
            // ressen bli fel. Man borde egentligen spara undan lSymbol och rSymbol
            // i en lista fr att senare fylla i absolutadressen.

			int elementCount = lSymbol.Location.ElementCount;
			Expression lValue = lSymbol.MakeSyntaxTreeNode();
			Expression rValue = rSymbol.MakeSyntaxTreeNode();
			if (elementCount > 1)
			{ 
				// Array assignment

				long sizeOfDataType = lSymbol.DataType.Size * elementCount;
				Expression size = MakeIntConstant(sizeOfDataType);
				this.rwMemoryManager.SetAbsoluteAddress(lSymbol);
				this.rwMemoryManager.SetAbsoluteAddress(rSymbol);
				((MemoryObject)lValue).Location.Size = size;
				((MemoryObject)rValue).Location.Size = size;
			}
			return new SimpleAssignmentStat(lValue, rValue);
		}
		return Statement.Empty;
	}

	private Statement MakeAssignmentStatement(Expression lExpression, Expression rValue, LexLocation location)
	{
		if (lExpression == null || rValue == null)
			return Statement.Empty;
		else if (lExpression == Expression.Error)
			return Statement.Empty;
		else if (rValue is FunctionName)
		{
			this.report.SemanticError(148, rValue.ToString(), location);
			return Statement.Empty;
		}
		else if (lExpression is FunctionName)
		{
			TypeNode rValueDataType = rValue.DataType;
			TypeNode resultType = lExpression.DataType;
			if (rValue.DataType == TypeNode.Bool && rValue.IsCompoundExpression)
				rValue = new LoadBoolValueOperator(rValue);
			if (! this.symbolTable.IsCurrentFunction(lExpression))
			{
				this.report.SemanticError(149, lExpression.ToString(), location);
				return Statement.Empty;
			}
			else if (resultType == TypeNode.Error || rValueDataType == TypeNode.Error)
				return new FunctionResultStatement(Expression.Error);
			else if (resultType == rValueDataType)
				return new FunctionResultStatement(rValue);
			else if (resultType.IsIntegerType && rValueDataType.IsIntegerType)
			{
				if (rValueDataType.Size <= resultType.Size)
					return new FunctionResultStatement(rValue);
			}
			else if (resultType.IsBitStringType)
			{
				if (rValueDataType.IsBitStringType)
				{
					if (rValueDataType.Size <= resultType.Size)
						return new FunctionResultStatement(rValue);
				}
				else if (rValueDataType.IsIntegerType)
				{
					if (rValue.IsConstant && rValueDataType.Size <= resultType.Size)
						return new FunctionResultStatement(rValue);
				}
			}
			else if (resultType == TypeNode.Real)
			{
				if (rValueDataType.IsIntegerType)
				{
					if (! rValue.IsConstant)
						rValue = this.MakeInt2Real(rValue); // Insert conversion operator
					else {
						// Convert constant value from integer to float
						float floatValue = Convert.ToSingle(rValue.Evaluate());
						rValue = MakeConstant(floatValue);
					}
					return new FunctionResultStatement(rValue);
				}
			}
			else if (resultType == TypeNode.LReal)
			{
				if (rValueDataType.IsIntegerType)
				{
					if (! rValue.IsConstant)
						rValue = new Int2LRealOperator(rValue); // Insert conversion operator
					else {
						// Convert constant value from integer to double
						double doubleValue = Convert.ToDouble(rValue.Evaluate());
						rValue = MakeConstant(doubleValue);
					}
					return new FunctionResultStatement(rValue);
				}
				else if (rValueDataType == TypeNode.Real)
				{
					if (! rValue.IsConstant)
						rValue = new Real2LRealOperator(rValue);
					else {
						double doubleValue = Convert.ToDouble(rValue.Evaluate());
						rValue = MakeConstant(doubleValue);
					}
					return new FunctionResultStatement(rValue);
				}
			}
			if (this.ConversionOperatorExists(rValueDataType, resultType))
				this.report.SemanticError(64, rValueDataType.Name, resultType.Name, location);
			else
				this.report.SemanticError(150, rValueDataType.Name, resultType.Name, location);
			return Statement.Empty;
		}
		else if (! lExpression.IsLValue)
		{
			this.report.SemanticError(54, lExpression.ToString(), location);
			return Statement.Empty;
		}
		else {
			TypeNode rValueDataType = rValue.DataType;
			TypeNode lValueDataType = lExpression.DataType;
			MemoryObject lmemObject = (MemoryObject)lExpression;
			InstanceSymbol symbol = lmemObject.Symbol;
			foreach (Hashtable forLoopVars in this.forLoopVarTable)
			{
				if (forLoopVars.Contains(symbol))
				{
					ForLoopVariableType forLoopVarType;
					forLoopVarType = (ForLoopVariableType)forLoopVars[symbol];
					if ((forLoopVarType & ForLoopVariableType.CONTROL_VARIABLE) != 0)
						this.report.SemanticError(125, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.START_VARIABLE) != 0)
						this.report.SemanticError(126, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.STOP_VARIABLE) != 0)
						this.report.SemanticError(127, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.INCR_VARIABLE) != 0)
						this.report.Warning(15, symbol.Name, location);
				}
			}
			if (rValue.DataType == TypeNode.Bool && rValue.IsCompoundExpression)
				rValue = new LoadBoolValueOperator(rValue);
			if (lExpression.IsConstant)
			{
				if (lmemObject.IsSimpleVariable)
					this.report.SemanticError(169, lExpression.ToString(), location);
				else
					this.report.SemanticError(170, lExpression.ToString(), location);
			}
			else if (lExpression.IsConstantLValue)
			{
				if (lmemObject.IsSimpleVariable)
					this.report.SemanticError(168, lExpression.ToString(), location);
				else
					this.report.SemanticError(170, lExpression.ToString(), location);
			}
			if (lValueDataType == rValueDataType)
			{
				if (rValueDataType.IsStructType)
				{
					MemoryObject rmemObject = (MemoryObject)rValue;
					STLangSymbol lSymbol = lmemObject.Symbol;
					STLangSymbol rSymbol = rmemObject.Symbol;
					return this.MakeAssignmentStatement(lSymbol, rSymbol);
				}
     			else if (rValueDataType.IsArrayType)
				{
					MemoryObject rmemObject = (MemoryObject)rValue;
					STLangSymbol lSymbol = lmemObject.Symbol;
					STLangSymbol rSymbol = rmemObject.Symbol;
					Expression lIndex = lmemObject.Offset;
					Expression rIndex = rmemObject.Offset;
					return this.MakeAssignmentStatement(lSymbol, rSymbol, lIndex, rIndex);
				}
				else if (lValueDataType.IsOrdinalType && lValueDataType.IsSubrangeType)
				{
					if (rValue.IsConstant)
					{
						if (lValueDataType.IsSignedIntType)
						{
							long numericValue = Convert.ToInt64(rValue.Evaluate());
							if (! lValueDataType.IsInRange(numericValue))
							{
								string strValue = rValue.ToString();
								string typeName = lValueDataType.Name;
								this.report.SemanticError(171, strValue, typeName, location);
							}
						}
						else {
							ulong numericValue = Convert.ToUInt64(rValue.Evaluate());
							if (! lValueDataType.IsInRange(numericValue))
							{
								string strValue = rValue.ToString();
								string typeName = lValueDataType.Name;
								this.report.SemanticError(171, strValue, typeName, location);
							}
						}
					}
					else if (rValueDataType.IsSubrangeType)
					{
						SubRange rValueSubrange = rValueDataType.GetSubrange();
						SubRange lValueSubrange = lValueDataType.GetSubrange();
						if (lValueSubrange.AreDisjoint(rValueSubrange))
						{
							string lValName = lValueDataType.Name;
							string rValName = rValueDataType.Name;
							this.report.SemanticError(11, lValName, rValName, location);
						}
					}
				}
				return new SimpleAssignmentStat(lExpression, rValue);
			}
			else if (lValueDataType == TypeNode.Error || rValueDataType == TypeNode.Error)
				return new SimpleAssignmentStat(lExpression, rValue);
			else if (lValueDataType.IsIntegerType && rValueDataType.IsIntegerType)
			{
				if (rValueDataType.Size <= lValueDataType.Size)
					return new SimpleAssignmentStat(lExpression, rValue);
			}
			else if (lValueDataType.IsBitStringType)
			{
				if (rValueDataType.IsBitStringType)
				{
					if (rValueDataType.Size <= lValueDataType.Size)
						return new SimpleAssignmentStat(lExpression, rValue);
				}
				else if (rValueDataType.IsIntegerType)
				{
					if (rValue.IsConstant && rValueDataType.Size <= lValueDataType.Size)
						return new SimpleAssignmentStat(lExpression, rValue);
				}
			}
			else if (lValueDataType == TypeNode.Real)
			{
				if (rValueDataType.IsIntegerType)
				{
					if (! rValue.IsConstant)
						rValue = this.MakeInt2Real(rValue); // Insert conversion operator
					else {
						// Convert constant value from integer to float
						float floatValue = Convert.ToSingle(rValue.Evaluate());
						rValue = MakeConstant(floatValue);
					}
					return new SimpleAssignmentStat(lExpression, rValue);
				}
			}
			else if (lValueDataType == TypeNode.LReal)
			{
				if (rValueDataType.IsIntegerType)
				{
					if (! rValue.IsConstant)
						rValue = new Int2LRealOperator(rValue); // Insert conversion operator
					else {
						// Convert constant value from integer to double
						double doubleValue = Convert.ToDouble(rValue.Evaluate());
						rValue = MakeConstant(doubleValue);
					}
					return new SimpleAssignmentStat(lExpression, rValue);
				}
				else if (rValueDataType == TypeNode.Real)
				{
					if (! rValue.IsConstant)
						rValue = new Real2LRealOperator(rValue);
					else {
						double doubleValue = Convert.ToDouble(rValue.Evaluate());
						rValue = MakeConstant(doubleValue);
					}
					return new SimpleAssignmentStat(lExpression, rValue);
				}
			}
			else if (lValueDataType.IsStringType && rValueDataType.IsStringType)
			{
				if (lValueDataType.Size >= rValueDataType.Size)
					return new SimpleAssignmentStat(lExpression, rValue);
				else {
					this.report.SemanticError(188, rValue.ToString(), lExpression.ToString(), location);
					return Statement.Empty;
				}
			}
			else if (lValueDataType.IsWStringType && rValueDataType.IsWStringType)
			{
				if (lValueDataType.Size >= rValueDataType.Size)
					return new SimpleAssignmentStat(lExpression, rValue);
				else {
					this.report.SemanticError(188, rValue.ToString(), lExpression.ToString(), location);
					return Statement.Empty;
				}
			}
			if (this.ConversionOperatorExists(rValueDataType, lValueDataType))
				this.report.SemanticError(64, rValueDataType.Name, lValueDataType.Name, location);
			else
				this.report.SemanticError(150, rValueDataType.Name, lValueDataType.Name, location);
			return Statement.Empty;
		}
	}

	private StatementList MakeStatementList(Statement statement)
	{
		StatementList statementList = new StatementList();
		if (statement != null && statement != Statement.Empty)
		{
			statementList.Add(statement);
			this.CopyValue(statement.IsFunctionValueDefined);
		}
		return statementList;
	}

	private StatementList AddToStatementList(StatementList statementList, Statement statement, LexLocation location)
	{
		if (statementList != null && statement != null)
		{
			if (statement == Statement.Empty)
				return statementList;
			else if (statementList.Count > 0 && statementList.Last.ControlFlowTerminates)
				this.report.Warning(2, location);
			else {
				statementList.Add(statement);
				this.CopyValue(statement.IsFunctionValueDefined);
			}
		}
		return statementList;
	}

	private StatementList MakeCaseStatList(Statement statement)
	{
		StatementList statementList = new StatementList();
		if (statement != null && statement != Statement.Empty)
		{
			statementList.Add(statement);
			this.CopyValue(statement.IsFunctionValueDefined);
		}
		this.CheckForEndOfCaseStatList();
		return statementList;
	}

	private StatementList AddToCaseStatList(StatementList statementList, Statement statement, LexLocation location)
	{
		if (statementList != null && statement != null)
		{
			if (statement == Statement.Empty)
				return statementList;
			else if (statementList.Count > 0 && statementList.ControlFlowTerminates)
				this.report.Warning(2, location);
			else {
				statementList.Add(statement);
				this.CopyValue(statement.IsFunctionValueDefined);
			}
		}
		this.CheckForEndOfCaseStatList();
		return statementList;
	}

	private void CheckForEndOfCaseStatList()
	{
		STLangScanner scanner = (STLangScanner)this.Scanner;
		Tokens token = scanner.GetNextToken();
		switch (token)
		{
		case Tokens.IF:
		case Tokens.ELSE:
		case Tokens.WHILE:
		case Tokens.FOR:
		case Tokens.REPEAT:
		case Tokens.CASE:
		case Tokens.EXIT:
		case Tokens.END_CASE:
			// Control flow statement. 
			scanner.DoPushBack(false); 
		    break;

        case Tokens.TRUE:           
		case Tokens.FALSE:        
		case Tokens.INT_LIT:      
		case Tokens.REAL_LIT:     
		case Tokens.TOD_LIT:      
		case Tokens.TIME_LIT:     
		case Tokens.DATE_LIT:     
		case Tokens.DT_LIT:        
		case Tokens.STRING_LIT:        
		case Tokens.WSTRING_LIT:     
		case Tokens.TYPED_INT:       
		case Tokens.TYPED_REAL:   
		case Tokens.TYPED_ENUM:
		    // Constant ==> End of statement.
			scanner.DoPushBack(true);
			break;

		case Tokens.IDENT:
			token = scanner.GetNextToken();
			if (token == Tokens.ASSIGN)
				scanner.DoPushBack(false);
			else if (token == Tokens.DOTDOT || (char)token == ',' || (char)token == ':')
				scanner.DoPushBack(true);
			else if ((char)token != '(')
				scanner.DoPushBack(false);
			else {
				// Determine whether it is a function call or function block call
				STLangSymbol symbol;
				string ident = scanner.GetBufferedValue(0).Ident;

				if (! this.symbolTable.Lookup(ident, out symbol, null))
					scanner.DoPushBack(false);
				else if (symbol.IsFunctionBlock)
					scanner.DoPushBack(false); // Statement
				else
					scanner.DoPushBack(true);  // Expression
			}
			break;

		default:
			scanner.DoPushBack(true);
			break;
        }
	}

	private void PushSymbolTable(int declarationType = -1)
	{
		if (declarationType == 0)
			this.isFunctionDecl = true;
		else if (declarationType == 1)
			this.isFunctionBlockDecl = true;
		else if (declarationType == 2)
			this.isProgramDecl = true;
		this.symbolTable.Push();
	}

	private void PopSymbolTable()
	{
		this.symbolTable.Pop();
	}

	private void StoreInputOutputData(POUVarDeclarations pouDeclarations)
	{
		IEnumerable<InstanceSymbol> inputs = pouDeclarations.InputParameters;
		IEnumerable<InstanceSymbol> outputs = pouDeclarations.OutputParameters;
		IEnumerable<InstanceSymbol> retainedVars = pouDeclarations.RetainedVariables;

		foreach (InstanceSymbol input in inputs)
			ByteCodeGenerator.StoreInputParameter(input.Name, input.Position);
		foreach (InstanceSymbol output in outputs)
			ByteCodeGenerator.StoreOutputParameter(output.Name, output.Location.Index);
		foreach (InstanceSymbol retainedVar in retainedVars)
			ByteCodeGenerator.StoreRetainedVariable(retainedVar.Name, retainedVar.Location.Index);
		ByteCodeGenerator.StoreIOParameterCount();
	}

	// void GenerateInitInputs(POUVarDeclarations pouDeclarations)
	//
	// Generates code that initializes input parameters (VAR_INPUT).
	//
	private void GenerateInitInputs(POUVarDeclarations pouDeclarations)
	{
		Expression inputParam;
		IEnumerable<InstanceSymbol> inputs;

		inputs = pouDeclarations.InputParameters.Reverse();
		foreach (InstanceSymbol input in inputs)
		{
			inputParam = input.MakeSyntaxTreeNode(null);
			inputParam.GenerateStore();
		}
	}

	// void GenerateInitLocalVars(POUVarDeclarations pouDeclarations)
	//
	// Generates code that initializes local variables (VAR, VAR_TEMP (and VAR_OUTPUT in functions).
	//
	private void GenerateInitLocalVars(POUVarDeclarations pouDeclaration, bool isFunction)
    {
		IEnumerable<DeclarationStatement> localVariables;
		if (isFunction)
		{
			localVariables = pouDeclaration.LocalVariables;
			foreach (DeclarationStatement localVariable in localVariables)
			{
				localVariable.GenerateCode();
			}
		}
		else {
		}
	}

	private void GenerateStatementList(StatementList statementList)
	{
		if (statementList == null)
			throw new STLangCompilerError(Resources.GENFCNBODY);
		else
			statementList.GenerateCode();
	}

    string GetBaseName(string sourceFileName)
    {
        char[] separators = new char[] { '.' };
        string[] result = sourceFileName.Split(separators);
        if (result.Length > 0)
            return result[0];
        else
            return "";
    }

    private void GenerateObjectCode(string path, string sourceFile)
    {
		string executableFile;
		POUVarDeclarations varDeclarations;
		RWMemoryLayoutManager rwMemoryManager;
		ROMemoryLayoutManager roMemoryManager;
		IEnumerable<ProgramOrganizationUnitSymbol> pouSymbols;

		roMemoryManager = new ROMemoryLayoutManager();
		GenericConstant.ConstMemoryManager = roMemoryManager;
		pouSymbols = this.symbolTable.ProgramOrganizationUnits;
		executableFile = this.GetBaseName(sourceFile) + ".xstl";
		foreach (ProgramOrganizationUnitSymbol pouSymbol in pouSymbols)
		{
			foreach (ProgramOrganizationUnit pou in pouSymbol.Definitions)
			{
				varDeclarations = pou.VarDeclarations;
				rwMemoryManager = pou.RWMemoryLayout;
				constantTable = pou.ConstantTable;
				this.StoreInputOutputData(varDeclarations);
				this.GenerateInitInputs(varDeclarations);
                this.GenerateInitLocalVars(varDeclarations, pouSymbol.IsFunction);
                this.GenerateStatementList(pou.Body);
				ByteCodeGenerator.StorePOUName(pou.Name);
				ByteCodeGenerator.StorePOUType(pou.POUType);
				ByteCodeGenerator.StoreRWDataSegmentInfo(rwMemoryManager);
				ByteCodeGenerator.StoreConstantTable(constantTable);
				ByteCodeGenerator.StoreRODataSegmentInfo(roMemoryManager);
				ByteCodeGenerator.OptimizeByteCode();
				ByteCodeGenerator.CreateExecutable(path, executableFile);
				roMemoryManager.Reset();
			}
		}
    }

	internal STLangPOUObject GenerateObjectCode(bool overWrite)
    {
		STLangPOUObject pouObject;
		POUVarDeclarations varDeclarations;
		RWMemoryLayoutManager rwMemoryManager;
		ROMemoryLayoutManager roMemoryManager;
		IEnumerable<ProgramOrganizationUnitSymbol> pouSymbolList;
		List<STLangPOUObject> pouObjectList = new List<STLangPOUObject>();

		roMemoryManager = new ROMemoryLayoutManager();
		GenericConstant.ConstMemoryManager = roMemoryManager;
		pouSymbolList = this.symbolTable.ProgramOrganizationUnits;
		foreach (ProgramOrganizationUnitSymbol pouSymbol in pouSymbolList)
		{
			foreach (ProgramOrganizationUnit pou in pouSymbol.Definitions)
			{
				rwMemoryManager = pou.RWMemoryLayout;
				varDeclarations = pou.VarDeclarations;
				constantTable = pou.ConstantTable;
				this.StoreInputOutputData(varDeclarations);
				this.GenerateInitInputs(varDeclarations);
                this.GenerateInitLocalVars(varDeclarations, pouSymbol.IsFunction);
                this.GenerateStatementList(pou.Body);
				ByteCodeGenerator.StorePOUName(pou.Name);
				ByteCodeGenerator.StorePOUType(pou.POUType);
				ByteCodeGenerator.StoreRWDataSegmentInfo(rwMemoryManager);
				ByteCodeGenerator.StoreConstantTable(constantTable);
				ByteCodeGenerator.StoreRODataSegmentInfo(roMemoryManager);
				ByteCodeGenerator.OptimizeByteCode();
				pouObject = ByteCodeGenerator.CreateExecutable(pou.Name, overWrite);
				pouObjectList.Add(pouObject);
				roMemoryManager.Reset();
			}
		}
		return pouObjectList[0];
    }

	public bool Parse(string path, string sourceFile)
	{
		this.ReInitializeParser();
		bool result = this.Parse();
		if (!result || this.Errors > 0)
			return false;
		else {
			this.GenerateObjectCode(path, sourceFile);
			return true;
		}
	}
#line default
}
}
