// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, QUT 2005-2010
// (see accompanying GPPGcopyright.rtf)

// GPPG version 1.5.0
// Machine:  TOBO-W7
// DateTime: 2014-05-23 14:54:44
// UserName: tobo
// Input file <stlang.y - 2014-05-23 14:53:23>

// options: no-lines gplex

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Text;
using QUT.Gppg;
using System.Linq;
using System.Collections;
using STLang.Symbols;
using STLang.Scanner;
using STLang.Subranges;
using STLang.DataTypes;
using STLang.Statements;
using STLang.Extensions;
using STLang.Expressions;
using STLang.SymbolTable;
using STLang.ErrorManager;
using STLang.MemoryLayout;
using STLang.ParserUtility;
using STLang.VMInstructions;
using STLang.ConstantTokens;
using STLang.AttributeStack;
using STLang.POUDefinitions;
using STLang.ByteCodegenerator;
using STLang.ConstantPoolHandler;
using STLang.ImplDependentParams;
using STLang.RuntimeWrapper;
using StructuredTextParser.Properties;

namespace STLang.Parser
{
public enum Tokens {error=94,EOF=95,WHILE=96,
    REPEAT=97,UNTIL=98,FOR=99,IF=100,TO=101,DO=102,
    THEN=103,ELSE=104,CASE=105,END_CASE=106,ELSIF=107,END_FOR=108,
    END_WHILE=109,END_IF=110,END_REPEAT=111,EXIT=112,BY=113,ASSIGN=114,
    OUTPUT_ASSIGN=115,PROGRAM=116,END_PROGRAM=117,ARRAY=118,OF=119,STRUCT=120,
    END_STRUCT=121,FUNCTION=122,END_FUNCTION=123,FUNCTION_BLOCK=124,END_FUNCTION_BLOCK=125,TYPE=126,
    END_TYPE=127,INT=128,SINT=129,DINT=130,LINT=131,USINT=132,
    UINT=133,UDINT=134,ULINT=135,REAL=136,LREAL=137,DATE=138,
    TIME=139,TIME_OF_DAY=140,TOD=141,DATE_AND_TIME=142,DT=143,STRING=144,
    WSTRING=145,BOOL=146,BYTE=147,WORD=148,DWORD=149,LWORD=150,
    DOTDOT=151,ANY=152,ANY_INT=153,ANY_DERIVED=154,ANY_ELEMENTARY=155,ANY_MAGNITUDE=156,
    ANY_STRING=157,ANY_REAL=158,ANY_BIT=159,ANY_NUM=160,ANY_DATE=161,R_EDGE=162,
    F_EDGE=163,VAR=164,VAR_INPUT=165,VAR_OUTPUT=166,VAR_IN_OUT=167,VAR_EXTERNAL=168,
    AT=169,VAR_GLOBAL=170,VAR_TEMP=171,VAR_ACCESS=172,VAR_CONFIG=173,END_VAR=174,
    CONSTANT=175,RETAIN=176,NON_RETAIN=177,TRUE=178,FALSE=179,RETURN=180,
    READ_ONLY=181,WRITE_ONLY=182,READ_WRITE=183,DUMMY_TOKEN=184,CONFIGURATION=185,END_CONFIGURATION=186,
    INITIAL_STEP=187,END_STEP=188,RESOURCE=189,END_RESOURCE=190,WITH=191,TASK=192,
    TRANSITION=193,END_TRANSITION=194,WHEN=195,INT_LIT=196,REAL_LIT=197,TYPED_INT=198,
    TYPED_REAL=199,TYPED_ENUM=200,DATE_LIT=201,DT_LIT=202,TIME_LIT=203,TOD_LIT=204,
    STRING_LIT=205,WSTRING_LIT=206,IDENT=207,DIRECT_VAR=208,IOR=209,XOR=210,
    AND=211,NEQ=212,GEQ=213,LEQ=214,MOD=215,UMINUS=216,
    NOT=217,POW=218};

public partial struct ValueType
{
	public Tokens Token;
	public string Ident;
	public TokenInt LInt;
	public TokenDate Date;
	public TokenTime Time;
	public TokenDouble LReal;
	public TokenTOD TimeOfDay;
	public TokenDateTime DateTime;
	public TokenTypedInt TypedInt;
	public TokenTypedReal TypedReal;
	public TokenTypedEnum TypedEnum;
	public TokenDirectVar DirectVar;
	public SubRange Subrange;
	public string String;
	public object Object;
	public Statement Stat;
	public StatementList StatList;
	public DeclarationStatement Declaration;
	public POUVarDeclarations POUVariableDecls;
	public Expression Expression;
	public List<object> GenericList;
	public VarDeclStatement VarInitDecl;
	public List<VarDeclStatement> POUVarDecl;
	public CaseLabel CaseLabel;
	public List<SubRange> Subranges;
	public List<string> IdentifierList;
	public List<CaseLabel> CaseLabelList;
	public List<CaseElement> CaseElementList;
	public InitializerList InitList;
	public STVarType VarType;
	public STVarQualifier VarQualifier;
	public STDeclQualifier EdgeQualifier;
	public TypeNode DataType; 
	public ForLoopData ForList; 
	public DataTypeSpec TypeSpec;
	public POUParameter POUParameter;
	public StructDeclaration StructDecl;
	public StructMemberDeclaration MemberDecl;
	public ProgramOrganizationUnitCall POU;
	public IndexedVariable IndexedVariable;
}
// Abstract base class for GPLEX scanners
public abstract class ScanBase : AbstractScanner<ValueType,LexLocation> {
  private LexLocation __yylloc = new LexLocation();
  public override LexLocation yylloc { get { return __yylloc; } set { __yylloc = value; } }
  protected virtual bool yywrap() { return true; }
}

// Utility class for encapsulating token information
public class ScanObj {
  public int token;
  public ValueType yylval;
  public LexLocation yylloc;
  public ScanObj( int t, ValueType val, LexLocation loc ) {
    this.token = t; this.yylval = val; this.yylloc = loc;
  }
}

public partial class STLangParser: ShiftReduceParser<ValueType, LexLocation>
{
#pragma warning disable 649
  private static Dictionary<int, string> aliasses;
#pragma warning restore 649
  private static Rule[] rules = new Rule[401];
  private static State[] states = new State[607];
  private static string[] nonTerms = new string[] {
      "subrange", "statement_list", "opt_else_stat", "while_statement_body", 
      "for_statement_body", "default_statement", "function_body", "function_block_body", 
      "program_body", "case_stat_list", "var_init_decl", "var_declaration", "var_decl_list", 
      "elsif_stat", "opt_elsif_stat", "case_element_list", "case_elem_list", 
      "identifier_list", "enum_ident_seq", "case_label_list", "array_init_list", 
      "array_init_seq", "struct_init_list", "struct_init_seq", "initializer_seq", 
      "statement", "assignment_stat", "repeat_statement_body", "case_label", 
      "subrange_list", "struct_member_decls", "struct_member_decl", "case_element", 
      "function_decl", "elementary_type", "array_type", "structure_type", "subrange_type", 
      "enumerated_type", "derived_type", "non_generic_type", "string_type", "data_type", 
      "generic_type", "expression", "constant", "condition_DO", "condition_THEN", 
      "expression_OF", "variable", "simple_variable", "symbolic_variable", "initial_value", 
      "until_condition", "control_variable", "optional_by_stat", "initializer", 
      "var_decl", "temp_var_decl", "extern_var_decl", "global_var_decl", "access_var_decl", 
      "config_var_decl", "input_var_decl", "output_var_decl", "inout_var_decl", 
      "data_type_decl", "pou_variable_decl", "pou_call_sequence", "prog_org_unit_call", 
      "pou_parameter", "pou_variable_decls", "pou_var_decl_list", "indexed_variable", 
      "for_list_DO", "data_type_spec", "opt_var_qualifier", "opt_decl_qualifier", 
      "enum_identifier", "reserved_word", "assign", "main", "$accept", "Anon@1", 
      "pou_declarations", "pou_declaration", "function_block_decl", "program_decl", 
      "Anon@2", "Anon@3", "semicolon", "Anon@4", "Anon@5", "Anon@6", "Anon@7", 
      "Anon@8", "Anon@9", "type_decl_list", "Anon@10", "type_decl", "Anon@11", 
      "Anon@12", "Anon@13", "Anon@14", "Anon@15", "Anon@16", "Anon@17", "Anon@18", 
      "Anon@19", "Anon@20", "Anon@21", "Anon@22", "Anon@23", "Anon@24", "Anon@25", 
      "Anon@26", "Anon@27", "Anon@28", "Anon@29", "Anon@30", "Anon@31", "Anon@32", 
      "Anon@33", "Anon@34", "Anon@35", "Anon@36", "Anon@37", };

  static STLangParser() {
    states[0] = new State(-2,new int[]{-82,1,-84,3});
    states[1] = new State(new int[]{95,2});
    states[2] = new State(-1);
    states[3] = new State(new int[]{122,7,124,585,116,596,126,568},new int[]{-85,4,-86,606,-34,6,-87,584,-88,595,-67,605});
    states[4] = new State(new int[]{122,7,124,585,116,596,126,568,95,-3},new int[]{-86,5,-34,6,-87,584,-88,595,-67,605});
    states[5] = new State(-5);
    states[6] = new State(-6);
    states[7] = new State(new int[]{207,8});
    states[8] = new State(new int[]{58,9});
    states[9] = new State(new int[]{129,317,128,318,130,319,131,320,132,321,133,322,134,323,135,324,136,325,137,326,138,327,140,328,141,329,142,330,143,331,139,332,146,333,147,334,148,335,149,336,150,337,207,347,144,349,145,353},new int[]{-41,10,-35,345,-40,346,-42,348});
    states[10] = new State(-265,new int[]{-111,11});
    states[11] = new State(new int[]{164,251,171,512,168,519,170,526,172,533,173,540,165,547,166,554,167,561,126,568,94,-313,96,-313,97,-313,100,-313,99,-313,105,-313,207,-313,208,-313,112,-313,180,-313,59,-313},new int[]{-72,12,-73,248,-68,583,-58,250,-59,511,-60,518,-61,525,-62,532,-63,539,-64,546,-65,553,-66,560,-67,567});
    states[12] = new State(-266,new int[]{-112,13});
    states[13] = new State(new int[]{94,232,96,-183,97,-183,100,-183,99,-183,105,-183,207,-183,208,-183,112,-183,180,-183,59,-183},new int[]{-7,14,-2,15,-103,201});
    states[14] = new State(-267);
    states[15] = new State(new int[]{123,16,94,19,96,21,97,28,100,135,99,144,105,154,207,81,208,125,112,172,180,173,59,-200},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[16] = new State(-259);
    states[17] = new State(new int[]{59,18});
    states[18] = new State(-185);
    states[19] = new State(new int[]{123,20});
    states[20] = new State(-260);
    states[21] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,94,246},new int[]{-47,22,-45,244,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[22] = new State(new int[]{94,242,96,-183,97,-183,100,-183,99,-183,105,-183,207,-183,208,-183,112,-183,180,-183,59,-183},new int[]{-4,23,-2,24,-103,201});
    states[23] = new State(-187);
    states[24] = new State(new int[]{109,25,94,26,96,21,97,28,100,135,99,144,105,154,207,81,208,125,112,172,180,173,59,-200},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[25] = new State(-201);
    states[26] = new State(new int[]{109,27});
    states[27] = new State(-202);
    states[28] = new State(-188,new int[]{-104,29});
    states[29] = new State(new int[]{94,240,96,-183,97,-183,100,-183,99,-183,105,-183,207,-183,208,-183,112,-183,180,-183,59,-183},new int[]{-28,30,-2,31,-103,201});
    states[30] = new State(-189);
    states[31] = new State(new int[]{98,32,94,132,96,21,97,28,100,135,99,144,105,154,207,81,208,125,112,172,180,173,59,-200},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[32] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,94,130},new int[]{-54,33,-45,34,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[33] = new State(-204);
    states[34] = new State(new int[]{111,35,61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,59,-218});
    states[35] = new State(-216);
    states[36] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,37,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[37] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,-153,209,-153,210,-153,218,54,215,56,38,-153,43,60,45,62,42,64,47,66,102,-153,94,-153,96,-153,97,-153,100,-153,99,-153,105,-153,207,-153,208,-153,112,-153,180,-153,59,-153,111,-153,41,-153,44,-153,93,-153,103,-153,101,-153,119,-153,195,-153,104,-153,106,-153,151,-153,58,-153,217,-153,40,-153,178,-153,179,-153,196,-153,197,-153,204,-153,203,-153,201,-153,202,-153,205,-153,206,-153,198,-153,199,-153,200,-153,113,-153,174,-153,169,-153,121,-153,127,-153});
    states[38] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,39,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[39] = new State(new int[]{61,-154,60,38,62,40,212,-154,213,44,214,46,211,-154,209,-154,210,-154,218,54,215,56,38,-154,43,60,45,62,42,64,47,66,102,-154,94,-154,96,-154,97,-154,100,-154,99,-154,105,-154,207,-154,208,-154,112,-154,180,-154,59,-154,111,-154,41,-154,44,-154,93,-154,103,-154,101,-154,119,-154,195,-154,104,-154,106,-154,151,-154,58,-154,217,-154,40,-154,178,-154,179,-154,196,-154,197,-154,204,-154,203,-154,201,-154,202,-154,205,-154,206,-154,198,-154,199,-154,200,-154,113,-154,174,-154,169,-154,121,-154,127,-154});
    states[40] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,41,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[41] = new State(new int[]{61,-155,60,38,62,40,212,-155,213,44,214,46,211,-155,209,-155,210,-155,218,54,215,56,38,-155,43,60,45,62,42,64,47,66,102,-155,94,-155,96,-155,97,-155,100,-155,99,-155,105,-155,207,-155,208,-155,112,-155,180,-155,59,-155,111,-155,41,-155,44,-155,93,-155,103,-155,101,-155,119,-155,195,-155,104,-155,106,-155,151,-155,58,-155,217,-155,40,-155,178,-155,179,-155,196,-155,197,-155,204,-155,203,-155,201,-155,202,-155,205,-155,206,-155,198,-155,199,-155,200,-155,113,-155,174,-155,169,-155,121,-155,127,-155});
    states[42] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,43,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[43] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,-156,209,-156,210,-156,218,54,215,56,38,-156,43,60,45,62,42,64,47,66,102,-156,94,-156,96,-156,97,-156,100,-156,99,-156,105,-156,207,-156,208,-156,112,-156,180,-156,59,-156,111,-156,41,-156,44,-156,93,-156,103,-156,101,-156,119,-156,195,-156,104,-156,106,-156,151,-156,58,-156,217,-156,40,-156,178,-156,179,-156,196,-156,197,-156,204,-156,203,-156,201,-156,202,-156,205,-156,206,-156,198,-156,199,-156,200,-156,113,-156,174,-156,169,-156,121,-156,127,-156});
    states[44] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,45,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[45] = new State(new int[]{61,-157,60,38,62,40,212,-157,213,44,214,46,211,-157,209,-157,210,-157,218,54,215,56,38,-157,43,60,45,62,42,64,47,66,102,-157,94,-157,96,-157,97,-157,100,-157,99,-157,105,-157,207,-157,208,-157,112,-157,180,-157,59,-157,111,-157,41,-157,44,-157,93,-157,103,-157,101,-157,119,-157,195,-157,104,-157,106,-157,151,-157,58,-157,217,-157,40,-157,178,-157,179,-157,196,-157,197,-157,204,-157,203,-157,201,-157,202,-157,205,-157,206,-157,198,-157,199,-157,200,-157,113,-157,174,-157,169,-157,121,-157,127,-157});
    states[46] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,47,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[47] = new State(new int[]{61,-158,60,38,62,40,212,-158,213,44,214,46,211,-158,209,-158,210,-158,218,54,215,56,38,-158,43,60,45,62,42,64,47,66,102,-158,94,-158,96,-158,97,-158,100,-158,99,-158,105,-158,207,-158,208,-158,112,-158,180,-158,59,-158,111,-158,41,-158,44,-158,93,-158,103,-158,101,-158,119,-158,195,-158,104,-158,106,-158,151,-158,58,-158,217,-158,40,-158,178,-158,179,-158,196,-158,197,-158,204,-158,203,-158,201,-158,202,-158,205,-158,206,-158,198,-158,199,-158,200,-158,113,-158,174,-158,169,-158,121,-158,127,-158});
    states[48] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,49,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[49] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,-159,209,-159,210,-159,218,54,215,56,38,-159,43,60,45,62,42,64,47,66,102,-159,94,-159,96,-159,97,-159,100,-159,99,-159,105,-159,207,-159,208,-159,112,-159,180,-159,59,-159,111,-159,41,-159,44,-159,93,-159,103,-159,101,-159,119,-159,195,-159,104,-159,106,-159,151,-159,58,-159,217,-159,40,-159,178,-159,179,-159,196,-159,197,-159,204,-159,203,-159,201,-159,202,-159,205,-159,206,-159,198,-159,199,-159,200,-159,113,-159,174,-159,169,-159,121,-159,127,-159});
    states[50] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,51,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[51] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,-160,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,102,-160,94,-160,96,-160,97,-160,100,-160,99,-160,105,-160,207,-160,208,-160,112,-160,180,-160,59,-160,111,-160,41,-160,44,-160,93,-160,103,-160,101,-160,119,-160,195,-160,104,-160,106,-160,151,-160,58,-160,217,-160,40,-160,178,-160,179,-160,196,-160,197,-160,204,-160,203,-160,201,-160,202,-160,205,-160,206,-160,198,-160,199,-160,200,-160,113,-160,174,-160,169,-160,121,-160,127,-160});
    states[52] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,53,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[53] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,-161,210,-161,218,54,215,56,38,58,43,60,45,62,42,64,47,66,102,-161,94,-161,96,-161,97,-161,100,-161,99,-161,105,-161,207,-161,208,-161,112,-161,180,-161,59,-161,111,-161,41,-161,44,-161,93,-161,103,-161,101,-161,119,-161,195,-161,104,-161,106,-161,151,-161,58,-161,217,-161,40,-161,178,-161,179,-161,196,-161,197,-161,204,-161,203,-161,201,-161,202,-161,205,-161,206,-161,198,-161,199,-161,200,-161,113,-161,174,-161,169,-161,121,-161,127,-161});
    states[54] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,55,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[55] = new State(new int[]{61,-162,60,-162,62,-162,212,-162,213,-162,214,-162,211,-162,209,-162,210,-162,218,54,215,-162,38,-162,43,-162,45,-162,42,-162,47,-162,102,-162,94,-162,96,-162,97,-162,100,-162,99,-162,105,-162,207,-162,208,-162,112,-162,180,-162,59,-162,111,-162,41,-162,44,-162,93,-162,103,-162,101,-162,119,-162,195,-162,104,-162,106,-162,151,-162,58,-162,217,-162,40,-162,178,-162,179,-162,196,-162,197,-162,204,-162,203,-162,201,-162,202,-162,205,-162,206,-162,198,-162,199,-162,200,-162,113,-162,174,-162,169,-162,121,-162,127,-162});
    states[56] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,57,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[57] = new State(new int[]{61,-163,60,-163,62,-163,212,-163,213,-163,214,-163,211,-163,209,-163,210,-163,218,54,215,-163,38,-163,43,-163,45,-163,42,-163,47,-163,102,-163,94,-163,96,-163,97,-163,100,-163,99,-163,105,-163,207,-163,208,-163,112,-163,180,-163,59,-163,111,-163,41,-163,44,-163,93,-163,103,-163,101,-163,119,-163,195,-163,104,-163,106,-163,151,-163,58,-163,217,-163,40,-163,178,-163,179,-163,196,-163,197,-163,204,-163,203,-163,201,-163,202,-163,205,-163,206,-163,198,-163,199,-163,200,-163,113,-163,174,-163,169,-163,121,-163,127,-163});
    states[58] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,59,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[59] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,-164,209,-164,210,-164,218,54,215,56,38,-164,43,60,45,62,42,64,47,66,102,-164,94,-164,96,-164,97,-164,100,-164,99,-164,105,-164,207,-164,208,-164,112,-164,180,-164,59,-164,111,-164,41,-164,44,-164,93,-164,103,-164,101,-164,119,-164,195,-164,104,-164,106,-164,151,-164,58,-164,217,-164,40,-164,178,-164,179,-164,196,-164,197,-164,204,-164,203,-164,201,-164,202,-164,205,-164,206,-164,198,-164,199,-164,200,-164,113,-164,174,-164,169,-164,121,-164,127,-164});
    states[60] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,61,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[61] = new State(new int[]{61,-165,60,-165,62,-165,212,-165,213,-165,214,-165,211,-165,209,-165,210,-165,218,54,215,56,38,-165,43,-165,45,-165,42,64,47,66,102,-165,94,-165,96,-165,97,-165,100,-165,99,-165,105,-165,207,-165,208,-165,112,-165,180,-165,59,-165,111,-165,41,-165,44,-165,93,-165,103,-165,101,-165,119,-165,195,-165,104,-165,106,-165,151,-165,58,-165,217,-165,40,-165,178,-165,179,-165,196,-165,197,-165,204,-165,203,-165,201,-165,202,-165,205,-165,206,-165,198,-165,199,-165,200,-165,113,-165,174,-165,169,-165,121,-165,127,-165});
    states[62] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,63,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[63] = new State(new int[]{61,-166,60,-166,62,-166,212,-166,213,-166,214,-166,211,-166,209,-166,210,-166,218,54,215,56,38,-166,43,-166,45,-166,42,64,47,66,102,-166,94,-166,96,-166,97,-166,100,-166,99,-166,105,-166,207,-166,208,-166,112,-166,180,-166,59,-166,111,-166,41,-166,44,-166,93,-166,103,-166,101,-166,119,-166,195,-166,104,-166,106,-166,151,-166,58,-166,217,-166,40,-166,178,-166,179,-166,196,-166,197,-166,204,-166,203,-166,201,-166,202,-166,205,-166,206,-166,198,-166,199,-166,200,-166,113,-166,174,-166,169,-166,121,-166,127,-166});
    states[64] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,65,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[65] = new State(new int[]{61,-167,60,-167,62,-167,212,-167,213,-167,214,-167,211,-167,209,-167,210,-167,218,54,215,-167,38,-167,43,-167,45,-167,42,-167,47,-167,102,-167,94,-167,96,-167,97,-167,100,-167,99,-167,105,-167,207,-167,208,-167,112,-167,180,-167,59,-167,111,-167,41,-167,44,-167,93,-167,103,-167,101,-167,119,-167,195,-167,104,-167,106,-167,151,-167,58,-167,217,-167,40,-167,178,-167,179,-167,196,-167,197,-167,204,-167,203,-167,201,-167,202,-167,205,-167,206,-167,198,-167,199,-167,200,-167,113,-167,174,-167,169,-167,121,-167,127,-167});
    states[66] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,67,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[67] = new State(new int[]{61,-168,60,-168,62,-168,212,-168,213,-168,214,-168,211,-168,209,-168,210,-168,218,54,215,-168,38,-168,43,-168,45,-168,42,-168,47,-168,102,-168,94,-168,96,-168,97,-168,100,-168,99,-168,105,-168,207,-168,208,-168,112,-168,180,-168,59,-168,111,-168,41,-168,44,-168,93,-168,103,-168,101,-168,119,-168,195,-168,104,-168,106,-168,151,-168,58,-168,217,-168,40,-168,178,-168,179,-168,196,-168,197,-168,204,-168,203,-168,201,-168,202,-168,205,-168,206,-168,198,-168,199,-168,200,-168,113,-168,174,-168,169,-168,121,-168,127,-168});
    states[68] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,69,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[69] = new State(new int[]{61,-150,60,-150,62,-150,212,-150,213,-150,214,-150,211,-150,209,-150,210,-150,218,54,215,-150,38,-150,43,-150,45,-150,42,-150,47,-150,102,-150,94,-150,96,-150,97,-150,100,-150,99,-150,105,-150,207,-150,208,-150,112,-150,180,-150,59,-150,111,-150,41,-150,44,-150,93,-150,103,-150,101,-150,119,-150,195,-150,104,-150,106,-150,151,-150,58,-150,217,-150,40,-150,178,-150,179,-150,196,-150,197,-150,204,-150,203,-150,201,-150,202,-150,205,-150,206,-150,198,-150,199,-150,200,-150,113,-150,174,-150,169,-150,121,-150,127,-150});
    states[70] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,71,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[71] = new State(new int[]{61,-151,60,-151,62,-151,212,-151,213,-151,214,-151,211,-151,209,-151,210,-151,218,54,215,-151,38,-151,43,-151,45,-151,42,-151,47,-151,102,-151,94,-151,96,-151,97,-151,100,-151,99,-151,105,-151,207,-151,208,-151,112,-151,180,-151,59,-151,111,-151,41,-151,44,-151,93,-151,103,-151,101,-151,119,-151,195,-151,104,-151,106,-151,151,-151,58,-151,217,-151,40,-151,178,-151,179,-151,196,-151,197,-151,204,-151,203,-151,201,-151,202,-151,205,-151,206,-151,198,-151,199,-151,200,-151,113,-151,174,-151,169,-151,121,-151,127,-151});
    states[72] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,73,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[73] = new State(new int[]{61,-152,60,-152,62,-152,212,-152,213,-152,214,-152,211,-152,209,-152,210,-152,218,54,215,-152,38,-152,43,-152,45,-152,42,-152,47,-152,102,-152,94,-152,96,-152,97,-152,100,-152,99,-152,105,-152,207,-152,208,-152,112,-152,180,-152,59,-152,111,-152,41,-152,44,-152,93,-152,103,-152,101,-152,119,-152,195,-152,104,-152,106,-152,151,-152,58,-152,217,-152,40,-152,178,-152,179,-152,196,-152,197,-152,204,-152,203,-152,201,-152,202,-152,205,-152,206,-152,198,-152,199,-152,200,-152,113,-152,174,-152,169,-152,121,-152,127,-152});
    states[74] = new State(new int[]{94,78,217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,75,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[75] = new State(new int[]{41,76,94,77,61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66});
    states[76] = new State(-169);
    states[77] = new State(-170);
    states[78] = new State(new int[]{41,79});
    states[79] = new State(-174);
    states[80] = new State(-171);
    states[81] = new State(new int[]{40,82,91,-148,46,-148,114,-148,61,-148,102,-148,60,-148,62,-148,212,-148,213,-148,214,-148,211,-148,209,-148,210,-148,218,-148,215,-148,38,-148,43,-148,45,-148,42,-148,47,-148,94,-148,96,-148,97,-148,100,-148,99,-148,105,-148,207,-148,208,-148,112,-148,180,-148,59,-148,111,-148,41,-148,44,-148,93,-148,103,-148,101,-148,119,-148,195,-148,104,-148,106,-148,151,-148,58,-148,217,-148,178,-148,179,-148,196,-148,197,-148,204,-148,203,-148,201,-148,202,-148,205,-148,206,-148,198,-148,199,-148,200,-148,113,-148,174,-148,169,-148,121,-148,127,-148});
    states[82] = new State(new int[]{41,83,94,84,217,88,45,70,43,72,40,74,207,96,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-71,86,-45,87,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[83] = new State(-180);
    states[84] = new State(new int[]{41,85});
    states[85] = new State(-181);
    states[86] = new State(-178);
    states[87] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,41,-175,44,-175});
    states[88] = new State(new int[]{207,89,217,68,45,70,43,72,40,74,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,69,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[89] = new State(new int[]{40,82,114,128,115,129,91,-148,46,-148,61,-148,60,-148,62,-148,212,-148,213,-148,214,-148,211,-148,209,-148,210,-148,218,-148,215,-148,38,-148,43,-148,45,-148,42,-148,47,-148,41,-148,44,-148},new int[]{-81,90});
    states[90] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,91,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[91] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,41,-177,44,-177});
    states[92] = new State(new int[]{41,93,44,94});
    states[93] = new State(-182);
    states[94] = new State(new int[]{217,88,45,70,43,72,40,74,207,96,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-71,95,-45,87,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[95] = new State(-179);
    states[96] = new State(new int[]{40,82,114,128,115,129,91,-148,46,-148,61,-148,60,-148,62,-148,212,-148,213,-148,214,-148,211,-148,209,-148,210,-148,218,-148,215,-148,38,-148,43,-148,45,-148,42,-148,47,-148,41,-148,44,-148},new int[]{-81,97});
    states[97] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,98,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[98] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,41,-176,44,-176});
    states[99] = new State(-172);
    states[100] = new State(-127);
    states[101] = new State(-128);
    states[102] = new State(-129);
    states[103] = new State(-130);
    states[104] = new State(-131);
    states[105] = new State(-132);
    states[106] = new State(-133);
    states[107] = new State(-134);
    states[108] = new State(-135);
    states[109] = new State(-136);
    states[110] = new State(-137);
    states[111] = new State(-138);
    states[112] = new State(-139);
    states[113] = new State(-173);
    states[114] = new State(new int[]{46,115,114,-140,61,-140,102,-140,60,-140,62,-140,212,-140,213,-140,214,-140,211,-140,209,-140,210,-140,218,-140,215,-140,38,-140,43,-140,45,-140,42,-140,47,-140,94,-140,96,-140,97,-140,100,-140,99,-140,105,-140,207,-140,208,-140,112,-140,180,-140,59,-140,111,-140,41,-140,44,-140,93,-140,103,-140,101,-140,119,-140,195,-140,104,-140,106,-140,151,-140,58,-140,217,-140,40,-140,178,-140,179,-140,196,-140,197,-140,204,-140,203,-140,201,-140,202,-140,205,-140,206,-140,198,-140,199,-140,200,-140,113,-140,174,-140,169,-140,121,-140,127,-140,115,-140});
    states[115] = new State(new int[]{207,116});
    states[116] = new State(-149);
    states[117] = new State(new int[]{91,118,46,-142,114,-142,61,-142,102,-142,60,-142,62,-142,212,-142,213,-142,214,-142,211,-142,209,-142,210,-142,218,-142,215,-142,38,-142,43,-142,45,-142,42,-142,47,-142,94,-142,96,-142,97,-142,100,-142,99,-142,105,-142,207,-142,208,-142,112,-142,180,-142,59,-142,111,-142,41,-142,44,-142,93,-142,103,-142,101,-142,119,-142,195,-142,104,-142,106,-142,151,-142,58,-142,217,-142,40,-142,178,-142,179,-142,196,-142,197,-142,204,-142,203,-142,201,-142,202,-142,205,-142,206,-142,198,-142,199,-142,200,-142,113,-142,174,-142,169,-142,121,-142,127,-142,115,-142});
    states[118] = new State(new int[]{94,126,217,-145,45,-145,43,-145,40,-145,207,-145,178,-145,179,-145,196,-145,197,-145,204,-145,203,-145,201,-145,202,-145,205,-145,206,-145,198,-145,199,-145,200,-145,208,-145},new int[]{-102,119});
    states[119] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,120,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[120] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,93,-146,44,-146});
    states[121] = new State(new int[]{93,122,44,123});
    states[122] = new State(-143);
    states[123] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,124,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[124] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,93,-147,44,-147});
    states[125] = new State(-141);
    states[126] = new State(new int[]{93,127});
    states[127] = new State(-144);
    states[128] = new State(-10);
    states[129] = new State(-11);
    states[130] = new State(new int[]{111,131});
    states[131] = new State(-217);
    states[132] = new State(new int[]{98,133});
    states[133] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,94,130},new int[]{-54,134,-45,34,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[134] = new State(-205);
    states[135] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,94,235},new int[]{-48,136,-45,233,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[136] = new State(new int[]{94,232,96,-183,97,-183,100,-183,99,-183,105,-183,207,-183,208,-183,112,-183,180,-183,59,-183},new int[]{-2,137,-103,201});
    states[137] = new State(new int[]{96,21,97,28,100,135,99,144,105,154,207,81,208,125,112,172,180,173,107,-190,104,-190,110,-190,59,-200},new int[]{-105,138,-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[138] = new State(new int[]{107,237,104,-236,110,-236},new int[]{-15,139,-14,228});
    states[139] = new State(new int[]{104,142,110,-234},new int[]{-3,140});
    states[140] = new State(new int[]{110,141});
    states[141] = new State(-191);
    states[142] = new State(new int[]{94,227,96,-183,97,-183,100,-183,99,-183,105,-183,207,-183,208,-183,112,-183,180,-183,59,-183},new int[]{-2,143,-103,201});
    states[143] = new State(new int[]{96,21,97,28,100,135,99,144,105,154,207,81,208,125,112,172,180,173,110,-232,59,-200},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[144] = new State(new int[]{207,226,208,125},new int[]{-55,145,-50,225,-52,114,-51,117,-74,121});
    states[145] = new State(new int[]{114,128,115,129},new int[]{-81,146});
    states[146] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,94,218},new int[]{-75,147,-45,207,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[147] = new State(-192,new int[]{-106,148});
    states[148] = new State(new int[]{94,204,96,-183,97,-183,100,-183,99,-183,105,-183,207,-183,208,-183,112,-183,180,-183,59,-183},new int[]{-5,149,-2,150,-103,201});
    states[149] = new State(-193);
    states[150] = new State(new int[]{108,151,94,152,96,21,97,28,100,135,99,144,105,154,207,81,208,125,112,172,180,173,59,-200},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[151] = new State(-207);
    states[152] = new State(new int[]{108,153});
    states[153] = new State(-208);
    states[154] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,94,199},new int[]{-49,155,-45,197,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[155] = new State(new int[]{195,160,104,193,106,-250},new int[]{-16,156,-17,158,-33,196,-6,192});
    states[156] = new State(new int[]{106,157});
    states[157] = new State(-194);
    states[158] = new State(new int[]{195,160,104,193,106,-249},new int[]{-33,159,-6,192});
    states[159] = new State(-248);
    states[160] = new State(new int[]{94,188,217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-20,161,-29,191,-45,184,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-1,187});
    states[161] = new State(new int[]{58,162,44,182,94,179,96,-239,97,-239,100,-239,99,-239,105,-239,207,-239,208,-239,112,-239,180,-239,59,-239},new int[]{-10,181,-110,176});
    states[162] = new State(new int[]{94,179,96,-239,97,-239,100,-239,99,-239,105,-239,207,-239,208,-239,112,-239,180,-239,59,-239},new int[]{-10,163,-110,176});
    states[163] = new State(new int[]{96,21,97,28,100,135,99,144,105,154,207,81,208,125,112,172,180,173,195,-243,104,-243,106,-243,59,-200},new int[]{-26,164,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[164] = new State(new int[]{59,165});
    states[165] = new State(-241);
    states[166] = new State(-195);
    states[167] = new State(new int[]{114,168,61,170});
    states[168] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,169,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[169] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,59,-257});
    states[170] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,171,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[171] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,59,-258});
    states[172] = new State(-196);
    states[173] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,59,-197},new int[]{-45,174,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[174] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,59,-198});
    states[175] = new State(-199);
    states[176] = new State(new int[]{96,21,97,28,100,135,99,144,105,154,207,81,208,125,112,172,180,173,59,-200},new int[]{-26,177,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[177] = new State(new int[]{59,178});
    states[178] = new State(-240);
    states[179] = new State(new int[]{59,180});
    states[180] = new State(-242);
    states[181] = new State(new int[]{96,21,97,28,100,135,99,144,105,154,207,81,208,125,112,172,180,173,195,-245,104,-245,106,-245,59,-200},new int[]{-26,164,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[182] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-29,183,-45,184,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-1,187});
    states[183] = new State(-254);
    states[184] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,151,185,58,-251,44,-251,94,-251,96,-251,97,-251,100,-251,99,-251,105,-251,207,-251,208,-251,112,-251,180,-251,59,-251});
    states[185] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,186,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[186] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,58,-12,44,-12,94,-12,96,-12,97,-12,100,-12,99,-12,105,-12,207,-12,208,-12,112,-12,180,-12,59,-12,93,-12,217,-12,40,-12,178,-12,179,-12,196,-12,197,-12,204,-12,203,-12,201,-12,202,-12,205,-12,206,-12,198,-12,199,-12,200,-12,41,-12});
    states[187] = new State(-252);
    states[188] = new State(new int[]{58,189});
    states[189] = new State(new int[]{94,179,96,-239,97,-239,100,-239,99,-239,105,-239,207,-239,208,-239,112,-239,180,-239,59,-239},new int[]{-10,190,-110,176});
    states[190] = new State(new int[]{96,21,97,28,100,135,99,144,105,154,207,81,208,125,112,172,180,173,195,-244,104,-244,106,-244,59,-200},new int[]{-26,164,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[191] = new State(-253);
    states[192] = new State(-246);
    states[193] = new State(new int[]{94,179,96,-239,97,-239,100,-239,99,-239,105,-239,207,-239,208,-239,112,-239,180,-239,59,-239},new int[]{-10,194,-110,176});
    states[194] = new State(new int[]{94,195,96,21,97,28,100,135,99,144,105,154,207,81,208,125,112,172,180,173,195,-237,104,-237,106,-237,59,-200},new int[]{-26,164,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[195] = new State(-238);
    states[196] = new State(-247);
    states[197] = new State(new int[]{119,198,61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,195,-221,104,-221,106,-221});
    states[198] = new State(-219);
    states[199] = new State(new int[]{119,200});
    states[200] = new State(-220);
    states[201] = new State(new int[]{96,21,97,28,100,135,99,144,105,154,207,81,208,125,112,172,180,173,59,-200},new int[]{-26,202,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[202] = new State(new int[]{59,203});
    states[203] = new State(-184);
    states[204] = new State(new int[]{59,205,108,206});
    states[205] = new State(-186);
    states[206] = new State(-209);
    states[207] = new State(new int[]{101,208,61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66});
    states[208] = new State(new int[]{94,216,217,-223,45,-223,43,-223,40,-223,207,-223,178,-223,179,-223,196,-223,197,-223,204,-223,203,-223,201,-223,202,-223,205,-223,206,-223,198,-223,199,-223,200,-223,208,-223},new int[]{-107,209});
    states[209] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,210,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[210] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,113,213,102,-231},new int[]{-56,211});
    states[211] = new State(new int[]{102,212});
    states[212] = new State(-224);
    states[213] = new State(-229,new int[]{-109,214});
    states[214] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,215,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[215] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,102,-230});
    states[216] = new State(new int[]{102,217});
    states[217] = new State(-227);
    states[218] = new State(new int[]{101,219,102,224});
    states[219] = new State(-225,new int[]{-108,220});
    states[220] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,221,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[221] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,113,213,102,-231},new int[]{-56,222});
    states[222] = new State(new int[]{102,223});
    states[223] = new State(-226);
    states[224] = new State(-228);
    states[225] = new State(-222);
    states[226] = new State(-148);
    states[227] = new State(new int[]{59,205,110,-233});
    states[228] = new State(new int[]{107,229,104,-235,110,-235});
    states[229] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,94,235},new int[]{-48,230,-45,233,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[230] = new State(new int[]{94,232,96,-183,97,-183,100,-183,99,-183,105,-183,207,-183,208,-183,112,-183,180,-183,59,-183},new int[]{-2,231,-103,201});
    states[231] = new State(new int[]{96,21,97,28,100,135,99,144,105,154,207,81,208,125,112,172,180,173,107,-256,104,-256,110,-256,59,-200},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[232] = new State(new int[]{59,205});
    states[233] = new State(new int[]{103,234,61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,94,-215,96,-215,97,-215,100,-215,99,-215,105,-215,207,-215,208,-215,112,-215,180,-215,59,-215});
    states[234] = new State(-213);
    states[235] = new State(new int[]{103,236});
    states[236] = new State(-214);
    states[237] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,94,235},new int[]{-48,238,-45,233,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[238] = new State(new int[]{94,232,96,-183,97,-183,100,-183,99,-183,105,-183,207,-183,208,-183,112,-183,180,-183,59,-183},new int[]{-2,239,-103,201});
    states[239] = new State(new int[]{96,21,97,28,100,135,99,144,105,154,207,81,208,125,112,172,180,173,107,-255,104,-255,110,-255,59,-200},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[240] = new State(new int[]{59,205,111,241});
    states[241] = new State(-206);
    states[242] = new State(new int[]{59,205,109,243});
    states[243] = new State(-203);
    states[244] = new State(new int[]{102,245,61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,94,-212,96,-212,97,-212,100,-212,99,-212,105,-212,207,-212,208,-212,112,-212,180,-212,59,-212});
    states[245] = new State(-210);
    states[246] = new State(new int[]{102,247});
    states[247] = new State(-211);
    states[248] = new State(new int[]{164,251,171,512,168,519,170,526,172,533,173,540,165,547,166,554,167,561,126,568,94,-312,96,-312,97,-312,100,-312,99,-312,105,-312,207,-312,208,-312,112,-312,180,-312,59,-312},new int[]{-68,249,-58,250,-59,511,-60,518,-61,525,-62,532,-63,539,-64,546,-65,553,-66,560,-67,567});
    states[249] = new State(-311);
    states[250] = new State(-300);
    states[251] = new State(new int[]{94,504,176,506,177,508,175,509,207,-330,169,-330},new int[]{-77,252});
    states[252] = new State(-276,new int[]{-117,253});
    states[253] = new State(new int[]{207,491,169,497},new int[]{-12,254,-13,255,-11,502,-18,262});
    states[254] = new State(-277);
    states[255] = new State(new int[]{174,256,94,260,207,491,169,497},new int[]{-11,257,-18,262});
    states[256] = new State(-316);
    states[257] = new State(new int[]{59,259,174,-124,94,-124,207,-124,169,-124},new int[]{-91,258});
    states[258] = new State(-315);
    states[259] = new State(-123);
    states[260] = new State(new int[]{174,261});
    states[261] = new State(-317);
    states[262] = new State(new int[]{58,263,44,487,207,490});
    states[263] = new State(new int[]{129,317,128,318,130,319,131,320,132,321,133,322,134,323,135,324,136,325,137,326,138,327,140,328,141,329,142,330,143,331,139,332,146,333,147,334,148,335,149,336,150,337,118,339,120,381,40,463,207,347,144,349,145,353,152,477,160,478,153,479,158,480,159,481,161,482,154,483,155,484,156,485,157,486},new int[]{-43,264,-35,316,-36,338,-37,366,-31,367,-39,387,-19,388,-38,468,-41,469,-40,474,-42,475,-44,476});
    states[264] = new State(new int[]{162,312,163,313,181,314,182,315,114,-335,59,-335,174,-335,94,-335,207,-335,169,-335},new int[]{-78,265});
    states[265] = new State(new int[]{59,-318,174,-318,94,-318,207,-318,169,-318,114,-319},new int[]{-125,266});
    states[266] = new State(new int[]{114,267});
    states[267] = new State(new int[]{217,68,45,70,43,72,40,270,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,91,294},new int[]{-53,268,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[268] = new State(-320);
    states[269] = new State(new int[]{61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,59,-114,174,-114,94,-114,207,-114,169,-114,41,-114,44,-114,93,-114,121,-114,127,-114});
    states[270] = new State(new int[]{94,78,41,273,217,68,45,70,43,72,40,270,207,274,178,100,179,101,196,284,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,91,294},new int[]{-45,271,-57,272,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-53,283,-21,278,-22,279,-23,297,-24,298});
    states[271] = new State(new int[]{41,76,94,77,61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66,44,-114});
    states[272] = new State(-95);
    states[273] = new State(-103);
    states[274] = new State(new int[]{40,82,91,-148,46,-148,41,-148,94,-148,61,-148,60,-148,62,-148,212,-148,213,-148,214,-148,211,-148,209,-148,210,-148,218,-148,215,-148,38,-148,43,-148,45,-148,42,-148,47,-148,44,-148,93,-148,114,-109},new int[]{-97,275});
    states[275] = new State(new int[]{114,276});
    states[276] = new State(new int[]{217,68,45,70,43,72,40,270,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,91,294},new int[]{-53,277,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[277] = new State(-110);
    states[278] = new State(-115);
    states[279] = new State(new int[]{93,280,44,281,94,310});
    states[280] = new State(-97);
    states[281] = new State(new int[]{217,68,45,70,43,72,40,270,207,274,178,100,179,101,196,284,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,91,294},new int[]{-57,282,-53,283,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[282] = new State(-94);
    states[283] = new State(-104);
    states[284] = new State(new int[]{40,285,41,-129,94,-129,61,-129,60,-129,62,-129,212,-129,213,-129,214,-129,211,-129,209,-129,210,-129,218,-129,215,-129,38,-129,43,-129,45,-129,42,-129,47,-129,44,-129,93,-129});
    states[285] = new State(new int[]{94,-105,217,-107,45,-107,43,-107,40,-107,207,-107,178,-107,179,-107,196,-107,197,-107,204,-107,203,-107,201,-107,202,-107,205,-107,206,-107,198,-107,199,-107,200,-107,208,-107,91,-107},new int[]{-95,286,-96,289});
    states[286] = new State(new int[]{94,287});
    states[287] = new State(new int[]{41,288});
    states[288] = new State(-106);
    states[289] = new State(new int[]{217,68,45,70,43,72,40,270,207,274,178,100,179,101,196,284,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,91,294},new int[]{-25,290,-57,309,-53,283,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[290] = new State(new int[]{41,291,44,292,94,307});
    states[291] = new State(-108);
    states[292] = new State(new int[]{217,68,45,70,43,72,40,270,207,274,178,100,179,101,196,284,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,91,294},new int[]{-57,293,-53,283,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[293] = new State(-112);
    states[294] = new State(new int[]{94,304,93,306,217,-92,45,-92,43,-92,40,-92,207,-92,178,-92,179,-92,196,-92,197,-92,204,-92,203,-92,201,-92,202,-92,205,-92,206,-92,198,-92,199,-92,200,-92,208,-92,91,-92},new int[]{-94,295});
    states[295] = new State(new int[]{217,68,45,70,43,72,40,270,207,274,178,100,179,101,196,284,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,91,294},new int[]{-57,296,-53,283,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[296] = new State(-93);
    states[297] = new State(-116);
    states[298] = new State(new int[]{41,299,44,300,94,302});
    states[299] = new State(-101);
    states[300] = new State(new int[]{217,68,45,70,43,72,40,270,207,274,178,100,179,101,196,284,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,91,294},new int[]{-57,301,-53,283,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[301] = new State(-96);
    states[302] = new State(new int[]{41,303});
    states[303] = new State(-102);
    states[304] = new State(new int[]{93,305});
    states[305] = new State(-99);
    states[306] = new State(-100);
    states[307] = new State(new int[]{217,68,45,70,43,72,40,270,207,274,178,100,179,101,196,284,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,91,294},new int[]{-57,308,-53,283,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[308] = new State(-113);
    states[309] = new State(-111);
    states[310] = new State(new int[]{93,311});
    states[311] = new State(-98);
    states[312] = new State(-331);
    states[313] = new State(-332);
    states[314] = new State(-333);
    states[315] = new State(-334);
    states[316] = new State(new int[]{162,-55,163,-55,181,-55,182,-55,114,-55,59,-55,174,-55,94,-55,207,-55,169,-55,121,-55,127,-55,40,-52});
    states[317] = new State(-20);
    states[318] = new State(-21);
    states[319] = new State(-22);
    states[320] = new State(-23);
    states[321] = new State(-24);
    states[322] = new State(-25);
    states[323] = new State(-26);
    states[324] = new State(-27);
    states[325] = new State(-28);
    states[326] = new State(-29);
    states[327] = new State(-30);
    states[328] = new State(-31);
    states[329] = new State(-32);
    states[330] = new State(-33);
    states[331] = new State(-34);
    states[332] = new State(-35);
    states[333] = new State(-36);
    states[334] = new State(-37);
    states[335] = new State(-38);
    states[336] = new State(-39);
    states[337] = new State(-40);
    states[338] = new State(-56);
    states[339] = new State(new int[]{91,340});
    states[340] = new State(new int[]{94,361,217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-30,341,-1,365,-45,359,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[341] = new State(new int[]{93,342,44,357,217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-1,360,-45,359,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[342] = new State(new int[]{119,343});
    states[343] = new State(new int[]{129,317,128,318,130,319,131,320,132,321,133,322,134,323,135,324,136,325,137,326,138,327,140,328,141,329,142,330,143,331,139,332,146,333,147,334,148,335,149,336,150,337,207,347,144,349,145,353},new int[]{-41,344,-35,345,-40,346,-42,348});
    states[344] = new State(-66);
    states[345] = new State(-52);
    states[346] = new State(-53);
    states[347] = new State(-51);
    states[348] = new State(-54);
    states[349] = new State(new int[]{91,350,164,-88,171,-88,168,-88,170,-88,172,-88,173,-88,165,-88,166,-88,167,-88,126,-88,94,-88,96,-88,97,-88,100,-88,99,-88,105,-88,207,-88,208,-88,112,-88,180,-88,59,-88,162,-88,163,-88,181,-88,182,-88,114,-88,174,-88,169,-88,40,-88,121,-88,127,-88});
    states[350] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,351,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[351] = new State(new int[]{93,352,61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66});
    states[352] = new State(-86);
    states[353] = new State(new int[]{91,354,164,-89,171,-89,168,-89,170,-89,172,-89,173,-89,165,-89,166,-89,167,-89,126,-89,94,-89,96,-89,97,-89,100,-89,99,-89,105,-89,207,-89,208,-89,112,-89,180,-89,59,-89,162,-89,163,-89,181,-89,182,-89,114,-89,174,-89,169,-89,40,-89,121,-89,127,-89});
    states[354] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-45,355,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[355] = new State(new int[]{93,356,61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66});
    states[356] = new State(-87);
    states[357] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-1,358,-45,359,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[358] = new State(-18);
    states[359] = new State(new int[]{151,185,61,36,60,38,62,40,212,42,213,44,214,46,211,48,209,50,210,52,218,54,215,56,38,58,43,60,45,62,42,64,47,66});
    states[360] = new State(-19);
    states[361] = new State(new int[]{93,362});
    states[362] = new State(new int[]{119,363});
    states[363] = new State(new int[]{129,317,128,318,130,319,131,320,132,321,133,322,134,323,135,324,136,325,137,326,138,327,140,328,141,329,142,330,143,331,139,332,146,333,147,334,148,335,149,336,150,337,207,347,144,349,145,353},new int[]{-41,364,-35,345,-40,346,-42,348});
    states[364] = new State(-67);
    states[365] = new State(-17);
    states[366] = new State(-57);
    states[367] = new State(new int[]{121,368,94,370,207,372},new int[]{-32,369});
    states[368] = new State(-72);
    states[369] = new State(-70);
    states[370] = new State(new int[]{121,371});
    states[371] = new State(-75);
    states[372] = new State(new int[]{58,373});
    states[373] = new State(new int[]{129,317,128,318,130,319,131,320,132,321,133,322,134,323,135,324,136,325,137,326,138,327,140,328,141,329,142,330,143,331,139,332,146,333,147,334,148,335,149,336,150,337,118,339,120,381,40,463,207,347,144,349,145,353,152,477,160,478,153,479,158,480,159,481,161,482,154,483,155,484,156,485,157,486},new int[]{-76,374,-43,376,-35,316,-36,338,-37,366,-31,367,-39,387,-19,388,-38,468,-41,469,-40,474,-42,475,-44,476});
    states[374] = new State(new int[]{59,259,121,-124,94,-124,207,-124},new int[]{-91,375});
    states[375] = new State(-71);
    states[376] = new State(new int[]{162,312,163,313,181,314,182,315,114,-335,59,-335,121,-335,94,-335,207,-335,174,-335,169,-335,127,-335},new int[]{-78,377});
    states[377] = new State(new int[]{114,378,59,-63,121,-63,94,-63,207,-63,174,-63,169,-63,127,-63});
    states[378] = new State(-64,new int[]{-89,379});
    states[379] = new State(new int[]{217,68,45,70,43,72,40,270,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125,91,294},new int[]{-53,380,-45,269,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121,-21,278,-22,279,-23,297,-24,298});
    states[380] = new State(-65);
    states[381] = new State(new int[]{207,-68,94,-73},new int[]{-90,382,-92,384});
    states[382] = new State(new int[]{207,372},new int[]{-32,383});
    states[383] = new State(-69);
    states[384] = new State(new int[]{94,385});
    states[385] = new State(new int[]{121,386});
    states[386] = new State(-74);
    states[387] = new State(-58);
    states[388] = new State(new int[]{41,389,44,390,94,461,207,392,200,393,129,317,128,318,130,319,131,320,132,321,133,322,134,323,135,324,136,325,137,326,138,327,140,328,141,329,142,330,143,331,139,332,146,333,147,334,148,335,149,336,150,337,144,396,145,397,176,398,177,399,175,400,162,401,163,402,181,403,182,404,165,405,166,406,167,407,170,408,172,409,173,410,171,411,168,412,164,413,174,414,169,415,122,416,123,417,124,418,125,419,116,420,117,421,100,422,103,423,104,424,107,425,110,426,96,427,109,428,97,429,98,430,111,431,99,432,101,433,113,434,102,435,108,436,105,437,119,438,106,439,112,440,180,441,126,442,127,443,118,444,120,445,121,446,211,447,217,448,209,449,210,450,215,451,185,452,186,453,193,454,194,455,189,456,190,457,191,458,192,459},new int[]{-79,460,-80,394,-35,395});
    states[389] = new State(-82);
    states[390] = new State(new int[]{207,392,200,393,129,317,128,318,130,319,131,320,132,321,133,322,134,323,135,324,136,325,137,326,138,327,140,328,141,329,142,330,143,331,139,332,146,333,147,334,148,335,149,336,150,337,144,396,145,397,176,398,177,399,175,400,162,401,163,402,181,403,182,404,165,405,166,406,167,407,170,408,172,409,173,410,171,411,168,412,164,413,174,414,169,415,122,416,123,417,124,418,125,419,116,420,117,421,100,422,103,423,104,424,107,425,110,426,96,427,109,428,97,429,98,430,111,431,99,432,101,433,113,434,102,435,108,436,105,437,119,438,106,439,112,440,180,441,126,442,127,443,118,444,120,445,121,446,211,447,217,448,209,449,210,450,215,451,185,452,186,453,193,454,194,455,189,456,190,457,191,458,192,459},new int[]{-79,391,-80,394,-35,395});
    states[391] = new State(-80);
    states[392] = new State(-76);
    states[393] = new State(-77);
    states[394] = new State(-78);
    states[395] = new State(-336);
    states[396] = new State(-337);
    states[397] = new State(-338);
    states[398] = new State(-339);
    states[399] = new State(-340);
    states[400] = new State(-341);
    states[401] = new State(-342);
    states[402] = new State(-343);
    states[403] = new State(-344);
    states[404] = new State(-345);
    states[405] = new State(-346);
    states[406] = new State(-347);
    states[407] = new State(-348);
    states[408] = new State(-349);
    states[409] = new State(-350);
    states[410] = new State(-351);
    states[411] = new State(-352);
    states[412] = new State(-353);
    states[413] = new State(-354);
    states[414] = new State(-355);
    states[415] = new State(-356);
    states[416] = new State(-357);
    states[417] = new State(-358);
    states[418] = new State(-359);
    states[419] = new State(-360);
    states[420] = new State(-361);
    states[421] = new State(-362);
    states[422] = new State(-363);
    states[423] = new State(-364);
    states[424] = new State(-365);
    states[425] = new State(-366);
    states[426] = new State(-367);
    states[427] = new State(-368);
    states[428] = new State(-369);
    states[429] = new State(-370);
    states[430] = new State(-371);
    states[431] = new State(-372);
    states[432] = new State(-373);
    states[433] = new State(-374);
    states[434] = new State(-375);
    states[435] = new State(-376);
    states[436] = new State(-377);
    states[437] = new State(-378);
    states[438] = new State(-379);
    states[439] = new State(-380);
    states[440] = new State(-381);
    states[441] = new State(-382);
    states[442] = new State(-383);
    states[443] = new State(-384);
    states[444] = new State(-385);
    states[445] = new State(-386);
    states[446] = new State(-387);
    states[447] = new State(-388);
    states[448] = new State(-389);
    states[449] = new State(-390);
    states[450] = new State(-391);
    states[451] = new State(-392);
    states[452] = new State(-393);
    states[453] = new State(-394);
    states[454] = new State(-395);
    states[455] = new State(-396);
    states[456] = new State(-397);
    states[457] = new State(-398);
    states[458] = new State(-399);
    states[459] = new State(-400);
    states[460] = new State(-81);
    states[461] = new State(new int[]{41,462});
    states[462] = new State(-83);
    states[463] = new State(new int[]{94,465,41,467,207,392,200,393,129,317,128,318,130,319,131,320,132,321,133,322,134,323,135,324,136,325,137,326,138,327,140,328,141,329,142,330,143,331,139,332,146,333,147,334,148,335,149,336,150,337,144,396,145,397,176,398,177,399,175,400,162,401,163,402,181,403,182,404,165,405,166,406,167,407,170,408,172,409,173,410,171,411,168,412,164,413,174,414,169,415,122,416,123,417,124,418,125,419,116,420,117,421,100,422,103,423,104,424,107,425,110,426,96,427,109,428,97,429,98,430,111,431,99,432,101,433,113,434,102,435,108,436,105,437,119,438,106,439,112,440,180,441,126,442,127,443,118,444,120,445,121,446,211,447,217,448,209,449,210,450,215,451,185,452,186,453,193,454,194,455,189,456,190,457,191,458,192,459},new int[]{-79,464,-80,394,-35,395});
    states[464] = new State(-79);
    states[465] = new State(new int[]{41,466});
    states[466] = new State(-84);
    states[467] = new State(-85);
    states[468] = new State(-59);
    states[469] = new State(new int[]{40,470});
    states[470] = new State(-90,new int[]{-93,471});
    states[471] = new State(new int[]{217,68,45,70,43,72,40,74,207,81,178,100,179,101,196,102,197,103,204,104,203,105,201,106,202,107,205,108,206,109,198,110,199,111,200,112,208,125},new int[]{-1,472,-45,359,-70,80,-69,92,-46,99,-50,113,-52,114,-51,117,-74,121});
    states[472] = new State(new int[]{41,473});
    states[473] = new State(-91);
    states[474] = new State(new int[]{40,-53,162,-60,163,-60,181,-60,182,-60,114,-60,59,-60,174,-60,94,-60,207,-60,169,-60,121,-60,127,-60});
    states[475] = new State(new int[]{40,-54,162,-61,163,-61,181,-61,182,-61,114,-61,59,-61,174,-61,94,-61,207,-61,169,-61,121,-61,127,-61});
    states[476] = new State(-62);
    states[477] = new State(-41);
    states[478] = new State(-42);
    states[479] = new State(-43);
    states[480] = new State(-44);
    states[481] = new State(-45);
    states[482] = new State(-46);
    states[483] = new State(-47);
    states[484] = new State(-48);
    states[485] = new State(-49);
    states[486] = new State(-50);
    states[487] = new State(new int[]{207,488,129,317,128,318,130,319,131,320,132,321,133,322,134,323,135,324,136,325,137,326,138,327,140,328,141,329,142,330,143,331,139,332,146,333,147,334,148,335,149,336,150,337,144,396,145,397,176,398,177,399,175,400,162,401,163,402,181,403,182,404,165,405,166,406,167,407,170,408,172,409,173,410,171,411,168,412,164,413,174,414,169,415,122,416,123,417,124,418,125,419,116,420,117,421,100,422,103,423,104,424,107,425,110,426,96,427,109,428,97,429,98,430,111,431,99,432,101,433,113,434,102,435,108,436,105,437,119,438,106,439,112,440,180,441,126,442,127,443,118,444,120,445,121,446,211,447,217,448,209,449,210,450,215,451,185,452,186,453,193,454,194,455,189,456,190,457,191,458,192,459},new int[]{-80,489,-35,395});
    states[488] = new State(-14);
    states[489] = new State(-15);
    states[490] = new State(-16);
    states[491] = new State(new int[]{169,492,58,-13,44,-13,207,-13});
    states[492] = new State(new int[]{208,493});
    states[493] = new State(-321,new int[]{-126,494});
    states[494] = new State(new int[]{58,495});
    states[495] = new State(new int[]{129,317,128,318,130,319,131,320,132,321,133,322,134,323,135,324,136,325,137,326,138,327,140,328,141,329,142,330,143,331,139,332,146,333,147,334,148,335,149,336,150,337,118,339,120,381,40,463,207,347,144,349,145,353,152,477,160,478,153,479,158,480,159,481,161,482,154,483,155,484,156,485,157,486},new int[]{-76,496,-43,376,-35,316,-36,338,-37,366,-31,367,-39,387,-19,388,-38,468,-41,469,-40,474,-42,475,-44,476});
    states[496] = new State(-322);
    states[497] = new State(new int[]{208,498});
    states[498] = new State(-323,new int[]{-127,499});
    states[499] = new State(new int[]{58,500});
    states[500] = new State(new int[]{129,317,128,318,130,319,131,320,132,321,133,322,134,323,135,324,136,325,137,326,138,327,140,328,141,329,142,330,143,331,139,332,146,333,147,334,148,335,149,336,150,337,118,339,120,381,40,463,207,347,144,349,145,353,152,477,160,478,153,479,158,480,159,481,161,482,154,483,155,484,156,485,157,486},new int[]{-76,501,-43,376,-35,316,-36,338,-37,366,-31,367,-39,387,-19,388,-38,468,-41,469,-40,474,-42,475,-44,476});
    states[501] = new State(-324);
    states[502] = new State(new int[]{59,259,174,-124,94,-124,207,-124,169,-124},new int[]{-91,503});
    states[503] = new State(-314);
    states[504] = new State(new int[]{174,505});
    states[505] = new State(-278);
    states[506] = new State(new int[]{175,507,207,-325,169,-325});
    states[507] = new State(-329);
    states[508] = new State(-326);
    states[509] = new State(new int[]{176,510,207,-327,169,-327});
    states[510] = new State(-328);
    states[511] = new State(-301);
    states[512] = new State(new int[]{94,516,176,506,177,508,175,509,207,-330,169,-330},new int[]{-77,513});
    states[513] = new State(-288,new int[]{-121,514});
    states[514] = new State(new int[]{207,491,169,497},new int[]{-12,515,-13,255,-11,502,-18,262});
    states[515] = new State(-289);
    states[516] = new State(new int[]{174,517});
    states[517] = new State(-290);
    states[518] = new State(-302);
    states[519] = new State(new int[]{94,523,176,506,177,508,175,509,207,-330,169,-330},new int[]{-77,520});
    states[520] = new State(-291,new int[]{-122,521});
    states[521] = new State(new int[]{207,491,169,497},new int[]{-12,522,-13,255,-11,502,-18,262});
    states[522] = new State(-292);
    states[523] = new State(new int[]{174,524});
    states[524] = new State(-293);
    states[525] = new State(-303);
    states[526] = new State(new int[]{94,530,176,506,177,508,175,509,207,-330,169,-330},new int[]{-77,527});
    states[527] = new State(-282,new int[]{-119,528});
    states[528] = new State(new int[]{207,491,169,497},new int[]{-12,529,-13,255,-11,502,-18,262});
    states[529] = new State(-283);
    states[530] = new State(new int[]{174,531});
    states[531] = new State(-284);
    states[532] = new State(-304);
    states[533] = new State(new int[]{94,537,176,506,177,508,175,509,207,-330,169,-330},new int[]{-77,534});
    states[534] = new State(-294,new int[]{-123,535});
    states[535] = new State(new int[]{207,491,169,497},new int[]{-12,536,-13,255,-11,502,-18,262});
    states[536] = new State(-295);
    states[537] = new State(new int[]{174,538});
    states[538] = new State(-296);
    states[539] = new State(-305);
    states[540] = new State(new int[]{94,544,176,506,177,508,175,509,207,-330,169,-330},new int[]{-77,541});
    states[541] = new State(-297,new int[]{-124,542});
    states[542] = new State(new int[]{207,491,169,497},new int[]{-12,543,-13,255,-11,502,-18,262});
    states[543] = new State(-298);
    states[544] = new State(new int[]{174,545});
    states[545] = new State(-299);
    states[546] = new State(-306);
    states[547] = new State(new int[]{94,551,176,506,177,508,175,509,207,-330,169,-330},new int[]{-77,548});
    states[548] = new State(-273,new int[]{-116,549});
    states[549] = new State(new int[]{207,491,169,497},new int[]{-12,550,-13,255,-11,502,-18,262});
    states[550] = new State(-274);
    states[551] = new State(new int[]{174,552});
    states[552] = new State(-275);
    states[553] = new State(-307);
    states[554] = new State(new int[]{94,558,176,506,177,508,175,509,207,-330,169,-330},new int[]{-77,555});
    states[555] = new State(-279,new int[]{-118,556});
    states[556] = new State(new int[]{207,491,169,497},new int[]{-12,557,-13,255,-11,502,-18,262});
    states[557] = new State(-280);
    states[558] = new State(new int[]{174,559});
    states[559] = new State(-281);
    states[560] = new State(-308);
    states[561] = new State(new int[]{94,565,176,506,177,508,175,509,207,-330,169,-330},new int[]{-77,562});
    states[562] = new State(-285,new int[]{-120,563});
    states[563] = new State(new int[]{207,491,169,497},new int[]{-12,564,-13,255,-11,502,-18,262});
    states[564] = new State(-286);
    states[565] = new State(new int[]{174,566});
    states[566] = new State(-287);
    states[567] = new State(-309);
    states[568] = new State(new int[]{94,579,207,-120},new int[]{-98,569,-99,581});
    states[569] = new State(new int[]{127,570,94,571,207,574},new int[]{-100,573});
    states[570] = new State(-117);
    states[571] = new State(new int[]{127,572});
    states[572] = new State(-118);
    states[573] = new State(-122);
    states[574] = new State(new int[]{58,575});
    states[575] = new State(-125,new int[]{-101,576});
    states[576] = new State(new int[]{129,317,128,318,130,319,131,320,132,321,133,322,134,323,135,324,136,325,137,326,138,327,140,328,141,329,142,330,143,331,139,332,146,333,147,334,148,335,149,336,150,337,118,339,120,381,40,463,207,347,144,349,145,353,152,477,160,478,153,479,158,480,159,481,161,482,154,483,155,484,156,485,157,486},new int[]{-76,577,-43,376,-35,316,-36,338,-37,366,-31,367,-39,387,-19,388,-38,468,-41,469,-40,474,-42,475,-44,476});
    states[577] = new State(new int[]{59,259,127,-124,94,-124,207,-124},new int[]{-91,578});
    states[578] = new State(-126);
    states[579] = new State(new int[]{127,580});
    states[580] = new State(-119);
    states[581] = new State(new int[]{207,574},new int[]{-100,582});
    states[582] = new State(-121);
    states[583] = new State(-310);
    states[584] = new State(-7);
    states[585] = new State(new int[]{207,586});
    states[586] = new State(-268,new int[]{-113,587});
    states[587] = new State(new int[]{164,251,171,512,168,519,170,526,172,533,173,540,165,547,166,554,167,561,126,568,94,-313,96,-313,97,-313,100,-313,99,-313,105,-313,207,-313,208,-313,112,-313,180,-313,59,-313},new int[]{-72,588,-73,248,-68,583,-58,250,-59,511,-60,518,-61,525,-62,532,-63,539,-64,546,-65,553,-66,560,-67,567});
    states[588] = new State(-269,new int[]{-114,589});
    states[589] = new State(new int[]{94,232,96,-183,97,-183,100,-183,99,-183,105,-183,207,-183,208,-183,112,-183,180,-183,59,-183},new int[]{-8,590,-2,591,-103,201});
    states[590] = new State(-270);
    states[591] = new State(new int[]{125,592,94,593,96,21,97,28,100,135,99,144,105,154,207,81,208,125,112,172,180,173,59,-200},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[592] = new State(-261);
    states[593] = new State(new int[]{125,594});
    states[594] = new State(-262);
    states[595] = new State(-8);
    states[596] = new State(new int[]{207,597});
    states[597] = new State(-271,new int[]{-115,598});
    states[598] = new State(new int[]{164,251,171,512,168,519,170,526,172,533,173,540,165,547,166,554,167,561,126,568,94,-313,96,-313,97,-313,100,-313,99,-313,105,-313,207,-313,208,-313,112,-313,180,-313,59,-313},new int[]{-72,599,-73,248,-68,583,-58,250,-59,511,-60,518,-61,525,-62,532,-63,539,-64,546,-65,553,-66,560,-67,567});
    states[599] = new State(new int[]{94,232,96,-183,97,-183,100,-183,99,-183,105,-183,207,-183,208,-183,112,-183,180,-183,59,-183},new int[]{-9,600,-2,601,-103,201});
    states[600] = new State(-272);
    states[601] = new State(new int[]{117,602,94,603,96,21,97,28,100,135,99,144,105,154,207,81,208,125,112,172,180,173,59,-200},new int[]{-26,17,-27,166,-50,167,-52,114,-51,117,-74,121,-70,175,-69,92});
    states[602] = new State(-263);
    states[603] = new State(new int[]{117,604});
    states[604] = new State(-264);
    states[605] = new State(-9);
    states[606] = new State(-4);

    for (int sNo = 0; sNo < states.Length; sNo++) states[sNo].number = sNo;

    rules[1] = new Rule(-83, new int[]{-82,95});
    rules[2] = new Rule(-84, new int[]{});
    rules[3] = new Rule(-82, new int[]{-84,-85});
    rules[4] = new Rule(-85, new int[]{-86});
    rules[5] = new Rule(-85, new int[]{-85,-86});
    rules[6] = new Rule(-86, new int[]{-34});
    rules[7] = new Rule(-86, new int[]{-87});
    rules[8] = new Rule(-86, new int[]{-88});
    rules[9] = new Rule(-86, new int[]{-67});
    rules[10] = new Rule(-81, new int[]{114});
    rules[11] = new Rule(-81, new int[]{115});
    rules[12] = new Rule(-1, new int[]{-45,151,-45});
    rules[13] = new Rule(-18, new int[]{207});
    rules[14] = new Rule(-18, new int[]{-18,44,207});
    rules[15] = new Rule(-18, new int[]{-18,44,-80});
    rules[16] = new Rule(-18, new int[]{-18,207});
    rules[17] = new Rule(-30, new int[]{-1});
    rules[18] = new Rule(-30, new int[]{-30,44,-1});
    rules[19] = new Rule(-30, new int[]{-30,-1});
    rules[20] = new Rule(-35, new int[]{129});
    rules[21] = new Rule(-35, new int[]{128});
    rules[22] = new Rule(-35, new int[]{130});
    rules[23] = new Rule(-35, new int[]{131});
    rules[24] = new Rule(-35, new int[]{132});
    rules[25] = new Rule(-35, new int[]{133});
    rules[26] = new Rule(-35, new int[]{134});
    rules[27] = new Rule(-35, new int[]{135});
    rules[28] = new Rule(-35, new int[]{136});
    rules[29] = new Rule(-35, new int[]{137});
    rules[30] = new Rule(-35, new int[]{138});
    rules[31] = new Rule(-35, new int[]{140});
    rules[32] = new Rule(-35, new int[]{141});
    rules[33] = new Rule(-35, new int[]{142});
    rules[34] = new Rule(-35, new int[]{143});
    rules[35] = new Rule(-35, new int[]{139});
    rules[36] = new Rule(-35, new int[]{146});
    rules[37] = new Rule(-35, new int[]{147});
    rules[38] = new Rule(-35, new int[]{148});
    rules[39] = new Rule(-35, new int[]{149});
    rules[40] = new Rule(-35, new int[]{150});
    rules[41] = new Rule(-44, new int[]{152});
    rules[42] = new Rule(-44, new int[]{160});
    rules[43] = new Rule(-44, new int[]{153});
    rules[44] = new Rule(-44, new int[]{158});
    rules[45] = new Rule(-44, new int[]{159});
    rules[46] = new Rule(-44, new int[]{161});
    rules[47] = new Rule(-44, new int[]{154});
    rules[48] = new Rule(-44, new int[]{155});
    rules[49] = new Rule(-44, new int[]{156});
    rules[50] = new Rule(-44, new int[]{157});
    rules[51] = new Rule(-40, new int[]{207});
    rules[52] = new Rule(-41, new int[]{-35});
    rules[53] = new Rule(-41, new int[]{-40});
    rules[54] = new Rule(-41, new int[]{-42});
    rules[55] = new Rule(-43, new int[]{-35});
    rules[56] = new Rule(-43, new int[]{-36});
    rules[57] = new Rule(-43, new int[]{-37});
    rules[58] = new Rule(-43, new int[]{-39});
    rules[59] = new Rule(-43, new int[]{-38});
    rules[60] = new Rule(-43, new int[]{-40});
    rules[61] = new Rule(-43, new int[]{-42});
    rules[62] = new Rule(-43, new int[]{-44});
    rules[63] = new Rule(-76, new int[]{-43,-78});
    rules[64] = new Rule(-89, new int[]{});
    rules[65] = new Rule(-76, new int[]{-43,-78,114,-89,-53});
    rules[66] = new Rule(-36, new int[]{118,91,-30,93,119,-41});
    rules[67] = new Rule(-36, new int[]{118,91,94,93,119,-41});
    rules[68] = new Rule(-90, new int[]{});
    rules[69] = new Rule(-31, new int[]{120,-90,-32});
    rules[70] = new Rule(-31, new int[]{-31,-32});
    rules[71] = new Rule(-32, new int[]{207,58,-76,-91});
    rules[72] = new Rule(-37, new int[]{-31,121});
    rules[73] = new Rule(-92, new int[]{});
    rules[74] = new Rule(-37, new int[]{120,-92,94,121});
    rules[75] = new Rule(-37, new int[]{-31,94,121});
    rules[76] = new Rule(-79, new int[]{207});
    rules[77] = new Rule(-79, new int[]{200});
    rules[78] = new Rule(-79, new int[]{-80});
    rules[79] = new Rule(-19, new int[]{40,-79});
    rules[80] = new Rule(-19, new int[]{-19,44,-79});
    rules[81] = new Rule(-19, new int[]{-19,-79});
    rules[82] = new Rule(-39, new int[]{-19,41});
    rules[83] = new Rule(-39, new int[]{-19,94,41});
    rules[84] = new Rule(-39, new int[]{40,94,41});
    rules[85] = new Rule(-39, new int[]{40,41});
    rules[86] = new Rule(-42, new int[]{144,91,-45,93});
    rules[87] = new Rule(-42, new int[]{145,91,-45,93});
    rules[88] = new Rule(-42, new int[]{144});
    rules[89] = new Rule(-42, new int[]{145});
    rules[90] = new Rule(-93, new int[]{});
    rules[91] = new Rule(-38, new int[]{-41,40,-93,-1,41});
    rules[92] = new Rule(-94, new int[]{});
    rules[93] = new Rule(-22, new int[]{91,-94,-57});
    rules[94] = new Rule(-22, new int[]{-22,44,-57});
    rules[95] = new Rule(-24, new int[]{40,-57});
    rules[96] = new Rule(-24, new int[]{-24,44,-57});
    rules[97] = new Rule(-21, new int[]{-22,93});
    rules[98] = new Rule(-21, new int[]{-22,94,93});
    rules[99] = new Rule(-21, new int[]{91,94,93});
    rules[100] = new Rule(-21, new int[]{91,93});
    rules[101] = new Rule(-23, new int[]{-24,41});
    rules[102] = new Rule(-23, new int[]{-24,94,41});
    rules[103] = new Rule(-23, new int[]{40,41});
    rules[104] = new Rule(-57, new int[]{-53});
    rules[105] = new Rule(-95, new int[]{});
    rules[106] = new Rule(-57, new int[]{196,40,-95,94,41});
    rules[107] = new Rule(-96, new int[]{});
    rules[108] = new Rule(-57, new int[]{196,40,-96,-25,41});
    rules[109] = new Rule(-97, new int[]{});
    rules[110] = new Rule(-57, new int[]{207,-97,114,-53});
    rules[111] = new Rule(-25, new int[]{-57});
    rules[112] = new Rule(-25, new int[]{-25,44,-57});
    rules[113] = new Rule(-25, new int[]{-25,94,-57});
    rules[114] = new Rule(-53, new int[]{-45});
    rules[115] = new Rule(-53, new int[]{-21});
    rules[116] = new Rule(-53, new int[]{-23});
    rules[117] = new Rule(-67, new int[]{126,-98,127});
    rules[118] = new Rule(-67, new int[]{126,-98,94,127});
    rules[119] = new Rule(-67, new int[]{126,94,127});
    rules[120] = new Rule(-99, new int[]{});
    rules[121] = new Rule(-98, new int[]{-99,-100});
    rules[122] = new Rule(-98, new int[]{-98,-100});
    rules[123] = new Rule(-91, new int[]{59});
    rules[124] = new Rule(-91, new int[]{});
    rules[125] = new Rule(-101, new int[]{});
    rules[126] = new Rule(-100, new int[]{207,58,-101,-76,-91});
    rules[127] = new Rule(-46, new int[]{178});
    rules[128] = new Rule(-46, new int[]{179});
    rules[129] = new Rule(-46, new int[]{196});
    rules[130] = new Rule(-46, new int[]{197});
    rules[131] = new Rule(-46, new int[]{204});
    rules[132] = new Rule(-46, new int[]{203});
    rules[133] = new Rule(-46, new int[]{201});
    rules[134] = new Rule(-46, new int[]{202});
    rules[135] = new Rule(-46, new int[]{205});
    rules[136] = new Rule(-46, new int[]{206});
    rules[137] = new Rule(-46, new int[]{198});
    rules[138] = new Rule(-46, new int[]{199});
    rules[139] = new Rule(-46, new int[]{200});
    rules[140] = new Rule(-50, new int[]{-52});
    rules[141] = new Rule(-50, new int[]{208});
    rules[142] = new Rule(-52, new int[]{-51});
    rules[143] = new Rule(-52, new int[]{-74,93});
    rules[144] = new Rule(-52, new int[]{-51,91,94,93});
    rules[145] = new Rule(-102, new int[]{});
    rules[146] = new Rule(-74, new int[]{-51,91,-102,-45});
    rules[147] = new Rule(-74, new int[]{-74,44,-45});
    rules[148] = new Rule(-51, new int[]{207});
    rules[149] = new Rule(-51, new int[]{-52,46,207});
    rules[150] = new Rule(-45, new int[]{217,-45});
    rules[151] = new Rule(-45, new int[]{45,-45});
    rules[152] = new Rule(-45, new int[]{43,-45});
    rules[153] = new Rule(-45, new int[]{-45,61,-45});
    rules[154] = new Rule(-45, new int[]{-45,60,-45});
    rules[155] = new Rule(-45, new int[]{-45,62,-45});
    rules[156] = new Rule(-45, new int[]{-45,212,-45});
    rules[157] = new Rule(-45, new int[]{-45,213,-45});
    rules[158] = new Rule(-45, new int[]{-45,214,-45});
    rules[159] = new Rule(-45, new int[]{-45,211,-45});
    rules[160] = new Rule(-45, new int[]{-45,209,-45});
    rules[161] = new Rule(-45, new int[]{-45,210,-45});
    rules[162] = new Rule(-45, new int[]{-45,218,-45});
    rules[163] = new Rule(-45, new int[]{-45,215,-45});
    rules[164] = new Rule(-45, new int[]{-45,38,-45});
    rules[165] = new Rule(-45, new int[]{-45,43,-45});
    rules[166] = new Rule(-45, new int[]{-45,45,-45});
    rules[167] = new Rule(-45, new int[]{-45,42,-45});
    rules[168] = new Rule(-45, new int[]{-45,47,-45});
    rules[169] = new Rule(-45, new int[]{40,-45,41});
    rules[170] = new Rule(-45, new int[]{40,-45,94});
    rules[171] = new Rule(-45, new int[]{-70});
    rules[172] = new Rule(-45, new int[]{-46});
    rules[173] = new Rule(-45, new int[]{-50});
    rules[174] = new Rule(-45, new int[]{40,94,41});
    rules[175] = new Rule(-71, new int[]{-45});
    rules[176] = new Rule(-71, new int[]{207,-81,-45});
    rules[177] = new Rule(-71, new int[]{217,207,-81,-45});
    rules[178] = new Rule(-69, new int[]{207,40,-71});
    rules[179] = new Rule(-69, new int[]{-69,44,-71});
    rules[180] = new Rule(-70, new int[]{207,40,41});
    rules[181] = new Rule(-70, new int[]{207,40,94,41});
    rules[182] = new Rule(-70, new int[]{-69,41});
    rules[183] = new Rule(-103, new int[]{});
    rules[184] = new Rule(-2, new int[]{-103,-26,59});
    rules[185] = new Rule(-2, new int[]{-2,-26,59});
    rules[186] = new Rule(-2, new int[]{94,59});
    rules[187] = new Rule(-26, new int[]{96,-47,-4});
    rules[188] = new Rule(-104, new int[]{});
    rules[189] = new Rule(-26, new int[]{97,-104,-28});
    rules[190] = new Rule(-105, new int[]{});
    rules[191] = new Rule(-26, new int[]{100,-48,-2,-105,-15,-3,110});
    rules[192] = new Rule(-106, new int[]{});
    rules[193] = new Rule(-26, new int[]{99,-55,-81,-75,-106,-5});
    rules[194] = new Rule(-26, new int[]{105,-49,-16,106});
    rules[195] = new Rule(-26, new int[]{-27});
    rules[196] = new Rule(-26, new int[]{112});
    rules[197] = new Rule(-26, new int[]{180});
    rules[198] = new Rule(-26, new int[]{180,-45});
    rules[199] = new Rule(-26, new int[]{-70});
    rules[200] = new Rule(-26, new int[]{});
    rules[201] = new Rule(-4, new int[]{-2,109});
    rules[202] = new Rule(-4, new int[]{-2,94,109});
    rules[203] = new Rule(-4, new int[]{94,109});
    rules[204] = new Rule(-28, new int[]{-2,98,-54});
    rules[205] = new Rule(-28, new int[]{-2,94,98,-54});
    rules[206] = new Rule(-28, new int[]{94,111});
    rules[207] = new Rule(-5, new int[]{-2,108});
    rules[208] = new Rule(-5, new int[]{-2,94,108});
    rules[209] = new Rule(-5, new int[]{94,108});
    rules[210] = new Rule(-47, new int[]{-45,102});
    rules[211] = new Rule(-47, new int[]{94,102});
    rules[212] = new Rule(-47, new int[]{-45});
    rules[213] = new Rule(-48, new int[]{-45,103});
    rules[214] = new Rule(-48, new int[]{94,103});
    rules[215] = new Rule(-48, new int[]{-45});
    rules[216] = new Rule(-54, new int[]{-45,111});
    rules[217] = new Rule(-54, new int[]{94,111});
    rules[218] = new Rule(-54, new int[]{-45});
    rules[219] = new Rule(-49, new int[]{-45,119});
    rules[220] = new Rule(-49, new int[]{94,119});
    rules[221] = new Rule(-49, new int[]{-45});
    rules[222] = new Rule(-55, new int[]{-50});
    rules[223] = new Rule(-107, new int[]{});
    rules[224] = new Rule(-75, new int[]{-45,101,-107,-45,-56,102});
    rules[225] = new Rule(-108, new int[]{});
    rules[226] = new Rule(-75, new int[]{94,101,-108,-45,-56,102});
    rules[227] = new Rule(-75, new int[]{-45,101,94,102});
    rules[228] = new Rule(-75, new int[]{94,102});
    rules[229] = new Rule(-109, new int[]{});
    rules[230] = new Rule(-56, new int[]{113,-109,-45});
    rules[231] = new Rule(-56, new int[]{});
    rules[232] = new Rule(-3, new int[]{104,-2});
    rules[233] = new Rule(-3, new int[]{104,94});
    rules[234] = new Rule(-3, new int[]{});
    rules[235] = new Rule(-15, new int[]{-14});
    rules[236] = new Rule(-15, new int[]{});
    rules[237] = new Rule(-6, new int[]{104,-10});
    rules[238] = new Rule(-6, new int[]{104,-10,94});
    rules[239] = new Rule(-110, new int[]{});
    rules[240] = new Rule(-10, new int[]{-110,-26,59});
    rules[241] = new Rule(-10, new int[]{-10,-26,59});
    rules[242] = new Rule(-10, new int[]{94,59});
    rules[243] = new Rule(-33, new int[]{195,-20,58,-10});
    rules[244] = new Rule(-33, new int[]{195,94,58,-10});
    rules[245] = new Rule(-33, new int[]{195,-20,-10});
    rules[246] = new Rule(-33, new int[]{-6});
    rules[247] = new Rule(-17, new int[]{-33});
    rules[248] = new Rule(-17, new int[]{-17,-33});
    rules[249] = new Rule(-16, new int[]{-17});
    rules[250] = new Rule(-16, new int[]{});
    rules[251] = new Rule(-29, new int[]{-45});
    rules[252] = new Rule(-29, new int[]{-1});
    rules[253] = new Rule(-20, new int[]{-29});
    rules[254] = new Rule(-20, new int[]{-20,44,-29});
    rules[255] = new Rule(-14, new int[]{107,-48,-2});
    rules[256] = new Rule(-14, new int[]{-14,107,-48,-2});
    rules[257] = new Rule(-27, new int[]{-50,114,-45});
    rules[258] = new Rule(-27, new int[]{-50,61,-45});
    rules[259] = new Rule(-7, new int[]{-2,123});
    rules[260] = new Rule(-7, new int[]{-2,94,123});
    rules[261] = new Rule(-8, new int[]{-2,125});
    rules[262] = new Rule(-8, new int[]{-2,94,125});
    rules[263] = new Rule(-9, new int[]{-2,117});
    rules[264] = new Rule(-9, new int[]{-2,94,117});
    rules[265] = new Rule(-111, new int[]{});
    rules[266] = new Rule(-112, new int[]{});
    rules[267] = new Rule(-34, new int[]{122,207,58,-41,-111,-72,-112,-7});
    rules[268] = new Rule(-113, new int[]{});
    rules[269] = new Rule(-114, new int[]{});
    rules[270] = new Rule(-87, new int[]{124,207,-113,-72,-114,-8});
    rules[271] = new Rule(-115, new int[]{});
    rules[272] = new Rule(-88, new int[]{116,207,-115,-72,-9});
    rules[273] = new Rule(-116, new int[]{});
    rules[274] = new Rule(-64, new int[]{165,-77,-116,-12});
    rules[275] = new Rule(-64, new int[]{165,94,174});
    rules[276] = new Rule(-117, new int[]{});
    rules[277] = new Rule(-58, new int[]{164,-77,-117,-12});
    rules[278] = new Rule(-58, new int[]{164,94,174});
    rules[279] = new Rule(-118, new int[]{});
    rules[280] = new Rule(-65, new int[]{166,-77,-118,-12});
    rules[281] = new Rule(-65, new int[]{166,94,174});
    rules[282] = new Rule(-119, new int[]{});
    rules[283] = new Rule(-61, new int[]{170,-77,-119,-12});
    rules[284] = new Rule(-61, new int[]{170,94,174});
    rules[285] = new Rule(-120, new int[]{});
    rules[286] = new Rule(-66, new int[]{167,-77,-120,-12});
    rules[287] = new Rule(-66, new int[]{167,94,174});
    rules[288] = new Rule(-121, new int[]{});
    rules[289] = new Rule(-59, new int[]{171,-77,-121,-12});
    rules[290] = new Rule(-59, new int[]{171,94,174});
    rules[291] = new Rule(-122, new int[]{});
    rules[292] = new Rule(-60, new int[]{168,-77,-122,-12});
    rules[293] = new Rule(-60, new int[]{168,94,174});
    rules[294] = new Rule(-123, new int[]{});
    rules[295] = new Rule(-62, new int[]{172,-77,-123,-12});
    rules[296] = new Rule(-62, new int[]{172,94,174});
    rules[297] = new Rule(-124, new int[]{});
    rules[298] = new Rule(-63, new int[]{173,-77,-124,-12});
    rules[299] = new Rule(-63, new int[]{173,94,174});
    rules[300] = new Rule(-68, new int[]{-58});
    rules[301] = new Rule(-68, new int[]{-59});
    rules[302] = new Rule(-68, new int[]{-60});
    rules[303] = new Rule(-68, new int[]{-61});
    rules[304] = new Rule(-68, new int[]{-62});
    rules[305] = new Rule(-68, new int[]{-63});
    rules[306] = new Rule(-68, new int[]{-64});
    rules[307] = new Rule(-68, new int[]{-65});
    rules[308] = new Rule(-68, new int[]{-66});
    rules[309] = new Rule(-68, new int[]{-67});
    rules[310] = new Rule(-73, new int[]{-68});
    rules[311] = new Rule(-73, new int[]{-73,-68});
    rules[312] = new Rule(-72, new int[]{-73});
    rules[313] = new Rule(-72, new int[]{});
    rules[314] = new Rule(-13, new int[]{-11,-91});
    rules[315] = new Rule(-13, new int[]{-13,-11,-91});
    rules[316] = new Rule(-12, new int[]{-13,174});
    rules[317] = new Rule(-12, new int[]{-13,94,174});
    rules[318] = new Rule(-11, new int[]{-18,58,-43,-78});
    rules[319] = new Rule(-125, new int[]{});
    rules[320] = new Rule(-11, new int[]{-18,58,-43,-78,-125,114,-53});
    rules[321] = new Rule(-126, new int[]{});
    rules[322] = new Rule(-11, new int[]{207,169,208,-126,58,-76});
    rules[323] = new Rule(-127, new int[]{});
    rules[324] = new Rule(-11, new int[]{169,208,-127,58,-76});
    rules[325] = new Rule(-77, new int[]{176});
    rules[326] = new Rule(-77, new int[]{177});
    rules[327] = new Rule(-77, new int[]{175});
    rules[328] = new Rule(-77, new int[]{175,176});
    rules[329] = new Rule(-77, new int[]{176,175});
    rules[330] = new Rule(-77, new int[]{});
    rules[331] = new Rule(-78, new int[]{162});
    rules[332] = new Rule(-78, new int[]{163});
    rules[333] = new Rule(-78, new int[]{181});
    rules[334] = new Rule(-78, new int[]{182});
    rules[335] = new Rule(-78, new int[]{});
    rules[336] = new Rule(-80, new int[]{-35});
    rules[337] = new Rule(-80, new int[]{144});
    rules[338] = new Rule(-80, new int[]{145});
    rules[339] = new Rule(-80, new int[]{176});
    rules[340] = new Rule(-80, new int[]{177});
    rules[341] = new Rule(-80, new int[]{175});
    rules[342] = new Rule(-80, new int[]{162});
    rules[343] = new Rule(-80, new int[]{163});
    rules[344] = new Rule(-80, new int[]{181});
    rules[345] = new Rule(-80, new int[]{182});
    rules[346] = new Rule(-80, new int[]{165});
    rules[347] = new Rule(-80, new int[]{166});
    rules[348] = new Rule(-80, new int[]{167});
    rules[349] = new Rule(-80, new int[]{170});
    rules[350] = new Rule(-80, new int[]{172});
    rules[351] = new Rule(-80, new int[]{173});
    rules[352] = new Rule(-80, new int[]{171});
    rules[353] = new Rule(-80, new int[]{168});
    rules[354] = new Rule(-80, new int[]{164});
    rules[355] = new Rule(-80, new int[]{174});
    rules[356] = new Rule(-80, new int[]{169});
    rules[357] = new Rule(-80, new int[]{122});
    rules[358] = new Rule(-80, new int[]{123});
    rules[359] = new Rule(-80, new int[]{124});
    rules[360] = new Rule(-80, new int[]{125});
    rules[361] = new Rule(-80, new int[]{116});
    rules[362] = new Rule(-80, new int[]{117});
    rules[363] = new Rule(-80, new int[]{100});
    rules[364] = new Rule(-80, new int[]{103});
    rules[365] = new Rule(-80, new int[]{104});
    rules[366] = new Rule(-80, new int[]{107});
    rules[367] = new Rule(-80, new int[]{110});
    rules[368] = new Rule(-80, new int[]{96});
    rules[369] = new Rule(-80, new int[]{109});
    rules[370] = new Rule(-80, new int[]{97});
    rules[371] = new Rule(-80, new int[]{98});
    rules[372] = new Rule(-80, new int[]{111});
    rules[373] = new Rule(-80, new int[]{99});
    rules[374] = new Rule(-80, new int[]{101});
    rules[375] = new Rule(-80, new int[]{113});
    rules[376] = new Rule(-80, new int[]{102});
    rules[377] = new Rule(-80, new int[]{108});
    rules[378] = new Rule(-80, new int[]{105});
    rules[379] = new Rule(-80, new int[]{119});
    rules[380] = new Rule(-80, new int[]{106});
    rules[381] = new Rule(-80, new int[]{112});
    rules[382] = new Rule(-80, new int[]{180});
    rules[383] = new Rule(-80, new int[]{126});
    rules[384] = new Rule(-80, new int[]{127});
    rules[385] = new Rule(-80, new int[]{118});
    rules[386] = new Rule(-80, new int[]{120});
    rules[387] = new Rule(-80, new int[]{121});
    rules[388] = new Rule(-80, new int[]{211});
    rules[389] = new Rule(-80, new int[]{217});
    rules[390] = new Rule(-80, new int[]{209});
    rules[391] = new Rule(-80, new int[]{210});
    rules[392] = new Rule(-80, new int[]{215});
    rules[393] = new Rule(-80, new int[]{185});
    rules[394] = new Rule(-80, new int[]{186});
    rules[395] = new Rule(-80, new int[]{193});
    rules[396] = new Rule(-80, new int[]{194});
    rules[397] = new Rule(-80, new int[]{189});
    rules[398] = new Rule(-80, new int[]{190});
    rules[399] = new Rule(-80, new int[]{191});
    rules[400] = new Rule(-80, new int[]{192});
  }

  protected override void Initialize() {
    this.InitSpecialTokens((int)Tokens.error, (int)Tokens.EOF);
    this.InitStates(states);
    this.InitRules(rules);
    this.InitNonTerminals(nonTerms);
  }

  protected override void DoAction(int action)
  {
#pragma warning disable 162, 1522
    switch (action)
    {
      case 2: // Anon@1 -> /* empty */
{this.PushSymbolTable();}
        break;
      case 3: // main -> Anon@1, pou_declarations
{this.PopSymbolTable();}
        break;
      case 6: // pou_declaration -> function_decl
{this.ReInitializeParser();}
        break;
      case 7: // pou_declaration -> function_block_decl
{this.ReInitializeParser();}
        break;
      case 8: // pou_declaration -> program_decl
{this.ReInitializeParser();}
        break;
      case 10: // assign -> ASSIGN
{CurrentSemanticValue.Token = Tokens.ASSIGN;}
        break;
      case 11: // assign -> OUTPUT_ASSIGN
{CurrentSemanticValue.Token = Tokens.OUTPUT_ASSIGN;}
        break;
      case 12: // subrange -> expression, DOTDOT, expression
{CurrentSemanticValue.Subrange = this.MakeSubrange(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3], LocationStack[LocationStack.Depth-1]);}
        break;
      case 13: // identifier_list -> IDENT
{CurrentSemanticValue.IdentifierList = this.MakeIdentifierList(ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
        break;
      case 14: // identifier_list -> identifier_list, ',', IDENT
{CurrentSemanticValue.IdentifierList = this.AddIdentToList(ValueStack[ValueStack.Depth-3].IdentifierList, ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
        break;
      case 15: // identifier_list -> identifier_list, ',', reserved_word
{CurrentSemanticValue.IdentifierList = ValueStack[ValueStack.Depth-3].IdentifierList; this.report.SyntaxError(192, ValueStack[ValueStack.Depth-1].Ident.ToString(), LocationStack[LocationStack.Depth-1]);}
        break;
      case 16: // identifier_list -> identifier_list, IDENT
{CurrentSemanticValue.IdentifierList = this.AddIdentToList(ValueStack[ValueStack.Depth-2].IdentifierList, ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);this.report.SyntaxError(75, LocationStack[LocationStack.Depth-1]);}
        break;
      case 17: // subrange_list -> subrange
{CurrentSemanticValue.Subranges = this.MakeSubRangeList(ValueStack[ValueStack.Depth-1].Subrange, LocationStack[LocationStack.Depth-1]);}
        break;
      case 18: // subrange_list -> subrange_list, ',', subrange
{CurrentSemanticValue.Subranges = this.AddSubRange(ValueStack[ValueStack.Depth-3].Subranges, ValueStack[ValueStack.Depth-1].Subrange, LocationStack[LocationStack.Depth-1]); }
        break;
      case 19: // subrange_list -> subrange_list, subrange
{CurrentSemanticValue.Subranges = this.AddSubRange(ValueStack[ValueStack.Depth-2].Subranges, ValueStack[ValueStack.Depth-1].Subrange, LocationStack[LocationStack.Depth-1]);this.report.SyntaxError(75, LocationStack[LocationStack.Depth-1]);}
        break;
      case 20: // elementary_type -> SINT
{CurrentSemanticValue.DataType = TypeNode.SInt;}
        break;
      case 21: // elementary_type -> INT
{CurrentSemanticValue.DataType = TypeNode.Int;}
        break;
      case 22: // elementary_type -> DINT
{CurrentSemanticValue.DataType = TypeNode.DInt;}
        break;
      case 23: // elementary_type -> LINT
{CurrentSemanticValue.DataType = TypeNode.LInt;}
        break;
      case 24: // elementary_type -> USINT
{CurrentSemanticValue.DataType = TypeNode.USInt;}
        break;
      case 25: // elementary_type -> UINT
{CurrentSemanticValue.DataType = TypeNode.UInt;}
        break;
      case 26: // elementary_type -> UDINT
{CurrentSemanticValue.DataType = TypeNode.UDInt;}
        break;
      case 27: // elementary_type -> ULINT
{CurrentSemanticValue.DataType = TypeNode.ULInt;}
        break;
      case 28: // elementary_type -> REAL
{CurrentSemanticValue.DataType = TypeNode.Real;}
        break;
      case 29: // elementary_type -> LREAL
{CurrentSemanticValue.DataType = TypeNode.LReal;}
        break;
      case 30: // elementary_type -> DATE
{CurrentSemanticValue.DataType = TypeNode.Date;}
        break;
      case 31: // elementary_type -> TIME_OF_DAY
{CurrentSemanticValue.DataType = TypeNode.TimeOfDay;}
        break;
      case 32: // elementary_type -> TOD
{CurrentSemanticValue.DataType = TypeNode.TimeOfDay;}
        break;
      case 33: // elementary_type -> DATE_AND_TIME
{CurrentSemanticValue.DataType = TypeNode.DateAndTime;}
        break;
      case 34: // elementary_type -> DT
{CurrentSemanticValue.DataType = TypeNode.DateAndTime;}
        break;
      case 35: // elementary_type -> TIME
{CurrentSemanticValue.DataType = TypeNode.Time;}
        break;
      case 36: // elementary_type -> BOOL
{CurrentSemanticValue.DataType = TypeNode.Bool;}
        break;
      case 37: // elementary_type -> BYTE
{CurrentSemanticValue.DataType = TypeNode.Byte;}
        break;
      case 38: // elementary_type -> WORD
{CurrentSemanticValue.DataType = TypeNode.Word;}
        break;
      case 39: // elementary_type -> DWORD
{CurrentSemanticValue.DataType = TypeNode.DWord;}
        break;
      case 40: // elementary_type -> LWORD
{CurrentSemanticValue.DataType = TypeNode.LWord;}
        break;
      case 41: // generic_type -> ANY
{CurrentSemanticValue.DataType = TypeNode.Any;}
        break;
      case 42: // generic_type -> ANY_NUM
{CurrentSemanticValue.DataType = TypeNode.AnyNum;}
        break;
      case 43: // generic_type -> ANY_INT
{CurrentSemanticValue.DataType = TypeNode.AnyInt;}
        break;
      case 44: // generic_type -> ANY_REAL
{CurrentSemanticValue.DataType = TypeNode.AnyReal;}
        break;
      case 45: // generic_type -> ANY_BIT
{CurrentSemanticValue.DataType = TypeNode.AnyBit;}
        break;
      case 46: // generic_type -> ANY_DATE
{CurrentSemanticValue.DataType = TypeNode.AnyDate;}
        break;
      case 47: // generic_type -> ANY_DERIVED
{CurrentSemanticValue.DataType = TypeNode.AnyDerived;}
        break;
      case 48: // generic_type -> ANY_ELEMENTARY
{CurrentSemanticValue.DataType = TypeNode.AnyElementary;}
        break;
      case 49: // generic_type -> ANY_MAGNITUDE
{CurrentSemanticValue.DataType = TypeNode.AnyMagnitude;}
        break;
      case 50: // generic_type -> ANY_STRING
{CurrentSemanticValue.DataType = TypeNode.AnyString;}
        break;
      case 51: // derived_type -> IDENT
{CurrentSemanticValue.DataType = this.GetDerivedType(ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
        break;
      case 62: // data_type -> generic_type
{CurrentSemanticValue.DataType = TypeNode.Error; this.report.SemanticError(51, LocationStack[LocationStack.Depth-1]);}
        break;
      case 63: // data_type_spec -> data_type, opt_decl_qualifier
{CurrentSemanticValue.TypeSpec = this.MakeDataTypeSpec(ValueStack[ValueStack.Depth-2].DataType, ValueStack[ValueStack.Depth-1].EdgeQualifier, LocationStack[LocationStack.Depth-1]);}
        break;
      case 64: // Anon@2 -> /* empty */
{this.Push(ValueStack[ValueStack.Depth-3].DataType);}
        break;
      case 65: // data_type_spec -> data_type, opt_decl_qualifier, ASSIGN, Anon@2, initial_value
{CurrentSemanticValue.TypeSpec = this.MakeDataTypeSpec(ValueStack[ValueStack.Depth-5].DataType, ValueStack[ValueStack.Depth-4].EdgeQualifier, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-4]);}
        break;
      case 66: // array_type -> ARRAY, '[', subrange_list, ']', OF, non_generic_type
{CurrentSemanticValue.DataType = this.MakeArrayType(ValueStack[ValueStack.Depth-4].Subranges, ValueStack[ValueStack.Depth-1].DataType, LocationStack[LocationStack.Depth-4], LocationStack[LocationStack.Depth-1]);}
        break;
      case 67: // array_type -> ARRAY, '[', error, ']', OF, non_generic_type
{CurrentSemanticValue.DataType = TypeNode.Error; this.yyerrok();}
        break;
      case 68: // Anon@3 -> /* empty */
{this.CheckNestingDepth(LocationStack[LocationStack.Depth-1]);}
        break;
      case 69: // struct_member_decls -> STRUCT, Anon@3, struct_member_decl
{CurrentSemanticValue.StructDecl = this.MakeStructMemberList(ValueStack[ValueStack.Depth-1].MemberDecl);}
        break;
      case 70: // struct_member_decls -> struct_member_decls, struct_member_decl
{CurrentSemanticValue.StructDecl = this.AddStructMemberDecl(ValueStack[ValueStack.Depth-2].StructDecl, ValueStack[ValueStack.Depth-1].MemberDecl, LocationStack[LocationStack.Depth-1]);}
        break;
      case 71: // struct_member_decl -> IDENT, ':', data_type_spec, semicolon
{CurrentSemanticValue.MemberDecl = this.MakeStructMemberDecl(ValueStack[ValueStack.Depth-4].Ident, ValueStack[ValueStack.Depth-2].TypeSpec, LocationStack[LocationStack.Depth-4]);}
        break;
      case 72: // structure_type -> struct_member_decls, END_STRUCT
{CurrentSemanticValue.DataType = this.MakeStructDataType(ValueStack[ValueStack.Depth-2].StructDecl);}
        break;
      case 73: // Anon@4 -> /* empty */
{this.CheckNestingDepth(LocationStack[LocationStack.Depth-1]);}
        break;
      case 74: // structure_type -> STRUCT, Anon@4, error, END_STRUCT
{CurrentSemanticValue.DataType = TypeNode.Error; this.yyerrok();}
        break;
      case 75: // structure_type -> struct_member_decls, error, END_STRUCT
{CurrentSemanticValue.DataType = this.MakeStructDataType(ValueStack[ValueStack.Depth-3].StructDecl); this.yyerrok();}
        break;
      case 76: // enum_identifier -> IDENT
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 77: // enum_identifier -> TYPED_ENUM
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].TypedEnum.Value; this.report.SyntaxError(169, ValueStack[ValueStack.Depth-1].TypedEnum.ToString(), LocationStack[LocationStack.Depth-1]);}
        break;
      case 78: // enum_identifier -> reserved_word
{CurrentSemanticValue.Ident = ""; this.report.SyntaxError(192, ValueStack[ValueStack.Depth-1].Ident.ToString(), LocationStack[LocationStack.Depth-1]);}
        break;
      case 79: // enum_ident_seq -> '(', enum_identifier
{CurrentSemanticValue.IdentifierList = this.MakeEnumIdentList(ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
        break;
      case 80: // enum_ident_seq -> enum_ident_seq, ',', enum_identifier
{CurrentSemanticValue.IdentifierList = this.AddToEnumIdentList(ValueStack[ValueStack.Depth-3].IdentifierList, ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
        break;
      case 81: // enum_ident_seq -> enum_ident_seq, enum_identifier
{CurrentSemanticValue.IdentifierList = this.AddToEnumIdentList(ValueStack[ValueStack.Depth-2].IdentifierList, ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]); this.report.SyntaxError(75, LocationStack[LocationStack.Depth-1]);}
        break;
      case 82: // enumerated_type -> enum_ident_seq, ')'
{CurrentSemanticValue.DataType = this.MakeEnumeratedType(ValueStack[ValueStack.Depth-2].IdentifierList);}
        break;
      case 83: // enumerated_type -> enum_ident_seq, error, ')'
{CurrentSemanticValue.DataType = this.MakeEnumeratedType(ValueStack[ValueStack.Depth-3].IdentifierList); this.yyerrok();}
        break;
      case 84: // enumerated_type -> '(', error, ')'
{CurrentSemanticValue.DataType = TypeNode.Error;this.yyerrok();}
        break;
      case 85: // enumerated_type -> '(', ')'
{CurrentSemanticValue.DataType = TypeNode.Error; this.report.SyntaxError(166, LocationStack[LocationStack.Depth-2]);}
        break;
      case 86: // string_type -> STRING, '[', expression, ']'
{CurrentSemanticValue.DataType = this.MakeStringType(ValueStack[ValueStack.Depth-2].Expression, LocationStack[LocationStack.Depth-4]);}
        break;
      case 87: // string_type -> WSTRING, '[', expression, ']'
{CurrentSemanticValue.DataType = this.MakeWStringType(ValueStack[ValueStack.Depth-2].Expression, LocationStack[LocationStack.Depth-4]);}
        break;
      case 88: // string_type -> STRING
{CurrentSemanticValue.DataType = TypeNode.String;}
        break;
      case 89: // string_type -> WSTRING
{CurrentSemanticValue.DataType = TypeNode.WString;}
        break;
      case 90: // Anon@5 -> /* empty */
{this.SubrangeTypeStart(ValueStack[ValueStack.Depth-2].DataType);}
        break;
      case 91: // subrange_type -> non_generic_type, '(', Anon@5, subrange, ')'
{CurrentSemanticValue.DataType = this.MakeSubrangeType(ValueStack[ValueStack.Depth-5].DataType, ValueStack[ValueStack.Depth-2].Subrange, LocationStack[LocationStack.Depth-2]);}
        break;
      case 92: // Anon@6 -> /* empty */
{this.PushArrayElemType(LocationStack[LocationStack.Depth-1]);}
        break;
      case 93: // array_init_seq -> '[', Anon@6, initializer
{CurrentSemanticValue.InitList = this.MakeArrayInitializer(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);    }
        break;
      case 94: // array_init_seq -> array_init_seq, ',', initializer
{CurrentSemanticValue.InitList = this.AddArrayInitializer(ValueStack[ValueStack.Depth-3].InitList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]); }
        break;
      case 95: // struct_init_seq -> '(', initializer
{CurrentSemanticValue.InitList = this.MakeStructInitializer(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 96: // struct_init_seq -> struct_init_seq, ',', initializer
{CurrentSemanticValue.InitList = this.AddStructMemberInitializer(ValueStack[ValueStack.Depth-3].InitList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 97: // array_init_list -> array_init_seq, ']'
{CurrentSemanticValue.InitList = this.WrapUpArrayInitList(ValueStack[ValueStack.Depth-2].InitList, LocationStack[LocationStack.Depth-1]);}
        break;
      case 98: // array_init_list -> array_init_seq, error, ']'
{CurrentSemanticValue.InitList = this.WrapUpArrayInitList(ValueStack[ValueStack.Depth-3].InitList, LocationStack[LocationStack.Depth-1]); this.yyerrok();}
        break;
      case 99: // array_init_list -> '[', error, ']'
{CurrentSemanticValue.InitList = null; this.yyerrok();}
        break;
      case 100: // array_init_list -> '[', ']'
{CurrentSemanticValue.InitList = null; this.report.Warning(19, LocationStack[LocationStack.Depth-2]);}
        break;
      case 101: // struct_init_list -> struct_init_seq, ')'
{CurrentSemanticValue.InitList = this.WrapUpStructInitList(ValueStack[ValueStack.Depth-2].InitList, LocationStack[LocationStack.Depth-1]);}
        break;
      case 102: // struct_init_list -> struct_init_seq, error, ')'
{CurrentSemanticValue.InitList = this.WrapUpStructInitList(ValueStack[ValueStack.Depth-3].InitList, LocationStack[LocationStack.Depth-1]); this.yyerrok();}
        break;
      case 103: // struct_init_list -> '(', ')'
{CurrentSemanticValue.InitList = null; this.report.Warning(19, LocationStack[LocationStack.Depth-2]);}
        break;
      case 104: // initializer -> initial_value
{CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].Expression;}
        break;
      case 105: // Anon@7 -> /* empty */
{this.CheckIfArrayType(LocationStack[LocationStack.Depth-2]);}
        break;
      case 106: // initializer -> INT_LIT, '(', Anon@7, error, ')'
{CurrentSemanticValue.Expression = this.ExpandInitializerSequence(ValueStack[ValueStack.Depth-5].LInt, null, LocationStack[LocationStack.Depth-5]);this.yyerrok();}
        break;
      case 107: // Anon@8 -> /* empty */
{this.CheckIfArrayType(LocationStack[LocationStack.Depth-2]);}
        break;
      case 108: // initializer -> INT_LIT, '(', Anon@8, initializer_seq, ')'
{CurrentSemanticValue.Expression = this.ExpandInitializerSequence(ValueStack[ValueStack.Depth-5].LInt, ValueStack[ValueStack.Depth-2].InitList, LocationStack[LocationStack.Depth-5]);}
        break;
      case 109: // Anon@9 -> /* empty */
{this.PushFieldType(ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
        break;
      case 110: // initializer -> IDENT, Anon@9, ASSIGN, initial_value
{CurrentSemanticValue.Expression = this.MakeStructMemberInit(ValueStack[ValueStack.Depth-4].Ident, ValueStack[ValueStack.Depth-1].Expression);}
        break;
      case 111: // initializer_seq -> initializer
{CurrentSemanticValue.InitList = this.MakeInitializerSequence(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);                    }
        break;
      case 112: // initializer_seq -> initializer_seq, ',', initializer
{CurrentSemanticValue.InitList = this.AddInitializerToSequence(ValueStack[ValueStack.Depth-3].InitList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);               }
        break;
      case 113: // initializer_seq -> initializer_seq, error, initializer
{CurrentSemanticValue.InitList = this.AddInitializerToSequence(ValueStack[ValueStack.Depth-3].InitList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);this.yyerrok();}
        break;
      case 114: // initial_value -> expression
{CurrentSemanticValue.Expression = this.CheckInitialValue(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 115: // initial_value -> array_init_list
{CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].InitList;}
        break;
      case 116: // initial_value -> struct_init_list
{CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].InitList;}
        break;
      case 117: // data_type_decl -> TYPE, type_decl_list, END_TYPE
{this.isTypeDecl = false;}
        break;
      case 118: // data_type_decl -> TYPE, type_decl_list, error, END_TYPE
{this.isTypeDecl = false; this.yyerrok();}
        break;
      case 119: // data_type_decl -> TYPE, error, END_TYPE
{this.isTypeDecl = false; this.yyerrok();}
        break;
      case 120: // Anon@10 -> /* empty */
{this.isTypeDecl = true;}
        break;
      case 124: // semicolon -> /* empty */
{this.report.SyntaxError(63, this.Scanner.yylloc);}
        break;
      case 125: // Anon@11 -> /* empty */
{this.derivedTypeName = ValueStack[ValueStack.Depth-2].Ident;}
        break;
      case 126: // type_decl -> IDENT, ':', Anon@11, data_type_spec, semicolon
{this.InstallDerivedType(ValueStack[ValueStack.Depth-5].Ident, ValueStack[ValueStack.Depth-2].TypeSpec, LocationStack[LocationStack.Depth-5]);}
        break;
      case 127: // constant -> TRUE
{CurrentSemanticValue.Expression = this.MakeConstant(true, ValueStack[ValueStack.Depth-1].Ident);}
        break;
      case 128: // constant -> FALSE
{CurrentSemanticValue.Expression = this.MakeConstant(false, ValueStack[ValueStack.Depth-1].Ident);}
        break;
      case 129: // constant -> INT_LIT
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].LInt);}
        break;
      case 130: // constant -> REAL_LIT
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].LReal);}
        break;
      case 131: // constant -> TOD_LIT
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].TimeOfDay);}
        break;
      case 132: // constant -> TIME_LIT
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].Time);}
        break;
      case 133: // constant -> DATE_LIT
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].Date);}
        break;
      case 134: // constant -> DT_LIT
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].DateTime);}
        break;
      case 135: // constant -> STRING_LIT
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].String, LocationStack[LocationStack.Depth-1]);}
        break;
      case 136: // constant -> WSTRING_LIT
{CurrentSemanticValue.Expression = this.MakeWString(ValueStack[ValueStack.Depth-1].String, LocationStack[LocationStack.Depth-1]); }
        break;
      case 137: // constant -> TYPED_INT
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].TypedInt, LocationStack[LocationStack.Depth-1]);}
        break;
      case 138: // constant -> TYPED_REAL
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].TypedReal, LocationStack[LocationStack.Depth-1]);}
        break;
      case 139: // constant -> TYPED_ENUM
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].TypedEnum, LocationStack[LocationStack.Depth-1]);}
        break;
      case 140: // variable -> symbolic_variable
{CurrentSemanticValue.Expression = this.MakeSymbolicVariable(ValueStack[ValueStack.Depth-1].Expression);}
        break;
      case 141: // variable -> DIRECT_VAR
{CurrentSemanticValue.Expression = this.MakeDirectVariable(ValueStack[ValueStack.Depth-1].DirectVar, LocationStack[LocationStack.Depth-1]);}
        break;
      case 142: // symbolic_variable -> simple_variable
{CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].Expression;}
        break;
      case 143: // symbolic_variable -> indexed_variable, ']'
{CurrentSemanticValue.Expression = this.MakeIndexedVariable(ValueStack[ValueStack.Depth-2].IndexedVariable);}
        break;
      case 144: // symbolic_variable -> simple_variable, '[', error, ']'
{CurrentSemanticValue.Expression = Expression.Error; this.yyerrok();}
        break;
      case 145: // Anon@12 -> /* empty */
{this.isIndexExpr = true;}
        break;
      case 146: // indexed_variable -> simple_variable, '[', Anon@12, expression
{CurrentSemanticValue.IndexedVariable = this.MakeIndexedVariable(ValueStack[ValueStack.Depth-4].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-4], LocationStack[LocationStack.Depth-1]);}
        break;
      case 147: // indexed_variable -> indexed_variable, ',', expression
{CurrentSemanticValue.IndexedVariable = this.MakeIndexedVariable(ValueStack[ValueStack.Depth-3].IndexedVariable, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3], LocationStack[LocationStack.Depth-1]);}
        break;
      case 148: // simple_variable -> IDENT
{CurrentSemanticValue.Expression = this.MakeSimpleVariable(ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);    }
        break;
      case 149: // simple_variable -> symbolic_variable, '.', IDENT
{CurrentSemanticValue.Expression = this.MakeSimpleVariable(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
        break;
      case 150: // expression -> NOT, expression
{CurrentSemanticValue.Expression = this.MakeNotOperator(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 151: // expression -> '-', expression
{CurrentSemanticValue.Expression = this.MakeUnaryMinusOperator(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 152: // expression -> '+', expression
{CurrentSemanticValue.Expression = this.MakeUnaryPlusOperator(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 153: // expression -> expression, '=', expression
{CurrentSemanticValue.Expression = this.MakeEqlOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 154: // expression -> expression, '<', expression
{CurrentSemanticValue.Expression = this.MakeLesOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 155: // expression -> expression, '>', expression
{CurrentSemanticValue.Expression = this.MakeGtrOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 156: // expression -> expression, NEQ, expression
{CurrentSemanticValue.Expression = this.MakeNeqOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 157: // expression -> expression, GEQ, expression
{CurrentSemanticValue.Expression = this.MakeGeqOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 158: // expression -> expression, LEQ, expression
{CurrentSemanticValue.Expression = this.MakeLeqOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 159: // expression -> expression, AND, expression
{CurrentSemanticValue.Expression = this.MakeAndOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 160: // expression -> expression, IOR, expression
{CurrentSemanticValue.Expression = this.MakeIOrOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 161: // expression -> expression, XOR, expression
{CurrentSemanticValue.Expression = this.MakeXOrOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 162: // expression -> expression, POW, expression
{CurrentSemanticValue.Expression = this.MakePowOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 163: // expression -> expression, MOD, expression
{CurrentSemanticValue.Expression = this.MakeModOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 164: // expression -> expression, '&', expression
{CurrentSemanticValue.Expression = this.MakeAndOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 165: // expression -> expression, '+', expression
{CurrentSemanticValue.Expression = this.MakeAddOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 166: // expression -> expression, '-', expression
{CurrentSemanticValue.Expression = this.MakeSubOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 167: // expression -> expression, '*', expression
{CurrentSemanticValue.Expression = this.MakeMulOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 168: // expression -> expression, '/', expression
{CurrentSemanticValue.Expression = this.MakeDivOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 169: // expression -> '(', expression, ')'
{CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-2].Expression;}
        break;
      case 170: // expression -> '(', expression, error
{CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-2].Expression; this.report.SemanticError(43, LocationStack[LocationStack.Depth-1]);}
        break;
      case 171: // expression -> prog_org_unit_call
{CurrentSemanticValue.Expression = this.MakeFunctionCall(ValueStack[ValueStack.Depth-1].POU);       }
        break;
      case 172: // expression -> constant
{CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].Expression;                              }
        break;
      case 173: // expression -> variable
{CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].Expression; this.CheckIfForLoopVar(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 174: // expression -> '(', error, ')'
{CurrentSemanticValue.Expression = Expression.Error; this.yyerrok();}
        break;
      case 175: // pou_parameter -> expression
{CurrentSemanticValue.POUParameter = this.MakeParameter(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 176: // pou_parameter -> IDENT, assign, expression
{CurrentSemanticValue.POUParameter = this.MakeParameter(ValueStack[ValueStack.Depth-3].Ident, ValueStack[ValueStack.Depth-2].Token, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3]);}
        break;
      case 177: // pou_parameter -> NOT, IDENT, assign, expression
{CurrentSemanticValue.POUParameter = this.MakeParameter(ValueStack[ValueStack.Depth-3].Ident, ValueStack[ValueStack.Depth-2].Token, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3], true);}
        break;
      case 178: // pou_call_sequence -> IDENT, '(', pou_parameter
{CurrentSemanticValue.POU = this.MakePOUCall(ValueStack[ValueStack.Depth-3].Ident, ValueStack[ValueStack.Depth-1].POUParameter, LocationStack[LocationStack.Depth-3]);}
        break;
      case 179: // pou_call_sequence -> pou_call_sequence, ',', pou_parameter
{CurrentSemanticValue.POU = this.AddPOUParameter(ValueStack[ValueStack.Depth-3].POU, ValueStack[ValueStack.Depth-1].POUParameter);}
        break;
      case 180: // prog_org_unit_call -> IDENT, '(', ')'
{CurrentSemanticValue.POU = this.MakePOUCall(ValueStack[ValueStack.Depth-3].Ident, LocationStack[LocationStack.Depth-3]);}
        break;
      case 181: // prog_org_unit_call -> IDENT, '(', error, ')'
{CurrentSemanticValue.POU = this.MakePOUCall(ValueStack[ValueStack.Depth-4].Ident, LocationStack[LocationStack.Depth-4]); this.yyerrok();}
        break;
      case 182: // prog_org_unit_call -> pou_call_sequence, ')'
{CurrentSemanticValue.POU = this.MakePOUCall(ValueStack[ValueStack.Depth-2].POU, LocationStack[LocationStack.Depth-2]);}
        break;
      case 183: // Anon@13 -> /* empty */
{this.PushTop();}
        break;
      case 184: // statement_list -> Anon@13, statement, ';'
{CurrentSemanticValue.StatList = this.MakeStatementList(ValueStack[ValueStack.Depth-2].Stat);}
        break;
      case 185: // statement_list -> statement_list, statement, ';'
{CurrentSemanticValue.StatList = this.AddToStatementList(ValueStack[ValueStack.Depth-3].StatList, ValueStack[ValueStack.Depth-2].Stat, LocationStack[LocationStack.Depth-2]);}
        break;
      case 186: // statement_list -> error, ';'
{CurrentSemanticValue.StatList = StatementList.Empty; this.yyerrok();}
        break;
      case 187: // statement -> WHILE, condition_DO, while_statement_body
{CurrentSemanticValue.Stat = this.MakeWhileStatement(ValueStack[ValueStack.Depth-2].Expression, ValueStack[ValueStack.Depth-1].StatList, LocationStack[LocationStack.Depth-3]);}
        break;
      case 188: // Anon@14 -> /* empty */
{this.loopNestingDepth++;}
        break;
      case 189: // statement -> REPEAT, Anon@14, repeat_statement_body
{CurrentSemanticValue.Stat = ValueStack[ValueStack.Depth-1].Stat;}
        break;
      case 190: // Anon@15 -> /* empty */
{this.PopTop();}
        break;
      case 191: // statement -> IF, condition_THEN, statement_list, Anon@15, opt_elsif_stat, 
                //              opt_else_stat, END_IF
{CurrentSemanticValue.Stat = this.MakeIfStatement(ValueStack[ValueStack.Depth-6].Expression, ValueStack[ValueStack.Depth-5].StatList, ValueStack[ValueStack.Depth-3].GenericList, ValueStack[ValueStack.Depth-2].StatList);}
        break;
      case 192: // Anon@16 -> /* empty */
{this.PushForLoopData(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].ForList);}
        break;
      case 193: // statement -> FOR, control_variable, assign, for_list_DO, Anon@16, 
                //              for_statement_body
{CurrentSemanticValue.Stat = this.MakeForLoopStatement(ValueStack[ValueStack.Depth-5].Expression, ValueStack[ValueStack.Depth-3].ForList, ValueStack[ValueStack.Depth-1].StatList);}
        break;
      case 194: // statement -> CASE, expression_OF, case_element_list, END_CASE
{CurrentSemanticValue.Stat = this.MakeCaseStatement(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-2].CaseElementList, LocationStack[LocationStack.Depth-1]);}
        break;
      case 195: // statement -> assignment_stat
{CurrentSemanticValue.Stat = ValueStack[ValueStack.Depth-1].Stat;}
        break;
      case 196: // statement -> EXIT
{CurrentSemanticValue.Stat = this.MakeExitStatement(LocationStack[LocationStack.Depth-1]);}
        break;
      case 197: // statement -> RETURN
{CurrentSemanticValue.Stat = this.MakeReturnStatement(LocationStack[LocationStack.Depth-1]);}
        break;
      case 198: // statement -> RETURN, expression
{CurrentSemanticValue.Stat = this.MakeReturnStatement2(LocationStack[LocationStack.Depth-1]);}
        break;
      case 199: // statement -> prog_org_unit_call
{CurrentSemanticValue.Stat = this.MakeFunctionBlockCallStatement(ValueStack[ValueStack.Depth-1].POU);}
        break;
      case 200: // statement -> /* empty */
{CurrentSemanticValue.Stat = Statement.Empty;}
        break;
      case 201: // while_statement_body -> statement_list, END_WHILE
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-2].StatList;}
        break;
      case 202: // while_statement_body -> statement_list, error, END_WHILE
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-3].StatList;this.yyerrok();}
        break;
      case 203: // while_statement_body -> error, END_WHILE
{CurrentSemanticValue.StatList = StatementList.Empty;this.yyerrok();}
        break;
      case 204: // repeat_statement_body -> statement_list, UNTIL, until_condition
{CurrentSemanticValue.Stat = this.MakeRepeatStatement(ValueStack[ValueStack.Depth-3].StatList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3]);}
        break;
      case 205: // repeat_statement_body -> statement_list, error, UNTIL, until_condition
{CurrentSemanticValue.Stat = this.MakeRepeatStatement(ValueStack[ValueStack.Depth-4].StatList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-4]);this.yyerrok();}
        break;
      case 206: // repeat_statement_body -> error, END_REPEAT
{CurrentSemanticValue.Stat = this.MakeRepeatStatement(); this.yyerrok();}
        break;
      case 207: // for_statement_body -> statement_list, END_FOR
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-2].StatList;}
        break;
      case 208: // for_statement_body -> statement_list, error, END_FOR
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-3].StatList; this.yyerrok();}
        break;
      case 209: // for_statement_body -> error, END_FOR
{CurrentSemanticValue.StatList = StatementList.Empty; this.yyerrok();}
        break;
      case 210: // condition_DO -> expression, DO
{CurrentSemanticValue.Expression = this.CheckIfBoolCondition("WHILE-DO", ValueStack[ValueStack.Depth-2].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 211: // condition_DO -> error, DO
{CurrentSemanticValue.Expression = Expression.Error; this.yyerrok();}
        break;
      case 212: // condition_DO -> expression
{CurrentSemanticValue.Expression = this.CheckIfBoolCondition("WHILE-DO", ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]); this.report.SyntaxError(80, LocationStack[LocationStack.Depth-1]);}
        break;
      case 213: // condition_THEN -> expression, THEN
{CurrentSemanticValue.Expression = this.CheckIfBoolCondition("IF-THEN-ELSE", ValueStack[ValueStack.Depth-2].Expression,  LocationStack[LocationStack.Depth-2]);}
        break;
      case 214: // condition_THEN -> error, THEN
{CurrentSemanticValue.Expression = Expression.Error; this.yyerrok();}
        break;
      case 215: // condition_THEN -> expression
{CurrentSemanticValue.Expression = this.CheckIfBoolCondition("IF-THEN-ELSE", ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);this.report.SyntaxError(81, LocationStack[LocationStack.Depth-1]);}
        break;
      case 216: // until_condition -> expression, END_REPEAT
{CurrentSemanticValue.Expression = this.CheckIfBoolCondition("REPEAT-UNTIL", ValueStack[ValueStack.Depth-2].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 217: // until_condition -> error, END_REPEAT
{CurrentSemanticValue.Expression = Expression.Error; this.yyerrok();}
        break;
      case 218: // until_condition -> expression
{CurrentSemanticValue.Expression = this.CheckIfBoolCondition("REPEAT-UNTIL", ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);this.report.SyntaxError(82, LocationStack[LocationStack.Depth-1]);}
        break;
      case 219: // expression_OF -> expression, OF
{CurrentSemanticValue.Expression = this.CheckCtrlExpression(LocationStack[LocationStack.Depth-2], ValueStack[ValueStack.Depth-2].Expression);}
        break;
      case 220: // expression_OF -> error, OF
{CurrentSemanticValue.Expression = this.CheckCtrlExpression(LocationStack[LocationStack.Depth-2]);this.yyerrok();}
        break;
      case 221: // expression_OF -> expression
{CurrentSemanticValue.Expression = this.CheckCtrlExpression(LocationStack[LocationStack.Depth-1], ValueStack[ValueStack.Depth-1].Expression);this.report.SyntaxError(83, LocationStack[LocationStack.Depth-1]);}
        break;
      case 222: // control_variable -> variable
{CurrentSemanticValue.Expression = this.SaveControlVariable(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);this.forLoopVarKind = 0x2;}
        break;
      case 223: // Anon@17 -> /* empty */
{this.forLoopVarKind = 0x4;}
        break;
      case 224: // for_list_DO -> expression, TO, Anon@17, expression, optional_by_stat, DO
{CurrentSemanticValue.ForList = this.MakeForLoopData(ValueStack[ValueStack.Depth-6].Expression, ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-2].Expression, LocationStack[LocationStack.Depth-6], LocationStack[LocationStack.Depth-3], LocationStack[LocationStack.Depth-2]);}
        break;
      case 225: // Anon@18 -> /* empty */
{this.forLoopVarKind = 0x4;}
        break;
      case 226: // for_list_DO -> error, TO, Anon@18, expression, optional_by_stat, DO
{CurrentSemanticValue.ForList = this.MakeForLoopData(null, ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-2].Expression, null, LocationStack[LocationStack.Depth-3], LocationStack[LocationStack.Depth-2]);this.yyerrok();}
        break;
      case 227: // for_list_DO -> expression, TO, error, DO
{CurrentSemanticValue.ForList = this.MakeForLoopData(ValueStack[ValueStack.Depth-4].Expression, null, null, LocationStack[LocationStack.Depth-4]);this.yyerrok();}
        break;
      case 228: // for_list_DO -> error, DO
{CurrentSemanticValue.ForList = this.MakeForLoopData(null, null, null);this.yyerrok();}
        break;
      case 229: // Anon@19 -> /* empty */
{this.forLoopVarKind = 0x8;}
        break;
      case 230: // optional_by_stat -> BY, Anon@19, expression
{CurrentSemanticValue.Expression = this.CheckForLoopIncr(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 231: // optional_by_stat -> /* empty */
{CurrentSemanticValue.Expression = MakeIntConstant((long)1);}
        break;
      case 232: // opt_else_stat -> ELSE, statement_list
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-1].StatList; this.PopTop();  }
        break;
      case 233: // opt_else_stat -> ELSE, error
{CurrentSemanticValue.StatList = null; this.PopTop();}
        break;
      case 234: // opt_else_stat -> /* empty */
{CurrentSemanticValue.StatList = null;}
        break;
      case 235: // opt_elsif_stat -> elsif_stat
{CurrentSemanticValue.GenericList = ValueStack[ValueStack.Depth-1].GenericList;}
        break;
      case 236: // opt_elsif_stat -> /* empty */
{CurrentSemanticValue.GenericList = null;}
        break;
      case 237: // default_statement -> ELSE, case_stat_list
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-1].StatList;}
        break;
      case 238: // default_statement -> ELSE, case_stat_list, error
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-2].StatList; this.yyerrok();}
        break;
      case 239: // Anon@20 -> /* empty */
{this.PushTop();}
        break;
      case 240: // case_stat_list -> Anon@20, statement, ';'
{CurrentSemanticValue.StatList = this.MakeCaseStatList(ValueStack[ValueStack.Depth-2].Stat);         }
        break;
      case 241: // case_stat_list -> case_stat_list, statement, ';'
{CurrentSemanticValue.StatList = this.AddToCaseStatList(ValueStack[ValueStack.Depth-3].StatList, ValueStack[ValueStack.Depth-2].Stat, LocationStack[LocationStack.Depth-2]);}
        break;
      case 243: // case_element -> WHEN, case_label_list, ':', case_stat_list
{CurrentSemanticValue.Object = this.MakeCaseElement(ValueStack[ValueStack.Depth-3].CaseLabelList, ValueStack[ValueStack.Depth-1].StatList);}
        break;
      case 244: // case_element -> WHEN, error, ':', case_stat_list
{CurrentSemanticValue.Object = this.MakeCaseElement(null, ValueStack[ValueStack.Depth-1].StatList);this.yyerrok();}
        break;
      case 245: // case_element -> WHEN, case_label_list, case_stat_list
{CurrentSemanticValue.Object = this.MakeCaseElement(null, ValueStack[ValueStack.Depth-1].StatList); this.report.SyntaxError(91, LocationStack[LocationStack.Depth-1]);}
        break;
      case 246: // case_element -> default_statement
{CurrentSemanticValue.Object = this.MakeDefaultCaseElement(ValueStack[ValueStack.Depth-1].StatList);}
        break;
      case 247: // case_elem_list -> case_element
{CurrentSemanticValue.CaseElementList = this.MakeCaseElementList(ValueStack[ValueStack.Depth-1].Object);}
        break;
      case 248: // case_elem_list -> case_elem_list, case_element
{CurrentSemanticValue.CaseElementList = this.AddCaseElementToList(ValueStack[ValueStack.Depth-2].CaseElementList, ValueStack[ValueStack.Depth-1].Object, LocationStack[LocationStack.Depth-1]);}
        break;
      case 249: // case_element_list -> case_elem_list
{CurrentSemanticValue.CaseElementList = ValueStack[ValueStack.Depth-1].CaseElementList;}
        break;
      case 250: // case_element_list -> /* empty */
{CurrentSemanticValue.CaseElementList = new List<CaseElement>();}
        break;
      case 251: // case_label -> expression
{CurrentSemanticValue.CaseLabel = this.CheckCaseLabel(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 252: // case_label -> subrange
{CurrentSemanticValue.CaseLabel = this.CheckCaseLabel(ValueStack[ValueStack.Depth-1].Subrange, LocationStack[LocationStack.Depth-1]);}
        break;
      case 253: // case_label_list -> case_label
{CurrentSemanticValue.CaseLabelList = this.MakeCaseLabelList(ValueStack[ValueStack.Depth-1].CaseLabel, LocationStack[LocationStack.Depth-1]);     }
        break;
      case 254: // case_label_list -> case_label_list, ',', case_label
{CurrentSemanticValue.CaseLabelList = this.AddCaseLabelToList(ValueStack[ValueStack.Depth-3].CaseLabelList, ValueStack[ValueStack.Depth-1].CaseLabel, LocationStack[LocationStack.Depth-1]);}
        break;
      case 255: // elsif_stat -> ELSIF, condition_THEN, statement_list
{CurrentSemanticValue.GenericList = this.MakeElseIfStatement(ValueStack[ValueStack.Depth-2].Expression, ValueStack[ValueStack.Depth-1].StatList);}
        break;
      case 256: // elsif_stat -> elsif_stat, ELSIF, condition_THEN, statement_list
{CurrentSemanticValue.GenericList = this.AddElseIfStatementToList(ValueStack[ValueStack.Depth-4].GenericList, ValueStack[ValueStack.Depth-2].Expression, ValueStack[ValueStack.Depth-1].StatList);}
        break;
      case 257: // assignment_stat -> variable, ASSIGN, expression
{CurrentSemanticValue.Stat = this.MakeAssignmentStatement(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3]);}
        break;
      case 258: // assignment_stat -> variable, '=', expression
{CurrentSemanticValue.Stat = this.MakeAssignmentStatement(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3]);}
        break;
      case 259: // function_body -> statement_list, END_FUNCTION
{CurrentSemanticValue.StatList = this.CheckFunctionValueDefinition(ValueStack[ValueStack.Depth-2].StatList, LocationStack[LocationStack.Depth-1]);}
        break;
      case 260: // function_body -> statement_list, error, END_FUNCTION
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-3].StatList;this.yyerrok();}
        break;
      case 261: // function_block_body -> statement_list, END_FUNCTION_BLOCK
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-2].StatList;}
        break;
      case 262: // function_block_body -> statement_list, error, END_FUNCTION_BLOCK
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-3].StatList; this.yyerrok();}
        break;
      case 263: // program_body -> statement_list, END_PROGRAM
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-2].StatList;}
        break;
      case 264: // program_body -> statement_list, error, END_PROGRAM
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-3].StatList; this.yyerrok();}
        break;
      case 265: // Anon@21 -> /* empty */
{this.PushSymbolTable(0);}
        break;
      case 266: // Anon@22 -> /* empty */
{this.InstallFunctionProtoType(ValueStack[ValueStack.Depth-5].Ident, ValueStack[ValueStack.Depth-3].DataType, ValueStack[ValueStack.Depth-1].POUVariableDecls, LocationStack[LocationStack.Depth-6]);}
        break;
      case 267: // function_decl -> FUNCTION, IDENT, ':', non_generic_type, Anon@21, 
                //                  pou_variable_decls, Anon@22, function_body
{this.SaveFunctionDefinition(ValueStack[ValueStack.Depth-3].POUVariableDecls, ValueStack[ValueStack.Depth-1].StatList);}
        break;
      case 268: // Anon@23 -> /* empty */
{this.PushSymbolTable(1);}
        break;
      case 269: // Anon@24 -> /* empty */
{this.InstallFunctionBlockProtoType(ValueStack[ValueStack.Depth-3].Ident, ValueStack[ValueStack.Depth-1].POUVariableDecls, LocationStack[LocationStack.Depth-4]);}
        break;
      case 270: // function_block_decl -> FUNCTION_BLOCK, IDENT, Anon@23, pou_variable_decls, 
                //                        Anon@24, function_block_body
{this.SaveFunctionBlockDeclaration(ValueStack[ValueStack.Depth-3].POUVariableDecls, ValueStack[ValueStack.Depth-1].StatList);}
        break;
      case 271: // Anon@25 -> /* empty */
{this.PushSymbolTable(2);}
        break;
      case 273: // Anon@26 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR_INPUT, ValueStack[ValueStack.Depth-1].VarQualifier, LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 274: // input_var_decl -> VAR_INPUT, opt_var_qualifier, Anon@26, var_declaration
{CurrentSemanticValue.Declaration = this.MakeFormalParameterDecl(STVarType.VAR_INPUT, ValueStack[ValueStack.Depth-3].VarQualifier, ValueStack[ValueStack.Depth-1].POUVarDecl);}
        break;
      case 275: // input_var_decl -> VAR_INPUT, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 276: // Anon@27 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR, ValueStack[ValueStack.Depth-1].VarQualifier, LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 277: // var_decl -> VAR, opt_var_qualifier, Anon@27, var_declaration
{CurrentSemanticValue.Declaration = this.MakeLocalVariableDecl(STVarType.VAR, ValueStack[ValueStack.Depth-3].VarQualifier, ValueStack[ValueStack.Depth-1].POUVarDecl);}
        break;
      case 278: // var_decl -> VAR, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 279: // Anon@28 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR_OUTPUT, ValueStack[ValueStack.Depth-1].VarQualifier, LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 280: // output_var_decl -> VAR_OUTPUT, opt_var_qualifier, Anon@28, var_declaration
{CurrentSemanticValue.Declaration = this.MakeFormalParameterDecl(STVarType.VAR_OUTPUT, ValueStack[ValueStack.Depth-3].VarQualifier, ValueStack[ValueStack.Depth-1].POUVarDecl);}
        break;
      case 281: // output_var_decl -> VAR_OUTPUT, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 282: // Anon@29 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR_OUTPUT, ValueStack[ValueStack.Depth-1].VarQualifier, LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 284: // global_var_decl -> VAR_GLOBAL, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 285: // Anon@30 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR_INOUT, ValueStack[ValueStack.Depth-1].VarQualifier,  LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 286: // inout_var_decl -> VAR_IN_OUT, opt_var_qualifier, Anon@30, var_declaration
{CurrentSemanticValue.Declaration = this.MakeFormalParameterDecl(STVarType.VAR_INOUT, ValueStack[ValueStack.Depth-3].VarQualifier, ValueStack[ValueStack.Depth-1].POUVarDecl);}
        break;
      case 287: // inout_var_decl -> VAR_IN_OUT, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 288: // Anon@31 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR_TEMP, ValueStack[ValueStack.Depth-1].VarQualifier,  LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 289: // temp_var_decl -> VAR_TEMP, opt_var_qualifier, Anon@31, var_declaration
{CurrentSemanticValue.Declaration = this.MakeLocalVariableDecl(STVarType.VAR_TEMP, ValueStack[ValueStack.Depth-3].VarQualifier, ValueStack[ValueStack.Depth-1].POUVarDecl);}
        break;
      case 290: // temp_var_decl -> VAR_TEMP, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 291: // Anon@32 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR_EXTERNAL, ValueStack[ValueStack.Depth-1].VarQualifier,  LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 293: // extern_var_decl -> VAR_EXTERNAL, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 294: // Anon@33 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR_ACCESS, ValueStack[ValueStack.Depth-1].VarQualifier,  LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 296: // access_var_decl -> VAR_ACCESS, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 297: // Anon@34 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR_CONFIG, ValueStack[ValueStack.Depth-1].VarQualifier,  LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 299: // config_var_decl -> VAR_CONFIG, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 300: // pou_variable_decl -> var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 301: // pou_variable_decl -> temp_var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 302: // pou_variable_decl -> extern_var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 303: // pou_variable_decl -> global_var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 304: // pou_variable_decl -> access_var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 305: // pou_variable_decl -> config_var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 306: // pou_variable_decl -> input_var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 307: // pou_variable_decl -> output_var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 308: // pou_variable_decl -> inout_var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 309: // pou_variable_decl -> data_type_decl
{CurrentSemanticValue.Declaration = null;}
        break;
      case 310: // pou_var_decl_list -> pou_variable_decl
{CurrentSemanticValue.POUVariableDecls = this.MakePOUVarDeclList(ValueStack[ValueStack.Depth-1].Declaration);}
        break;
      case 311: // pou_var_decl_list -> pou_var_decl_list, pou_variable_decl
{CurrentSemanticValue.POUVariableDecls = this.AddPOUVarDeclToList(ValueStack[ValueStack.Depth-2].POUVariableDecls, ValueStack[ValueStack.Depth-1].Declaration);}
        break;
      case 312: // pou_variable_decls -> pou_var_decl_list
{CurrentSemanticValue.POUVariableDecls = ValueStack[ValueStack.Depth-1].POUVariableDecls;}
        break;
      case 313: // pou_variable_decls -> /* empty */
{CurrentSemanticValue.POUVariableDecls = this.MakeEmptyPOUVarDecl();}
        break;
      case 314: // var_decl_list -> var_init_decl, semicolon
{CurrentSemanticValue.POUVarDecl = this.MakeVariableDeclList(ValueStack[ValueStack.Depth-2].VarInitDecl);}
        break;
      case 315: // var_decl_list -> var_decl_list, var_init_decl, semicolon
{CurrentSemanticValue.POUVarDecl = this.AddToVariableDeclList(ValueStack[ValueStack.Depth-3].POUVarDecl, ValueStack[ValueStack.Depth-2].VarInitDecl);}
        break;
      case 316: // var_declaration -> var_decl_list, END_VAR
{CurrentSemanticValue.POUVarDecl = ValueStack[ValueStack.Depth-2].POUVarDecl;}
        break;
      case 317: // var_declaration -> var_decl_list, error, END_VAR
{CurrentSemanticValue.POUVarDecl = ValueStack[ValueStack.Depth-3].POUVarDecl;this.yyerrok();}
        break;
      case 318: // var_init_decl -> identifier_list, ':', data_type, opt_decl_qualifier
{CurrentSemanticValue.VarInitDecl = this.InstallLocalVars(ValueStack[ValueStack.Depth-4].IdentifierList, ValueStack[ValueStack.Depth-2].DataType, ValueStack[ValueStack.Depth-1].EdgeQualifier, LocationStack[LocationStack.Depth-1]);}
        break;
      case 319: // Anon@35 -> /* empty */
{this.Push(ValueStack[ValueStack.Depth-2].DataType);}
        break;
      case 320: // var_init_decl -> identifier_list, ':', data_type, opt_decl_qualifier, Anon@35, 
                //                  ASSIGN, initial_value
{CurrentSemanticValue.VarInitDecl = this.InstallLocalVars(ValueStack[ValueStack.Depth-7].IdentifierList, ValueStack[ValueStack.Depth-5].DataType, ValueStack[ValueStack.Depth-4].EdgeQualifier, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3]);}
        break;
      case 321: // Anon@36 -> /* empty */
{}
        break;
      case 322: // var_init_decl -> IDENT, AT, DIRECT_VAR, Anon@36, ':', data_type_spec
{CurrentSemanticValue.VarInitDecl = this.InstallSymbolicVariable(ValueStack[ValueStack.Depth-6].Ident, ValueStack[ValueStack.Depth-1].TypeSpec, ValueStack[ValueStack.Depth-4].DirectVar, LocationStack[LocationStack.Depth-6]);}
        break;
      case 323: // Anon@37 -> /* empty */
{}
        break;
      case 324: // var_init_decl -> AT, DIRECT_VAR, Anon@37, ':', data_type_spec
{CurrentSemanticValue.VarInitDecl = this.InstallDirectVariable(ValueStack[ValueStack.Depth-4].DirectVar, ValueStack[ValueStack.Depth-1].TypeSpec, LocationStack[LocationStack.Depth-4]);}
        break;
      case 325: // opt_var_qualifier -> RETAIN
{CurrentSemanticValue.VarQualifier = STVarQualifier.RETAIN;}
        break;
      case 326: // opt_var_qualifier -> NON_RETAIN
{CurrentSemanticValue.VarQualifier = STVarQualifier.NON_RETAIN;}
        break;
      case 327: // opt_var_qualifier -> CONSTANT
{CurrentSemanticValue.VarQualifier = STVarQualifier.CONSTANT;}
        break;
      case 328: // opt_var_qualifier -> CONSTANT, RETAIN
{CurrentSemanticValue.VarQualifier = STVarQualifier.CONSTANT; this.report.SemanticError(173, LocationStack[LocationStack.Depth-2]);}
        break;
      case 329: // opt_var_qualifier -> RETAIN, CONSTANT
{CurrentSemanticValue.VarQualifier = STVarQualifier.CONSTANT; this.report.SemanticError(173, LocationStack[LocationStack.Depth-2]);}
        break;
      case 330: // opt_var_qualifier -> /* empty */
{CurrentSemanticValue.VarQualifier = STVarQualifier.NONE;}
        break;
      case 331: // opt_decl_qualifier -> R_EDGE
{CurrentSemanticValue.EdgeQualifier = STDeclQualifier.R_EDGE;}
        break;
      case 332: // opt_decl_qualifier -> F_EDGE
{CurrentSemanticValue.EdgeQualifier = STDeclQualifier.F_EDGE;}
        break;
      case 333: // opt_decl_qualifier -> READ_ONLY
{CurrentSemanticValue.EdgeQualifier = STDeclQualifier.READ_ONLY;}
        break;
      case 334: // opt_decl_qualifier -> WRITE_ONLY
{CurrentSemanticValue.EdgeQualifier = STDeclQualifier.WRITE_ONLY;}
        break;
      case 335: // opt_decl_qualifier -> /* empty */
{CurrentSemanticValue.EdgeQualifier = STDeclQualifier.NONE;}
        break;
      case 336: // reserved_word -> elementary_type
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].DataType.Name;}
        break;
      case 337: // reserved_word -> STRING
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 338: // reserved_word -> WSTRING
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 339: // reserved_word -> RETAIN
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 340: // reserved_word -> NON_RETAIN
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 341: // reserved_word -> CONSTANT
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 342: // reserved_word -> R_EDGE
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 343: // reserved_word -> F_EDGE
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 344: // reserved_word -> READ_ONLY
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 345: // reserved_word -> WRITE_ONLY
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 346: // reserved_word -> VAR_INPUT
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 347: // reserved_word -> VAR_OUTPUT
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 348: // reserved_word -> VAR_IN_OUT
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 349: // reserved_word -> VAR_GLOBAL
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 350: // reserved_word -> VAR_ACCESS
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 351: // reserved_word -> VAR_CONFIG
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 352: // reserved_word -> VAR_TEMP
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 353: // reserved_word -> VAR_EXTERNAL
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 354: // reserved_word -> VAR
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 355: // reserved_word -> END_VAR
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 356: // reserved_word -> AT
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 357: // reserved_word -> FUNCTION
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 358: // reserved_word -> END_FUNCTION
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 359: // reserved_word -> FUNCTION_BLOCK
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 360: // reserved_word -> END_FUNCTION_BLOCK
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 361: // reserved_word -> PROGRAM
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 362: // reserved_word -> END_PROGRAM
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 363: // reserved_word -> IF
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 364: // reserved_word -> THEN
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 365: // reserved_word -> ELSE
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 366: // reserved_word -> ELSIF
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 367: // reserved_word -> END_IF
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 368: // reserved_word -> WHILE
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 369: // reserved_word -> END_WHILE
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 370: // reserved_word -> REPEAT
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 371: // reserved_word -> UNTIL
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 372: // reserved_word -> END_REPEAT
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 373: // reserved_word -> FOR
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 374: // reserved_word -> TO
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 375: // reserved_word -> BY
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 376: // reserved_word -> DO
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 377: // reserved_word -> END_FOR
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 378: // reserved_word -> CASE
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 379: // reserved_word -> OF
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 380: // reserved_word -> END_CASE
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 381: // reserved_word -> EXIT
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 382: // reserved_word -> RETURN
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 383: // reserved_word -> TYPE
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 384: // reserved_word -> END_TYPE
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 385: // reserved_word -> ARRAY
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 386: // reserved_word -> STRUCT
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 387: // reserved_word -> END_STRUCT
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 388: // reserved_word -> AND
{CurrentSemanticValue.Ident = "AND";}
        break;
      case 389: // reserved_word -> NOT
{CurrentSemanticValue.Ident = "NOT";}
        break;
      case 390: // reserved_word -> IOR
{CurrentSemanticValue.Ident = "OR";}
        break;
      case 391: // reserved_word -> XOR
{CurrentSemanticValue.Ident = "XOR";}
        break;
      case 392: // reserved_word -> MOD
{CurrentSemanticValue.Ident = "MOD";}
        break;
      case 393: // reserved_word -> CONFIGURATION
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 394: // reserved_word -> END_CONFIGURATION
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 395: // reserved_word -> TRANSITION
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 396: // reserved_word -> END_TRANSITION
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 397: // reserved_word -> RESOURCE
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 398: // reserved_word -> END_RESOURCE
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 399: // reserved_word -> WITH
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 400: // reserved_word -> TASK
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
    }
#pragma warning restore 162, 1522
  }

  protected override string TerminalToString(int terminal)
  {
    if (aliasses != null && aliasses.ContainsKey(terminal))
        return aliasses[terminal];
    else if (((Tokens)terminal).ToString() != terminal.ToString(CultureInfo.InvariantCulture))
        return ((Tokens)terminal).ToString();
    else
        return CharToString((char)terminal);
  }

	public STLangParser(STLangScanner scanner, ErrorHandler errorHandler) : base(scanner) 
	{ 
		this.report = errorHandler;
		Expression.Report = errorHandler;
		TypeNode.Report = errorHandler;
		STLangSymbol.Report = errorHandler;
		errorHandler.Scanner = scanner;
		this.structNestingDepth = 0;
		this.forLoopVarKind = 0;
		this.loopNestingDepth = 0;
		this.functionValueDef = new List<bool>(){false};
		this.forLoopVarTable = new List<Hashtable>();
		this.forLoopDataList = new List<ForLoopData>();
		this.attributeStack = new SemanticStack(errorHandler);
		constantTable = new Dictionary<string, Expression>();
		this.rwMemoryManager = new RWMemoryLayoutManager();
		this.symbolTable = new STLangSymbolTable(errorHandler);
		this.caseLabelStack = null;
		this.isFunctionDecl = false;
		this.isProgramDecl  = false;
		this.isFunctionBlockDecl = false;
		this.variablePosition = 0;
		this.isTypeDecl = false;
		this.isIndexExpr = false;
		this.isSubrangeDecl = false;
		this.subrangeDataType = TypeNode.Error;
	}

	public int Errors
    {
        get { return this.report.Errors; }
    }

    public int Warnings
    {
        get { return this.report.Warnings; }
    }

    public IEnumerable<string> Messages
    {
        get { return this.report.ErrorMessages; }
    }

	private STVarType variableType;

	private STVarQualifier variableQualifier;

	private int structNestingDepth;

	private int forLoopVarKind;

	private int loopNestingDepth;

	private static Dictionary<string, Expression> constantTable;

	private readonly List<Hashtable> forLoopVarTable;

	private readonly List<bool> functionValueDef;

	private readonly ErrorHandler report;

	private readonly STLangSymbolTable symbolTable;

	private readonly SemanticStack attributeStack;

	private RWMemoryLayoutManager rwMemoryManager;

	private List<List<CaseLabel>> caseLabelStack;

	private List<ForLoopData> forLoopDataList;

	private List<CaseLabel> caseLabelList;

	private int variablePosition;

	private bool isProgramDecl;

	private bool isFunctionDecl;

	private bool isFunctionBlockDecl;

	private bool isTypeDecl;

	private bool isIndexExpr;

	private string derivedTypeName;

	private TypeNode subrangeDataType;

	private bool isSubrangeDecl;

	private void ReInitializeParser()
	{
		this.structNestingDepth = 0;
		this.forLoopVarKind = 0;
		this.loopNestingDepth = 0;
		this.forLoopVarTable.Clear();
		this.attributeStack.Clear();
		this.functionValueDef.Clear();
		this.functionValueDef.Add(false);
		constantTable = new Dictionary<string, Expression>();
		this.symbolTable.ReInitialize();
		this.isFunctionDecl = false;
		this.isProgramDecl  = false;
		this.isFunctionBlockDecl = false;
		this.variablePosition = 0;
		this.isTypeDecl = false;
		this.isIndexExpr = false;
		this.isSubrangeDecl = false;
		this.subrangeDataType = TypeNode.Error;
		this.rwMemoryManager = new RWMemoryLayoutManager();
	}

	private DataTypeSpec MakeDataTypeSpec(TypeNode dataType, STDeclQualifier declQualifier, LexLocation location)
	{
		if (declQualifier != STDeclQualifier.NONE)
		{
			if (dataType != TypeNode.Error && dataType != TypeNode.Bool)
			{
				this.report.SemanticError(120, location);
				declQualifier = STDeclQualifier.NONE;
			}
			if (this.structNestingDepth > 0)
			{
				this.report.SemanticError(121, location);
				declQualifier = STDeclQualifier.NONE;
			}
		}
		return new DataTypeSpec(dataType, declQualifier, dataType.DefaultValue);
	}

	private DataTypeSpec MakeDataTypeSpec(TypeNode dataType, STDeclQualifier declQualifier, Expression initialValue, LexLocation location)
	{
		if (declQualifier != STDeclQualifier.NONE)
		{
			if (dataType != TypeNode.Bool)
			{
				this.report.SemanticError(120, location);
				declQualifier = STDeclQualifier.NONE;
			}
			if (this.structNestingDepth > 0)
			{
				this.report.SemanticError(121, location);
				declQualifier = STDeclQualifier.NONE;
			}
		}
		this.Pop();
		return new DataTypeSpec(dataType, declQualifier, initialValue);
	}

	private List<string> MakeIdentifierList(string ident, LexLocation location)
	{
		List<string> identList = new List<string>();
		if (this.symbolTable.IsValidUserDefinedSymbol(ident, location))
			identList.Add(ident);
		return identList;
	}

	private List<string> AddIdentToList(List<string> identList, string ident, LexLocation location)
	{
		if (identList == null)
			return this.MakeIdentifierList(ident, location);
		else if (! identList.IsUnique(ident))
			this.report.SemanticError(2, ident, location);
		else if (this.symbolTable.IsValidUserDefinedSymbol(ident, location))
			identList.Add(ident);
		return identList;
	}

	// void RegisterForLoopVariable(InstanceSymbol symbol, ForLoopVariableType loopVarType)
	//
	// Keeps track of variables used as control variables, start-, stop-values and increments in for-loops.
	// This information is used to check that these variables aren't changed inside the loop.
	//
	private void RegisterForLoopVariable(InstanceSymbol symbol, ForLoopVariableType loopVarType, LexLocation location)
	{
		if (loopVarType == ForLoopVariableType.CONTROL_VARIABLE)
		{
			// Make sure that the variable isn't already used as a control 
			// variable, start-value or stop-value in any outer for-loop.

			foreach (Hashtable loopVarTable in this.forLoopVarTable)
			{
				if (loopVarTable.Contains(symbol))
				{
					ForLoopVariableType forLoopVarType;
					forLoopVarType = (ForLoopVariableType)loopVarTable[symbol];
					if ((forLoopVarType & ForLoopVariableType.CONTROL_VARIABLE) != 0)
						this.report.SemanticError(125, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.START_VARIABLE) != 0)
						this.report.SemanticError(126, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.STOP_VARIABLE) != 0)
						this.report.SemanticError(127, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.INCR_VARIABLE) != 0)
						this.report.Warning(15, symbol.Name, location);
				}
			}
			Hashtable currentLoopVarTable = new Hashtable();
			currentLoopVarTable[symbol] = ForLoopVariableType.CONTROL_VARIABLE;
			this.forLoopVarTable.Add(currentLoopVarTable);
		}
		else {
			Hashtable loopVarTable = this.forLoopVarTable.Last();
			if (loopVarTable == null)
				throw new STLangCompilerError("For-loop variable table is empty.");
			else if (! loopVarTable.Contains(symbol))
				loopVarTable[symbol] = loopVarType;
			else {
				ForLoopVariableType forLoopVarType;

				forLoopVarType = (ForLoopVariableType)loopVarTable[symbol];
				if ((forLoopVarType & ForLoopVariableType.CONTROL_VARIABLE) == 0)
				{
					forLoopVarType |= loopVarType;
					loopVarTable[symbol] = forLoopVarType;
				}
				else if (loopVarType == ForLoopVariableType.START_VARIABLE)
					this.report.SemanticError(126, symbol.Name, location);
				else if (loopVarType == ForLoopVariableType.STOP_VARIABLE)
					this.report.SemanticError(127, symbol.Name, location);
				else if (loopVarType == ForLoopVariableType.INCR_VARIABLE)
					this.report.Warning(15, symbol.Name, location);
			}
		}
	}


	private void PopForLoopVariables()
	{
		if (this.forLoopVarTable.Count > 0)
		{
			Hashtable currentLoopVars = this.forLoopVarTable.Last();
			this.forLoopVarTable.Remove(currentLoopVars);
			ForLoopData forLoopData = this.forLoopDataList.Last();
			this.forLoopDataList.Remove(forLoopData);
			forLoopData.ControlVariable.Symbol.IsForLoopCtrlVar = false;
		}
	}

	private void Push(Expression expression)
	{
		if (expression == null)
			this.attributeStack.Push(TypeNode.Error);
		else
			this.attributeStack.Push(expression.DataType);
	}

	private void PushTop()
	{
		if (this.functionValueDef.Count == 0)
			throw new STLangCompilerError("Function value stack is empty.");
		else {
			bool topValue = this.functionValueDef.Last();
			this.functionValueDef.Add(topValue);
		}
	}

	private void PushCaseLabelList()
	{
		if (this.caseLabelStack == null)
		{
			this.caseLabelStack = new List<List<CaseLabel>>();
			this.caseLabelList = new List<CaseLabel>();
			this.caseLabelStack.Add(this.caseLabelList);
		}
		else {
			this.caseLabelStack.Add(this.caseLabelList);
			this.caseLabelList = new List<CaseLabel>();
		}
	}

	private void PopCaseLabelList()
	{
		if (this.caseLabelStack.Count == 0)
			throw new STLangCompilerError("PopCaseLabelList(): Case label stack is empty.");
		else {
			int lastIndex = this.caseLabelStack.Count - 1;
			this.caseLabelStack.RemoveAt(lastIndex);
			if (this.caseLabelStack.Count > 0)
                this.caseLabelList = this.caseLabelStack.Last();
            else {
				this.caseLabelStack = null;
				this.caseLabelList = null;
			} 
		}
	}

	private void CopyValue(bool funcValueDefined)
	{
		if (this.functionValueDef.Count == 0)
			throw new STLangCompilerError("CopyValue(): Function value stack is empty.");
		else {
			bool currentValue = this.functionValueDef.Last();
			if (funcValueDefined && ! currentValue)
			{
				int topIndex = this.functionValueDef.Count - 1;
				this.functionValueDef[topIndex] = true;
			}
		}
	}

	private void PopTop()
	{
		if (this.functionValueDef.Count == 0)
			throw new STLangCompilerError("Function value stack is empty.");
		else if (this.functionValueDef.Count > 1)
		{
			int topIndex = this.functionValueDef.Count - 1;
			this.functionValueDef.RemoveAt(topIndex);
		}
	}

	private void CheckFunctionValueIsDefined(LexLocation location)
	{
		if (this.functionValueDef.Count == 0)
			throw new STLangCompilerError("Function value stack is empty.");
		else {
			bool functionValueIsDefined = this.functionValueDef.Last();
			if (! functionValueIsDefined)
				this.report.SemanticError(13, location);
		}
	}

	private StatementList CheckFunctionValueDefinition(StatementList statementList, LexLocation loc)
	{
		this.CheckFunctionValueIsDefined(loc);
		if (statementList == null)
			statementList = StatementList.Empty;
		return statementList;
	}

	private void SaveFunctionDefinition(POUVarDeclarations varDecls, StatementList functionBody)
	{
		this.symbolTable.Pop();
		if (! functionBody.POUReturns)
			functionBody.Add(new ReturnStatement());  // Make sure the function returns
		this.rwMemoryManager.SetSegmentAlignment(sizeof(double));
		varDecls.SetDeclarationSize(this.rwMemoryManager);
		this.symbolTable.SaveFunctionDefinition(functionBody, constantTable, this.rwMemoryManager);
	}

	private void SaveFunctionBlockDeclaration(POUVarDeclarations fbVarDecls, StatementList functionBlockBody)
	{
		this.symbolTable.Pop();
		if (! functionBlockBody.POUReturns)
			functionBlockBody.Add(new ReturnStatement()); // Make sure the function block returns
		this.rwMemoryManager.SetSegmentAlignment(sizeof(double));
		fbVarDecls.SetDeclarationSize(this.rwMemoryManager);
		this.symbolTable.SaveFunctionBlockBody(functionBlockBody, constantTable, this.rwMemoryManager);
	}

	private void CheckIfArrayType(LexLocation location)
	{
		this.attributeStack.CheckIfArrayType(location);
	}

	private void PushArrayElemType(LexLocation location)
	{
		this.attributeStack.PushArrayElementType(location);
	}

	private void Push(TypeNode dataType)
	{
		this.attributeStack.Push(dataType);
	}

	private void Pop()
	{
		this.attributeStack.Pop();
	}

	private TypeNode LargestDataType(Expression expr1, Expression expr2)
	{
		return expr1.DataType.Size > expr2.DataType.Size ? expr1.DataType : expr2.DataType;
	}

	private StructMemberInit MakeStructMemberInit(string name, Expression initValue)
	{
		TypeNode fieldDataType = this.attributeStack.Top;
		this.Pop();
		if (initValue == null)
			return new StructMemberInit(name, fieldDataType.DefaultValue);
		else
			return new StructMemberInit(name, initValue);
	}

	private InitializerList MakeInitializerSequence(Expression initializer, LexLocation loc)
	{
		TypeNode dataType = this.attributeStack.Top;
		InitializerSequence initSequence = new InitializerSequence(dataType);
		initSequence.Add(initializer, loc);
		return initSequence;
	}

	private InitializerList AddInitializerToSequence(InitializerList initSequence, Expression initializer, LexLocation loc)
	{
		if (initSequence != null)
			initSequence.Add(initializer, loc);
		return initSequence;
	}

	private TypeNode MakeInitializerDataType(uint elementCount, TypeNode elementType)
	{
		string typeID;
		TypeNode arrayType;
		
		typeID = string.Format("[0..{0}]{1}", elementCount - 1, elementType.TypeID);
		if (TypeNode.LookUpType(typeID, out arrayType))
			return arrayType;
		else {
			int upper = (int)elementCount - 1;
			long byteCount = elementCount * elementType.Size;
			Expression size =  MakeIntConstant(byteCount);
			string typeName = string.Format("ARRAY [0..{0}] OF {1}", upper, elementType.Name);
			return new ArrayType(typeName, 0, upper, (uint)byteCount, size, elementType, elementType, typeID);
		}
	}

	private InitializerList MakeArrayOfStructInitializer(TypeNode array, FieldSymbol firstField, uint elementCount)
	{
		TypeNode dataType;
		TypeNode fieldDataType;
        InitializerList arrayInit;
		FieldSymbol field = firstField;
		Expression size   = MakeIntConstant(array.Size);
		ArrayOfStructInitializer arrayOfStructInitializer;

		arrayOfStructInitializer = new ArrayOfStructInitializer(array, size);
		while (field != null)
		{
			fieldDataType = field.DataType;
			if (fieldDataType.IsElementaryType || fieldDataType.IsTextType)
			{
				dataType = this.MakeInitializerDataType(elementCount, fieldDataType);
				size = MakeIntConstant((long)dataType.Size);
				arrayInit = new ArrayInitializer(dataType, size);
			}
			else if (fieldDataType.IsStructType)
			{
				StructType struct2 = (StructType)fieldDataType.BaseType;
				FieldSymbol firstField2 = struct2.FirstField;
				dataType = this.MakeInitializerDataType(elementCount, fieldDataType);
				arrayInit = this.MakeArrayOfStructInitializer(dataType, firstField2, elementCount);
			}
			else if (fieldDataType.IsArrayType)
			{
				ArrayType array2 = (ArrayType)fieldDataType.BaseType;
				TypeNode elementType = array2.BasicElementType;
				uint elemCount2 = (array2.Size/elementType.Size)*elementCount;
				dataType = this.MakeInitializerDataType(elemCount2, elementType);
				if (elementType.IsElementaryType || elementType.IsTextType)
				{
					size = MakeIntConstant((long)dataType.Size);
					arrayInit = new ArrayInitializer(dataType, size);
				}
                else if (elementType.IsStructType)
                {
                    StructType struct2 = (StructType)elementType.BaseType;
					FieldSymbol firstField2 = struct2.FirstField;
                    arrayInit = this.MakeArrayOfStructInitializer(dataType, firstField2, elemCount2);
                }
				else if (elementType.IsFunctionBlockType)
                {
					//
					// IEC 61131-3 does not allow arrays of function blocks (yet).
					//
                    size = MakeIntConstant((long)elementType.Size);
					arrayInit = new ArrayInitializer(fieldDataType, size); 
                }
				else if (elementType == TypeNode.Error)
				{
					size = MakeIntConstant((long)elementType.Size);
					arrayInit = new ArrayInitializer(elementType, size);
				}
                else
                {
                    string msg = "MakeArrayOfStructInitializer(): Unknown ";
                    msg += "type of array element " + elementType.Name;
                    throw new STLangCompilerError(msg);
                }
			}
			else if (fieldDataType.IsFunctionBlockType)
			{
				//
				// IEC 61131-3 does not allow arrays of function blocks (yet).
				//
				size = MakeIntConstant((long)fieldDataType.Size);
				arrayInit = new ArrayInitializer(fieldDataType, size); 
			}
			else if (fieldDataType == TypeNode.Error)
			{
				size = MakeIntConstant((long)fieldDataType.Size);
				arrayInit = new ArrayInitializer(fieldDataType, size);
			}
			else {
				string msg;
				msg = "MakeArrayOfStructInitializer(): Unknown type " + fieldDataType.Name;
				throw new STLangCompilerError(msg);
			}
			arrayOfStructInitializer.AddInitializer(field.Name, arrayInit);
			field = field.Next;
		}
		return arrayOfStructInitializer;
	}

	private InitializerList MakeArrayInitializer(Expression initializer, LexLocation location)
	{
		InitializerList arrayInitList;
		TypeNode dataType = this.attributeStack.Top2;
		if (initializer == null || ! dataType.IsArrayType)
		{
			Expression size = MakeIntConstant((long)1000);
			arrayInitList = new ArrayInitializer(TypeNode.Error, size);
			arrayInitList.Add(initializer, location);
			return arrayInitList;
		}
		else {
			ArrayType array = (ArrayType)dataType;
			TypeNode elementType = array.BasicElementType;
		
			if (elementType.IsElementaryType || elementType.IsTextType)
			{
				Expression size = MakeIntConstant((long)dataType.Size);
				arrayInitList = new ArrayInitializer(dataType, size);
				arrayInitList.Add(initializer, location);
				return arrayInitList;
			}
			else if (elementType.IsFunctionBlockType)
			{
				//
				// IEC 61131-3 does not allow arrays of function blocks (yet).
				//
				Expression size = MakeIntConstant((long)dataType.Size);
				arrayInitList = new ArrayInitializer(dataType, size);
				return arrayInitList; 
			}
			else if (elementType.IsStructType)
			{
				uint elemCount = array.Size/elementType.Size;
				StructType structure = (StructType)elementType.BaseType;
				FieldSymbol firstField = structure.FirstField;
				arrayInitList = this.MakeArrayOfStructInitializer(array, firstField, elemCount);
				arrayInitList.Add(initializer, location);
				return arrayInitList;
			}
		}
		throw new STLangCompilerError(Resources.MAKEARRAYINITLIST2);
	}

	private InitializerList AddArrayInitializer(InitializerList arrayInitList, Expression initializer, LexLocation loc)
	{
		if (arrayInitList == null)
		{
			TypeNode dataType = this.attributeStack.Top2;
			initializer = dataType.DefaultValue;
		}
		arrayInitList.Add(initializer, loc);
		return arrayInitList;
	}

	private InitializerList WrapUpArrayInitList(InitializerList arrayInitList, LexLocation location)
	{
		this.attributeStack.Pop();
		if (arrayInitList == null)
			return arrayInitList;
		else if (arrayInitList.DataType == TypeNode.Error)
			return arrayInitList;
		else {
			arrayInitList.CheckInitListSize(location);
			if (! arrayInitList.IsConstant)
				return arrayInitList;
			else {
				string key = arrayInitList.GetKey();
				if (! constantTable.ContainsKey(key))
				{
					constantTable[key] = arrayInitList;
					return arrayInitList;
				}
				else {
					Expression initializer;
					initializer = (Expression)constantTable[key];
					if (initializer is ArrayInitializer)
					{
						ArrayInitializer arrayInitList2;
						arrayInitList2 = (ArrayInitializer)initializer;
						if (arrayInitList2.DataType == arrayInitList.DataType)
							return arrayInitList2;
					}
					else if (initializer is ArrayOfStructInitializer)
					{
						ArrayOfStructInitializer arrayInitList2;
						arrayInitList2 = (ArrayOfStructInitializer)initializer;
						if (arrayInitList2.DataType == arrayInitList.DataType)
							return arrayInitList2;
					}
					throw new STLangCompilerError(Resources.WRAPUPARRAYINILIST);
				} 
			}
		}
	}

	private InitializerList WrapUpStructInitList(InitializerList structInitList, LexLocation location)
	{
		if (structInitList == null)
			return structInitList;
		else if (structInitList.DataType == TypeNode.Error)
			return structInitList;
		else {
			structInitList.CheckInitListSize(location);
			if (! structInitList.IsConstant)
				return structInitList;
			else {
				string key = structInitList.GetKey();
				if (! constantTable.ContainsKey(key))
				{
					constantTable[key] = structInitList;
					return structInitList;
				}
				else {
					Expression initializer;
					initializer = (Expression)constantTable[key];
					if (initializer is StructInitializer)
					{
						StructInitializer structInitList2;
						structInitList2 = (StructInitializer)initializer;
						if (structInitList2.DataType == structInitList.DataType)
							return structInitList2;
					}
					throw new STLangCompilerError(Resources.WRAPUPARRAYINILIST);
				}
			}
		}
	}

	private InitializerList MakeStructInitializer(Expression initializer, LexLocation location)
	{
		TypeNode dataType = this.attributeStack.Top;
		Expression size = MakeIntConstant((long)dataType.Size);
		if (dataType.IsStructType)
		{
			StructInitializer structInitList = new StructInitializer(dataType, size);
			structInitList.Add(initializer, location);
			return structInitList;
		}
		else if (dataType.IsFunctionBlockType)
		{
			FunctionBlockInitializer functionBlockInitList;
			functionBlockInitList = new FunctionBlockInitializer(dataType, size);
			functionBlockInitList.Add(initializer, location);
			return functionBlockInitList;
		}
		else 
		{
			if (dataType != TypeNode.Error)
				this.report.SemanticError(65, dataType.Name, location);
			return new StructInitializer(TypeNode.Error, size);
		}
	}

	private InitializerList AddStructMemberInitializer(InitializerList structInitList, Expression initializer, LexLocation loc)
	{
		if (structInitList != null)
			structInitList.Add(initializer, loc);
		return structInitList;
	}

	private StructDeclaration MakeStructMemberList(StructMemberDeclaration member)
	{	
		StructDeclaration structure = new StructDeclaration();
		if (member != null)
		{
			if (! structure.Add(member))
				this.report.SemanticError(62, member.Name, member.Location);
		}
		return structure;
	}
	
	private StructDeclaration AddStructMemberDecl(StructDeclaration structure, StructMemberDeclaration member, LexLocation loc)
	{
		if (structure != null && member != null)
		{
			if (! structure.Add(member))
				this.report.SemanticError(62, member.Name, member.Location);
		}
		return structure;
	}

	private StructMemberDeclaration MakeStructMemberDecl(string name, DataTypeSpec member, LexLocation loc)
	{
		return new StructMemberDeclaration(name, member.DataType, member.InitialValue, loc);
	}

	private int BitCount(ulong value)
	{
		int count = 0;
		while (value > 0)
		{
			count++;
			value >>= 1;
		}
		return count;
	}

	private ulong IntPower(ulong value, int power)
	{
		if (power == 0)
			return 1;
		else if ((power & 1) == 0)
			return this.IntPower(value*value, power >> 1);
		else if ((value & 1) == 0)
			return this.IntPower(value >> 1, power) << power;
		else
			return value * IntPower(value, power - 1);
	}

	private long IntPower(long value, int power)
	{
		if (power == 0)
			return 1;
		else if ((power & 1) == 0)
			return this.IntPower(value*value, power >> 1);
		else if ((value & 1) == 0)
			return this.IntPower(value >> 1, power) << power;
		else
			return value * IntPower(value, power - 1);
	}

	private bool IsPowerOf2(ulong value, out int power)
	{
		power = 0;
		if (value <= 1)
			return false;
		else {
			while ((value & 1) == 0)
			{
				power++;
				value >>= 1;
			}
			return value == 1;
		}
	}

	private Expression CheckForLoopIncr(Expression expr, LexLocation location)
	{
		if (expr == null)
			return Expression.Error;
		else if (expr is FunctionName)
		{
			this.report.SemanticError(148, expr.ToString(), location);
			return Expression.Error;
		}
		else if (expr.DataType == TypeNode.Error)
			return expr;
		else if (expr.DataType.IsSignedIntType)
			return expr;
		else {
			this.report.SemanticError(135, expr.ToString(), location);
			return Expression.Error;
		}
	}

	private Expression MakeIntConstant(TokenInt token)
	{
		ulong value = token.Value;
		string lexeme = token.ToString();
		if ((value & 0x8000000000000000) != 0)
			return new ULIntConstant(value, lexeme);
		else if (TypeNode.SInt.IsInRange((long)value))
			return new SIntConstant((sbyte)value, lexeme);
		else if (TypeNode.Int.IsInRange((long)value))
			return new IntConstant((short)value, lexeme);
		else if (TypeNode.DInt.IsInRange((long)value))
			return new DIntConstant((int)value, lexeme);
		else
			return new LIntConstant((long)value, lexeme);
	}

	private Expression MakeIntConstant(ulong value)
	{
		string strValue = value.ToString();
		if (constantTable.ContainsKey(strValue))
			return (Expression)constantTable[strValue];
		else {
			Expression intConst;
			if (TypeNode.USInt.IsInRange(value))
				intConst = new USIntConstant((byte)value, strValue);
			else if (TypeNode.UInt.IsInRange(value))
				intConst = new UIntConstant((ushort)value, strValue);
			else if (TypeNode.UDInt.IsInRange(value))
				intConst = new UDIntConstant((uint)value, strValue);
			else 
				intConst = new ULIntConstant((ulong)value, strValue);
			constantTable[strValue] = intConst;
			return intConst;
		}
	}

	public static Expression MakeIntConstant(long value)
	{
		string strValue = value.ToString();
		if (constantTable.ContainsKey(strValue))
			return (Expression)constantTable[strValue];
		else {
			Expression intConst;
			if (TypeNode.SInt.IsInRange(value))
				intConst = new SIntConstant((sbyte)value, strValue);
			else if (TypeNode.Int.IsInRange(value))
				intConst = new IntConstant((short)value, strValue);
			else if (TypeNode.DInt.IsInRange(value))
				intConst = new DIntConstant((int)value, strValue);
			else
				intConst = new LIntConstant((long)value, strValue);
			constantTable[strValue] = intConst;
			return intConst;
		}
	}

	private Expression MakeConstant(ulong value, TypeNode bitStringType)
	{
		if (bitStringType == TypeNode.Bool)
			return this.MakeConstant(value != 0);
		else {
			string typeName = bitStringType.Name;
			string strValue = typeName + "#" + value.ToString();
			if (constantTable.ContainsKey(strValue))
				return (Expression)constantTable[strValue];
			else {
				Expression bitStringConst;
				if (TypeNode.Byte.IsInRange(value))
					bitStringConst = new ByteConstant((byte)value, strValue);
				else if (TypeNode.Word.IsInRange(value))
					bitStringConst = new WordConstant((ushort)value, strValue);
				else if (TypeNode.DInt.IsInRange(value))
					bitStringConst = new DWordConstant((uint)value, strValue);
				else
					bitStringConst = new LWordConstant((ulong)value, strValue);
				constantTable[strValue] = bitStringConst;
				return bitStringConst;
			}
		}
	}

	private Expression MakeConstant(bool value)
	{
		string stringValue = value.ToString();
		string keyValue = stringValue.ToUpper();
		if (constantTable.ContainsKey(keyValue))
			return (Expression)constantTable[keyValue];
		else
		{
			Expression expr = new BoolConstant(value, stringValue);
			constantTable[keyValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(bool value, string boolStr)
	{
		string keyValue = boolStr.ToUpper();
		if (constantTable.ContainsKey(keyValue))
			return (Expression)constantTable[keyValue];
		else
		{
			Expression expr = new BoolConstant(value, boolStr);
			constantTable[keyValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(string stringValue, LexLocation location)
	{
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			long length = stringValue.Length;
			Expression size = MakeIntConstant(length);
			TypeNode stringType = this.MakeStringType(size, location);
			Expression expr = new StringConstant(stringValue, stringType);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeWString(string stringValue, LexLocation location)
	{
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			long length = stringValue.Length;
			Expression size = MakeIntConstant(length);
			TypeNode stringType = this.MakeWStringType(size, location);
			Expression expr = new StringConstant(stringValue, stringType);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenTypedInt token, LexLocation location)
	{
		string lexeme = token.ToString();
		string keyValue = lexeme.RemoveChar('_').ToUpper();
		ulong value = token.Value;
		if (constantTable.ContainsKey(keyValue))
			return (Expression)constantTable[keyValue];
		else {
			Expression constant = null;
			switch (token.IntType)
			{
			case Tokens.INT:
				constant = new IntConstant((short)value, lexeme);
				break;
			case Tokens.SINT:
				constant = new SIntConstant((sbyte)value, lexeme);
				break;
			case Tokens.DINT:
				constant = new DIntConstant((int)value, lexeme);
				break;
			case Tokens.LINT:
				constant = new LIntConstant((long)value, lexeme);
				break;
			case Tokens.USINT:
				constant = new USIntConstant((byte)value, lexeme);
				break;
			case Tokens.UINT:
				constant = new UIntConstant((ushort)value, lexeme);
				break;
			case Tokens.UDINT:
				constant = new UDIntConstant((uint)value, lexeme);
				break;
			case Tokens.ULINT:
				constant = new ULIntConstant(value, lexeme);
				break;
			case Tokens.BOOL:
				constant = new BoolConstant(value != 0, lexeme);
				break;
			case Tokens.BYTE:
				constant = new ByteConstant((byte)value, lexeme);
				break;
			case Tokens.WORD:
				constant = new WordConstant((ushort)value, lexeme);
				break;
			case Tokens.DWORD:
				constant = new DWordConstant((uint)value, lexeme);
				break;
			case Tokens.LWORD:
				constant = new LWordConstant(value, lexeme);
				break;
			case Tokens.REAL:
				constant = new RealConstant((float)value);
				break;
			case Tokens.LREAL:
				constant = new LRealConstant((double)value);
				break;
			case Tokens.IDENT:
				{
					STLangSymbol symbol;
					string typeName = token.TypeName;
					if (! this.symbolTable.Lookup(typeName, out symbol, location))
					{
						this.report.SemanticError(1, typeName, location);
						return Expression.Error;
					}
					else if (! (symbol is TypeNameSymbol))
					{
						this.report.SemanticError(24, typeName, location);
						return Expression.Error;
					}
					else if (! symbol.DataType.IsElementaryType)
					{
						this.report.SemanticError(114, value, symbol.DataType.Name, location);
						return Expression.Error;
					}
					else {
						TypeNode dataType = symbol.DataType;
						keyValue = dataType.Name + "#" + value;
						keyValue = keyValue.RemoveChar('_').ToUpper();
						if (constantTable.ContainsKey(keyValue))
							return (Expression)constantTable[keyValue];
						else if (dataType == TypeNode.SInt)
							constant = new SIntConstant((sbyte)value, lexeme);
						else if (dataType == TypeNode.Int)
							constant = new IntConstant((short)value, lexeme);
						else if (dataType == TypeNode.DInt)
							constant = new DIntConstant((int)value, lexeme);
						else if (dataType == TypeNode.LInt)
							constant = new LIntConstant((long)value, lexeme);
						else if (dataType == TypeNode.USInt)
							constant = new USIntConstant((byte)value, lexeme);
						else if (dataType == TypeNode.UInt)
							constant = new UIntConstant((ushort)value, lexeme);
						else if (dataType == TypeNode.UDInt)
							constant = new UDIntConstant((uint)value, lexeme);
						else if (dataType == TypeNode.ULInt)
							constant = new ULIntConstant((ulong)value, lexeme);
						else if (dataType == TypeNode.Bool)
							constant = new BoolConstant(value != 0, lexeme);
						else if (dataType == TypeNode.Byte)
							constant = new ByteConstant((byte)value, lexeme);
						else if (dataType == TypeNode.Word)
							constant = new WordConstant((ushort)value, lexeme);
						else if (dataType == TypeNode.DWord)
							constant = new DWordConstant((uint)value, lexeme);
						else if (dataType == TypeNode.LWord)
							constant = new LWordConstant((ulong)value, lexeme);
						else if (dataType == TypeNode.Real)
							constant = new RealConstant((float)value);
						else if (dataType == TypeNode.LReal)
							constant = new LRealConstant((double)value);
						else {
							this.report.SemanticError(114, value, dataType.Name, location);
							return Expression.Error;
						}

					}
				}
				break;
			case Tokens.DATE:
			case Tokens.DATE_AND_TIME:
			case Tokens.DT:
			case Tokens.TIME:
			case Tokens.TIME_OF_DAY:
			case Tokens.TOD:
			case Tokens.STRING:
			case Tokens.WSTRING:
			default:
				this.report.SemanticError(114, value, token.IntType.ToString(), location);
				return Expression.Error;
			}
			if (constant != null)
			{
				TypeNode dataType = constant.DataType;
				constantTable[keyValue] = constant;
				return constant;
			}
		}
		return Expression.Error;
	}

	private Expression MakeConstant(TokenTypedReal token, LexLocation location)
	{
		string lexeme = token.ToString();
		double value = token.Value;
		string keyValue = lexeme.RemoveChar('_').ToUpper();
		if (constantTable.ContainsKey(keyValue))
			return (Expression)constantTable[keyValue];
		else {
			Expression constant = null;
			switch (token.RealType)
			{
			case Tokens.REAL:
				constant = new RealConstant((float)value, lexeme);
				break;
			case Tokens.LREAL:
				constant = new LRealConstant(value);
				break;
			case Tokens.INT:
				constant = new IntConstant((short)value, lexeme);
				break;
			case Tokens.SINT:
				constant = new SIntConstant((sbyte)value, lexeme);
				break;
			case Tokens.DINT:
				constant = new DIntConstant((int)value, lexeme);
				break;
			case Tokens.LINT:
				constant = new LIntConstant((long)value, lexeme);
				break;
			case Tokens.USINT:
				constant = new USIntConstant((byte)value, lexeme);
				break;
			case Tokens.UINT:
				constant = new UIntConstant((ushort)value, lexeme);
				break;
			case Tokens.UDINT:
				constant = new UDIntConstant((uint)value, lexeme);
				break;
			case Tokens.ULINT:
				constant = new ULIntConstant((ulong)value, lexeme);
				break;
			case Tokens.BOOL:
				constant = new BoolConstant(value != 0, lexeme);
				break;
			case Tokens.BYTE:
				constant = new ByteConstant((byte)value, lexeme);
				break;
			case Tokens.WORD:
				constant = new WordConstant((ushort)value, lexeme);
				break;
			case Tokens.DWORD:
				constant = new DWordConstant((uint)value, lexeme);
				break;
			case Tokens.LWORD:
				constant = new LWordConstant((ulong)value, lexeme);
				break;
			case Tokens.IDENT:
			{
				STLangSymbol symbol;
				string typeName = token.TypeName;
				if (! this.symbolTable.Lookup(typeName, out symbol, location))
				{
					this.report.SemanticError(1, typeName, location);
					return MakeConstant(value);
				}
				else if (! (symbol is TypeNameSymbol))
				{
					this.report.SemanticError(24, typeName, location);
					return MakeConstant(value);
				}
				else {
					TypeNode dataType = symbol.DataType;
					lexeme = dataType.Name + "#" + value;
					keyValue = lexeme.RemoveChar('_').ToUpper();
					if (constantTable.ContainsKey(keyValue))
						return (Expression)constantTable[keyValue];
					else if (dataType == TypeNode.SInt)
						constant = new SIntConstant((sbyte)value, lexeme);
					else if (dataType == TypeNode.Int)
						constant = new IntConstant((short)value, lexeme);
					else if (dataType == TypeNode.DInt)
						constant = new DIntConstant((int)value, lexeme);
					else if (dataType == TypeNode.LInt)
						constant = new LIntConstant((long)value, lexeme);
					else if (dataType == TypeNode.USInt)
						constant = new USIntConstant((byte)value, lexeme);
					else if (dataType == TypeNode.UInt)
						constant = new UIntConstant((ushort)value, lexeme);
					else if (dataType == TypeNode.UDInt)
						constant = new UDIntConstant((uint)value, lexeme);
					else if (dataType == TypeNode.ULInt)
						constant = new ULIntConstant((ulong)value, lexeme);
					else if (dataType == TypeNode.Bool)
						constant = new BoolConstant(value != 0.0, lexeme);
					else if (dataType == TypeNode.Byte)
						constant = new ByteConstant((byte)value, lexeme);
					else if (dataType == TypeNode.Word)
						constant = new WordConstant((ushort)value, lexeme);
					else if (dataType == TypeNode.DWord)
						constant = new DWordConstant((uint)value, lexeme);
					else if (dataType == TypeNode.LWord)
						constant = new LWordConstant((ulong)value, lexeme);
					else if (dataType == TypeNode.Real)
						constant = new RealConstant((float)value, lexeme);
					else if (dataType == TypeNode.LReal)
						constant = new LRealConstant(value, lexeme);
					else {
						this.report.SemanticError(114, value, dataType.Name, location);
						return Expression.Error;
					}
				}
			}
			break;
			default:
				this.report.SyntaxError(111, token.TypeName, location);
				return Expression.Error;
			}
			if (constant != null)
			{
				TypeNode dataType = constant.DataType;
				constantTable[keyValue] = constant;
				return constant;
			}
		}
		return Expression.Error;
	}

	private Expression MakeConstant(TokenTypedEnum enumConst, LexLocation location)
	{
		if (enumConst.TypeToken != Tokens.IDENT || enumConst.ValueToken != Tokens.IDENT)
			return Expression.Error;
		else {
			STLangSymbol symbol;
			string qualifiedName = enumConst.ToString();
			string keyValue = qualifiedName.ToUpper();
			if (constantTable.ContainsKey(keyValue))
				return (Expression)constantTable[keyValue];
			else if (this.symbolTable.Lookup(qualifiedName, out symbol, location))
			{
				Expression constant = symbol.MakeSyntaxTreeNode(location);
				constantTable[keyValue] = constant;
				return constant;
			}
			else {
				STLangSymbol enumSymbol;
				string enumTypeName = enumConst.TypeName;
				string enumValue = enumConst.Value;
				this.report.SemanticError(0, qualifiedName, location);
				if (! this.symbolTable.Lookup(enumTypeName, out symbol, location))
					this.report.SemanticError(0, enumTypeName, location);
				else if (! (symbol is TypeNameSymbol))
					this.report.SemanticError(24, enumTypeName, location);
				else if (! symbol.DataType.IsEnumeratedType)
					this.report.SemanticError(-7, enumTypeName, location);
				if (! this.symbolTable.Lookup(enumValue, out enumSymbol, location))
					this.report.SemanticError(0, enumValue, location);
				else if (! (enumSymbol is EnumSymbol))
					this.report.SemanticError(-8, enumValue, location);
				return Expression.Error;
			}
		}
	}

	private SubRange MakeEnumSubRange(Expression lower, Expression upper, LexLocation location)
	{
		int lowerBound = Convert.ToInt32(lower.Evaluate());
		int upperBound = Convert.ToInt32(upper.Evaluate());
		if (lowerBound > upperBound)
		{
			string interval = lower + ".." + upper;
			this.report.SemanticError(16, interval, location);
			int tmp = lowerBound;
			lowerBound = upperBound;
			upperBound = tmp;
		}
		return new EnumSubrange((ushort)lowerBound, (ushort)upperBound, lower.DataType);
	}

	private SubRange MakeIntSubRange(Expression lower, Expression upper, LexLocation location)
	{
		long lowerBound = Convert.ToInt64(lower.Evaluate());
		long upperBound = Convert.ToInt64(upper.Evaluate());
		if (lowerBound > upperBound)
		{
			string interval = lower.ToString() + ".." + upper.ToString();
			this.report.SemanticError(16, interval, location);
			long tmp = lowerBound;
			lowerBound = upperBound;
			upperBound = tmp;
		}
		TypeNode dataType = this.LargestDataType(lower, upper);
		return new IntSubrange(lower, upper, dataType);
	}

	private SubRange MakeUIntSubRange(Expression lower, Expression upper, LexLocation location)
	{
		ulong lowerBound = Convert.ToUInt64(lower.Evaluate());
		ulong upperBound = Convert.ToUInt64(upper.Evaluate());
		if (lowerBound > upperBound)
		{
			string interval = lower.ToString() + ".." + upper.ToString();
			this.report.SemanticError(16, interval, location);
			ulong tmp = lowerBound;
			lowerBound = upperBound;
			upperBound = tmp;
		}
		TypeNode dataType = this.LargestDataType(lower, upper);
		return new UIntSubrange(lower, upper, dataType);
	}

	private SubRange MakeBitStringSubRange(Expression lower, Expression upper, LexLocation location)
	{
		ulong lowerBound = Convert.ToUInt64(lower.Evaluate());
		ulong upperBound = Convert.ToUInt64(upper.Evaluate());
		if (lowerBound > upperBound)
		{
			string interval = lower.ToString() + ".." + upper.ToString();
			this.report.SemanticError(16, interval, location);
			ulong tmp = lowerBound;
			lowerBound = upperBound;
			upperBound = tmp;
		}
		TypeNode dataType = this.LargestDataType(lower, upper);
		return new BitStringSubrange(lower, upper, dataType);
	}

private SubRange MakeSubrange(Expression lower, Expression upper, LexLocation loc1, LexLocation loc2)
{
		if (lower == null || upper == null)
			return SubRange.Error;
		else {
			TypeNode lowerDataType = lower.DataType;
			TypeNode upperDataType = upper.DataType;
		
			if (lowerDataType == TypeNode.Error || upperDataType == TypeNode.Error)
				return SubRange.Error;
			else if (! lower.IsConstant)
			{
				this.report.SemanticError(95, lower.ToString(), loc1);
				if (! upper.IsConstant)
					this.report.SemanticError(95, upper.ToString(), loc2);
				if (! lowerDataType.IsOrdinalType)
					this.report.SemanticError(-1, lower.ToString(), loc1);
				if (! upperDataType.IsOrdinalType)
					this.report.SemanticError(-1, upper.ToString(), loc2);
				return SubRange.Error;
			}
			else if (! upper.IsConstant)
			{
				this.report.SemanticError(95, upper.ToString(), loc2);
				if (! lowerDataType.IsOrdinalType)
					this.report.SemanticError(-1, lower.ToString(), loc1);
				if (! upperDataType.IsOrdinalType)
					this.report.SemanticError(-1, upper.ToString(), loc2);
				return SubRange.Error;
			}
			else if (! lowerDataType.IsOrdinalType)
			{
				this.report.SemanticError(-1, lower.ToString(), loc1);
				if (! upperDataType.IsOrdinalType)
					this.report.SemanticError(-1, upper.ToString(), loc2);
				return SubRange.Error;
			}
			else if (! upperDataType.IsOrdinalType)
			{
				this.report.SemanticError(-1, upper.ToString(), loc2);
				return SubRange.Error;
			}
			else if (lowerDataType.IsSignedIntType)
			{
				if (upperDataType.IsSignedIntType)
					return this.MakeIntSubRange(lower, upper, loc1);
			}
			else if (lowerDataType.IsUnsignedIntType)
			{
				if (upperDataType.IsUnsignedIntType)
					return this.MakeUIntSubRange(lower, upper, loc1);
			}
			else if (lowerDataType.IsBitStringType)
			{
				if (upperDataType.IsBitStringType)
					return this.MakeBitStringSubRange(lower, upper, loc1);
			}
			else if (lowerDataType.BaseType != upperDataType.BaseType)
			{
				string subRange = lower + ".." + upper;
				this.report.SemanticError(94, subRange, loc1);
				return SubRange.Error;
			}
			else if (lowerDataType.IsEnumeratedType)
				return this.MakeEnumSubRange(lower, upper, loc1);
		}
		string interval = lower + ".." + upper;
		this.report.SemanticError(94, interval, loc1);
		return SubRange.Error;
	}

	private void SubrangeTypeStart(TypeNode subrangeType)
	{
		this.isSubrangeDecl = true;
		this.subrangeDataType = subrangeType;
	}

	private TypeNode MakeSubrangeType(TypeNode baseType, SubRange subrange, LexLocation loc)
	{
		TypeNode subRangeType;
		this.isSubrangeDecl = false;            
		this.subrangeDataType = TypeNode.Error;
		string typeID = baseType.TypeID + "(" + subrange + ")";
		if (TypeNode.LookUpType(typeID, out subRangeType))
			return subRangeType;
		else {
			string typeName = baseType.Name + "(" + subrange + ")";
			return baseType.MakeSubrange(typeName, subrange, loc);
		}
	}	

	private List<SubRange> MakeSubRangeList(SubRange subrange, LexLocation location)
	{
		if (subrange.DataType.IsSignedIntType)
			return new List<SubRange>{subrange};
		else {
			this.report.SemanticError(15, subrange.ToString(), location);
			return new List<SubRange>{new IntSubrange(0, 100, TypeNode.Int)};
		}
	}

	private List<SubRange> AddSubRange(List<SubRange> subRangeList, SubRange subrange, LexLocation location)
	{
		if (subRangeList.Count == STLangParameters.MAX_ARRAY_SUBSCRIPTS)
			this.report.SemanticError(50, location);
		if (subrange.DataType.IsIntegerType)
			subRangeList.Add(subrange);
		else {
			if (subrange.DataType != TypeNode.Error)
				this.report.SemanticError(15, subrange.ToString(), location);
			subRangeList.Add(new IntSubrange(0, 100, TypeNode.Int));
		}
		return subRangeList;
	}

	private List<string> MakeEnumIdentList(string enumIdent, LexLocation location)
	{
		List<string> enumIdentList = new List<string>();
		if (enumIdent.Length > 0)
		{
			if (this.isTypeDecl)
			{
				if (this.symbolTable.IsValidTypedEnumSymbol(enumIdent, location))
					enumIdentList.Add(enumIdent);
			}
			else if (this.symbolTable.IsValidUserDefinedSymbol(enumIdent, location))
				enumIdentList.Add(enumIdent);
		}
		return enumIdentList;
	}

	private List<string> AddToEnumIdentList(List<string> enumIdentList, string enumIdent, LexLocation location)
	{
		if (enumIdent.Length == 0)
			return enumIdentList;
		else if (enumIdentList == null)
			return this.MakeEnumIdentList(enumIdent, location);
		else if (!enumIdentList.IsUnique(enumIdent))
			this.report.SemanticError(1, enumIdent, location);
		else if (this.isTypeDecl)
		{
			if (this.symbolTable.IsValidTypedEnumSymbol(enumIdent, location))
				enumIdentList.Add(enumIdent);
		}
		else if (this.symbolTable.IsValidUserDefinedSymbol(enumIdent, location))
			enumIdentList.Add(enumIdent);
		return enumIdentList;
	}

	private EnumeratedType MakeEnumeratedType(List<string> identList)
	{
		EnumeratedType enumType = new EnumeratedType(identList);
		if (this.isTypeDecl)
			this.symbolTable.InstallEnumeratedConstants(enumType, this.derivedTypeName);
		else
			this.symbolTable.InstallEnumeratedConstants(enumType);
		//
		// Install selection functions SEL and MUX for this enumerated type in the symboltable.
		//
		STLangSymbolTable.InstallStandardFunction("SEL", enumType, StandardLibraryFunction.SELECT, TypeNode.Bool, enumType, enumType);
		STLangSymbolTable.InstallExtensibleFunction("MUX", enumType, StandardLibraryFunction.MUX, TypeNode.AnyInt, enumType, enumType);
		return enumType;
	}

	private List<object> MakeArrayInitList(object initElem)
	{
		List<object> initList = new List<object>();
		if (initElem != null)
		{
			if (initElem is List<object>)
				initList.AddRange((List<object>)initElem);
			else
				initList.Add(initElem);
		}
		return initList;
	}

	private void AddArrayInitElem(List<object> initList, object initElem)
	{
		if (initElem != null)
		{
			if (initElem is List<object>)
				initList.AddRange((List<object>)initElem);
			else
				initList.Add(initElem);
		}
	}

	private List<object> MakeStructInitList(object initElem)
	{
		List<object> initList = new List<object>();
		if (initElem != null)
		{
			if (initElem is List<object>)
				initList.AddRange((List<object>)initElem);
			else
				initList.Add(initElem);
		}
		return initList;
	}

	private void AddStructInitElem(List<object> initList, object initElem)
	{
		if (initElem != null)
		{
			if (initElem is List<object>)
				initList.AddRange((List<object>)initElem);
			else
				initList.Add(initElem);
		}
	}

	private string MakeTypeName(List<SubRange> subRanges, TypeNode elemDataType)
	{
		string intervalList = "";

		foreach (SubRange subrange in subRanges)
		{
			if (intervalList.Length > 0)
				intervalList += ",";
			intervalList += subrange;
		}
		return "ARRAY [" + intervalList + "] OF " + elemDataType.Name;
	}

	private List<SubRange> GetSubRanges(ArrayType array)
	{
		int lower,upper;
		TypeNode elementType = array;
		List<SubRange> subRanges = new List<SubRange>();
		
		while (elementType.IsArrayType)
	    {
			array = (ArrayType)elementType;
			lower = array.LowerBound;
			upper = array.UpperBound;
			elementType = array.ElementType;
			subRanges.Add(new IntSubrange(lower, upper, TypeNode.DInt));
		}
		while (elementType.IsArrayType);
		return subRanges;
	}

	private TypeNode MakeArrayType(List<SubRange> subRanges, TypeNode elemDataType, LexLocation loc1, LexLocation loc2) 
	{
		if (elemDataType.IsFunctionBlockType)
		{
			//
			// Error. IEC 61131-3 does not allow arrays of function blocks.
			//
			this.report.SemanticError(164, loc2);
			return TypeNode.Error;
		}
		else {
			string typeID = "";
			TypeNode arrayDataType;
			foreach (SubRange subrange in subRanges)
			{
				typeID +=  "[" + subrange + "]";
			} 
			typeID += elemDataType.TypeID;
			if (TypeNode.LookUpType(typeID, out arrayDataType))
				return arrayDataType;
			else {
				Expression defaultValue = elemDataType.DefaultValue;
				return this.MakeArrayType(subRanges, elemDataType, defaultValue, loc1);
			}
		}
	}

	private TypeNode MakeArrayType(List<SubRange> subranges, TypeNode basicElementType, Expression initializer, LexLocation loc) 
	{
		if (subranges.Count == 0)
			return basicElementType;
		else {
			SubRange subrange = subranges[0];
			if (! (subrange is IntSubrange))
				return TypeNode.Error;
			else {
				TypeNode arrayDataType;
				TypeNode elementType    = this.MakeArrayType(subranges.Succ(), basicElementType, initializer, loc);
				string typeID           = "[" + subrange + "]" + elementType.TypeID;
			    IntSubrange intSubrange = (IntSubrange)subrange;
				long lower              = intSubrange.LowerBound;
				long upper              = intSubrange.UpperBound;
				string typeName         = this.MakeTypeName(subranges, basicElementType);
				long elementCount       = (upper - lower + 1)*(elementType.Size / basicElementType.Size);
				long byteCount          = elementCount * basicElementType.Size;
				if (byteCount > STLangParameters.MAX_ARRAY_SIZE)
					this.report.SemanticError(113, loc);
				if (TypeNode.LookUpType(typeID, out arrayDataType))
					return arrayDataType;
				else if (basicElementType.IsElementaryType || basicElementType.IsTextType)
				{
					Expression size = MakeIntConstant(byteCount);
					return new ArrayType(typeName, (int)lower, (int)upper, (uint)byteCount, size, elementType, basicElementType, initializer, typeID);
				}
				else if (basicElementType.IsArrayType)
				{
					List<SubRange> subranges2 = new List<SubRange>();
					ArrayType array = (ArrayType)basicElementType.BaseType;
					subranges2.AddRange(subranges);
					subranges2.AddRange(this.GetSubRanges(array));
					return this.MakeArrayType(subranges2, array.BasicElementType, initializer, loc);
				}
				else if (basicElementType.IsStructType)
				{
					string key;
					ArrayType array;
					StructType structure = (StructType)basicElementType.BaseType;
					FieldSymbol field = structure.FirstField;
					Dictionary<string, InitializerList> flattenedInitLists;
					flattenedInitLists = new Dictionary<string, InitializerList>();
					while (field != null)
					{
						key = field.Name.ToUpper();
						array = (ArrayType)this.MakeFlattenedArrayType(elementCount, field.DataType, field.InitialValue);
						flattenedInitLists.Add(key, (InitializerList)array.DefaultValue);
						field = field.Next;
					}
					Expression size = MakeIntConstant(byteCount);
					return new ArrayType(typeName, (int)lower, (int)upper, (uint)byteCount, size, elementType, basicElementType, flattenedInitLists, typeID);
				}
				string msg = "Illegal array element type: " + basicElementType.Name;
				throw new STLangCompilerError(msg);
			}
		}
	}

	private TypeNode MakeFlattenedArrayType(long elementCount, TypeNode elementType, Expression initializer)
	{
		if (elementType.IsElementaryType || elementType.IsTextType)
		{
			string typeID;
			TypeNode arrayDataType;
			int upper = (int)elementCount - 1;

			typeID = "[0.." + upper + "]" + elementType.TypeID;
			if (TypeNode.LookUpType(typeID, out arrayDataType))
				return arrayDataType;
			else {
				long byteCount = elementCount * elementType.Size;
				Expression size = MakeIntConstant(byteCount);
				string typeName = "ARRAY [0.." + upper + "] OF " + elementType.Name;
				return new ArrayType(typeName, 0, upper, (uint)byteCount, size, elementType, elementType, initializer, typeID);
			}
		}
		else if (elementType.IsArrayType)
		{
			ArrayType array2 = (ArrayType)elementType.BaseType;
			TypeNode elementType2 = array2.BasicElementType;
			long elementCount2 = elementCount*(array2.Size/elementType2.Size);
			return this.MakeFlattenedArrayType(elementCount2, elementType2, initializer);
		}
		else if (elementType.IsStructType)
		{
			TypeNode arrayDataType;
			int upper = (int)elementCount - 1;
			string typeID = "[0.." + upper + "]" + elementType.TypeID;
			
			if (TypeNode.LookUpType(typeID, out arrayDataType))
				return arrayDataType;
			else {
				string key;
				ArrayType array;
				StructType structure = (StructType)elementType.BaseType;
				FieldSymbol field = structure.FirstField;
				Dictionary<string, InitializerList> flattenedInitLists;
				flattenedInitLists = new Dictionary<string, InitializerList>();
				while (field != null)
				{
					key = field.Name.ToUpper();
					array = (ArrayType)this.MakeFlattenedArrayType(elementCount, field.DataType, field.InitialValue);
					flattenedInitLists.Add(key, (InitializerList)array.DefaultValue);
					field = field.Next;
				}
				long byteCount = elementCount * elementType.Size;
				Expression size = MakeIntConstant(byteCount);
				string typeName = "ARRAY [0.." + upper + "] OF " + elementType.Name;
				return new ArrayType(typeName, 0, upper, (uint)byteCount, size, elementType, elementType, flattenedInitLists, typeID);
			}
		}
		else
		{
			Expression size = MakeIntConstant(0);
			string typeID = "[0..1]" + elementType.TypeID;
			string typeName = "ARRAY [0..1] OF " + elementType.Name;
			return new ArrayType(typeName, 0, 1, 0, size, elementType, elementType, initializer, typeID);
		}
	}

	private string MakeTypeName(StructDeclaration structure)
	{
		string typeName = string.Empty;
		if (structure.MemberCount < 4)
		{
			foreach (StructMemberDeclaration member in structure.Members)
			{
				if (typeName.Length == 0)
					typeName = "STRUCT (" + member.Name + " : " + member.DataType.Name;
				else 
					typeName += "; " + member.Name + " : " + member.DataType.Name;
			}
		}
		else {
			StructMemberDeclaration member = structure.Members.ElementAt(0);
			typeName = "STRUCT (" + member.Name + " : " + member.DataType.Name;
            member = structure.Members.ElementAt(1);
			typeName += "; " + member.Name + " : " + member.DataType.Name;
            member = structure.Members.ElementAt(structure.MemberCount - 1);
			typeName += "; ... ; " + member.Name + " : " + member.DataType.Name;
		}
		typeName += ")";
		return typeName;
	}

	private TypeNode MakeStructDataType(StructDeclaration structure)
	{
		this.structNestingDepth--;
		if (structure == null || structure.MemberCount == 0)
			return TypeNode.Error;
		else {
			TypeNode structType;
			string typeID = string.Empty;
			
			foreach (StructMemberDeclaration member in structure.Members)
			{
				if (typeID.Length > 0)
					typeID += ",";
				typeID += member.Name.ToUpper() + ":" + member.DataType.TypeID;
			}
			typeID = "(" + typeID + ")";
			if (TypeNode.LookUpType(typeID, out structType))
				return structType;
			else {
				string key;
				uint byteCount = 0;
				FieldSymbol field = null;
				FieldSymbol prevField = null;
				FieldSymbol firstField = null;
				bool isContiguouslyStored = true;
				Dictionary<string, FieldSymbol> members;
				
				members = new Dictionary<string, FieldSymbol>();
				foreach (StructMemberDeclaration member in structure.Members)
				{
					prevField = field;
					field = new FieldSymbol(member.Name, member.DataType, member.InitValue);
					key = member.Name.ToUpper();
					members.Add(key, field);
					if (prevField == null)
                        firstField = field;
					else {
                        prevField.Next = field;
						if (prevField.DataType != field.DataType)
							isContiguouslyStored = false;
					}
					byteCount += member.DataType.Size;
				}
				string typeName = this.MakeTypeName(structure);
				Expression size = MakeIntConstant((long)byteCount);
				return new StructType(members, firstField, byteCount, size, isContiguouslyStored, typeName, typeID);
			}
		}
	}

	private InitializerList ExpandInitializerSequence(TokenInt tokenInt, InitializerList initSequence, LexLocation loc)
	{
		int repetitionFactor = (int)tokenInt.Value;
		if (repetitionFactor == 0)
		{
			this.report.SemanticError(89, loc);
			return initSequence; 
		}
		else if (initSequence != null)
			return initSequence.Expand(repetitionFactor, this.report);
		else {
			TypeNode dataType = this.attributeStack.Top;
			Expression defaultValue = dataType.DefaultValue;
			initSequence = new InitializerSequence(dataType);
			for (int i = repetitionFactor; i > 0; i--)
			{
				initSequence.Add(defaultValue, loc);
			}
			return initSequence;
		}
	}

	private TypeNode GetDerivedType(string typeName, LexLocation location)
	{
		STLangSymbol symbol;

		if (! this.symbolTable.Lookup(typeName, out symbol, location))
		{
			// Error: Undefined identifier

			this.report.SemanticError(151, typeName, location);
			return TypeNode.Error;
		}
		else if (! (symbol.IsDerivedType || symbol.IsFunctionBlock))
		{
			// Error: identifier is not a type name or function block.

			this.report.SemanticError(24, typeName, symbol.TypeName, location);
			return TypeNode.Error;
		}
		else if (symbol.IsFunctionBlock)
		{
			// Check that structure members are not function blocks.

			if (this.structNestingDepth > 0)
				this.report.SemanticError(165, location);
			if (this.isFunctionDecl)
			{
				// Check that the function block can be used in functions. 
				// Function blocks such as timers, counters or edge detectors
				// are illegal because they contain data that are declared 
				// retentive or R_EDGE/F_EDGE.

				StandardFunctionBlockSymbol functionBlockSymbol;
				functionBlockSymbol = (StandardFunctionBlockSymbol)symbol;
				if (functionBlockSymbol.HasRetentiveData) 
					this.report.SemanticError(162, typeName, location);
				if (functionBlockSymbol.HasRFEdgeDetection)
					this.report.SemanticError(163, typeName, location);
			}
		}
		return symbol.DataType;
	}

	private TypeNode MakeStringType(Expression size, LexLocation location)
	{
		if (size == null)
			return TypeNode.String;
		else if (! size.IsConstant && location != null)
		{
			this.report.SemanticError(22, location);
			if (! size.DataType.IsSignedIntType)
				this.report.SemanticError(-5, location);
			return TypeNode.String;
		}
		else if (! size.DataType.IsIntegerType)
		{
			this.report.SemanticError(-5, location);
			return TypeNode.String;
		}
		else {
			int length = Convert.ToInt32(size.Evaluate());
			if (length < 1)
			{
				this.report.SemanticError(22, location);
				return TypeNode.String;
			}
			else if (length > STLangParameters.MAX_STRING_LENGTH)
			{
				this.report.SemanticError(-6, length, location);
				return TypeNode.String;
			}
			else {
				TypeNode stringType;
				string baseTypeID = TypeNode.String.TypeID;
				string typeID = baseTypeID + "[" + length + "]";
				if (TypeNode.LookUpType(typeID, out stringType))
					return stringType;
				else {
					string typeName = "STRING[" + length + "]";
					return new StringType(typeName, length + 1, typeID);
				}
			}
		}
	}

	private TypeNode MakeWStringType(Expression size, LexLocation location)
	{
		if (size == null)
			return TypeNode.WString;
		else if (! size.IsConstant && location != null)
		{
			this.report.SemanticError(22, location);
			if (! size.DataType.IsIntegerType)
				this.report.SemanticError(-5, location);
			return TypeNode.WString;
		}
		else if (! size.DataType.IsIntegerType)
		{
			this.report.SemanticError(-5, location);
			return TypeNode.WString;
		}
		else {
			int length = Convert.ToInt32(size.Evaluate());
			if (length < 1)
			{
				this.report.SemanticError(22, location);
				return TypeNode.WString;
			}
			else if (length > STLangParameters.MAX_WSTRING_LENGTH)
			{
				this.report.SemanticError(-6, length, location);
				return TypeNode.WString;
			}
			else {
				TypeNode stringType;
				string baseTypeID = TypeNode.String.TypeID;
				string typeID = baseTypeID + "[" + length + "]";
				if (TypeNode.LookUpType(typeID, out stringType))
					return stringType;
				else {
					string typeName = "WSTRING[" + length + "]";
					return new WStringType(typeName, length + 1, typeID);
				}
			}
		}
	}

	private Expression MakeTODConstant(TimeSpan timeOfDay)
	{
		if (timeOfDay < TimeSpan.Zero)
			timeOfDay += new TimeSpan(0, 23, 59, 59, 999);
		if (timeOfDay.Days != 0)
			timeOfDay -= new TimeSpan(timeOfDay.Days, 0, 0, 0);
		string stringValue = timeOfDay.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new TimeOfDayConstant(timeOfDay);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenTOD token)
	{
		string stringValue = token.Value.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new TimeOfDayConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TimeSpan time)
	{
		string stringValue = time.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new TimeConstant(time);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenTime token)
	{
		string stringValue = token.Value.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new TimeConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	public static Expression MakeConstant(double value)
	{
		string stringValue = "LREAL#" + value.GetBinaryString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new LRealConstant(value);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	public static Expression MakeConstant(float value)
	{
		string stringValue = "REAL#" + value.GetBinaryString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new RealConstant(value);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenDouble token)
	{
		string stringValue = "LREAL#" + token.Value.GetBinaryString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new LRealConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenInt token)
	{
		string stringValue = token.Value.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = this.MakeIntConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenDate token)
	{
		string stringValue = token.Value.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new DateConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(DateTime dateTime)
	{
		string stringValue = dateTime.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new DateTimeConstant(dateTime);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenDateTime token)
	{
		string stringValue = token.Value.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new DateTimeConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private void PushFieldType(string field, LexLocation location)
	{
		this.attributeStack.PushFieldType(field, location);
	}

	private void CheckNestingDepth(LexLocation location)
	{
		this.structNestingDepth++;
		if (this.structNestingDepth == STLangParameters.MAX_STRUCT_NESTING_DEPTH + 1)
			this.report.SemanticError(115, location);
	}

	private SubrangeLabel CheckSubRangeTypes(TypeNode selectorDataType, SubRange subRange, LexLocation loc)
	{
		SubRange selectorSubrange = selectorDataType.GetSubrange();
		if (selectorSubrange.Contains(subRange))
			return new SubrangeLabel(subRange);
		else if (selectorSubrange.AreDisjoint(subRange))
		{
			this.report.SemanticError(-3, subRange.ToString(), selectorDataType.Name, loc);
			return new SubrangeLabel(subRange);
		}
		else {
			this.report.Warning(14, subRange.ToString(), loc);
			return new SubrangeLabel(subRange);
		}
	}

	private NumericLabel CheckSubRangeTypes(TypeNode selectorDataType, Expression caseLabel, LexLocation loc)
	{
		SubRange selectorSubrange = selectorDataType.GetSubrange();
		if (selectorSubrange.Contains(caseLabel))
			return new NumericLabel(caseLabel);
		else {
			this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, loc);
			return null;
		}
	}

	private Expression CheckCtrlExpression(LexLocation location, Expression expression = null)
	{
		if (expression == null)
		{
			this.Push(Expression.Error);
			expression = Expression.Error;
		}
		else if (expression is FunctionName)
		{
			this.Push(Expression.Error);
			expression = Expression.Error;
			this.report.SemanticError(148, expression.ToString(), location);
		}
		else {
			TypeNode ctrlExpressionType = expression.DataType;
			if (ctrlExpressionType == TypeNode.Error)
				this.Push(Expression.Error);
			else if (ctrlExpressionType.IsOrdinalType)
				this.Push(expression);
			else {
				this.report.SemanticError(147, location);
				this.Push(Expression.Error);
			}
		}
		this.PushCaseLabelList();
		this.CheckForEndOfCaseStatList();
		return expression;
	}

	private NumericLabel CheckCaseLabel(Expression caseLabel, LexLocation location)
	{
		if (caseLabel == null)
			return null;
		else if (caseLabel is FunctionName)
		{
			this.report.SemanticError(32, caseLabel.ToString(), location);
			return null;
		}
		else if (caseLabel.DataType == TypeNode.Error)
			return null;
		else if (! caseLabel.IsConstant)
		{
			this.report.SemanticError(32, caseLabel.ToString(), location);
			if (! caseLabel.DataType.IsOrdinalType)
				this.report.SemanticError(31, caseLabel.ToString(), location);
			return null;
		}
		else {
			TypeNode labelDataType = caseLabel.DataType;
			TypeNode selectorDataType = this.attributeStack.Top;	

			if (labelDataType == TypeNode.Error)
				return null;
			else if (! labelDataType.IsOrdinalType)
			{
				this.report.SemanticError(31, caseLabel.ToString(), location);
				return null;
			}
			else if (selectorDataType == TypeNode.Error)
				return new NumericLabel(caseLabel);
			else if (selectorDataType == labelDataType)
			{
				if (selectorDataType.IsSubrangeType)
				{
					if (selectorDataType.IsSignedIntType)
					{
						long numericValue = Convert.ToInt64(caseLabel.Evaluate());
						if (! selectorDataType.IsInRange(numericValue))
						{
							string strValue = caseLabel.ToString();
							string typeName = selectorDataType.Name;
							this.report.SemanticError(171, strValue, typeName, location);
						}
					}
					else {
						ulong numericValue = Convert.ToUInt64(caseLabel.Evaluate());
						if (! selectorDataType.IsInRange(numericValue))
						{
							string strValue = caseLabel.ToString();
							string typeName = selectorDataType.Name;
							this.report.SemanticError(171, strValue, typeName, location);
						}
					}
				}
				return new NumericLabel(caseLabel);
			}
			else if (selectorDataType.IsSignedIntType && labelDataType.IsSignedIntType)
			{
				if (selectorDataType.Size < labelDataType.Size)
					this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
				else {
					// Convert case label type to selector type

					long value = Convert.ToInt64(caseLabel.Evaluate());
					if (selectorDataType == TypeNode.Int)
						caseLabel = new IntConstant((short)value);
					else if (selectorDataType == TypeNode.DInt)
						caseLabel = new DIntConstant((int)value);
					else
						caseLabel = new LIntConstant(value);
				}
				return new NumericLabel(caseLabel);
			}
			else if (selectorDataType.IsUnsignedIntType && labelDataType.IsUnsignedIntType)
			{
				if (selectorDataType.Size < labelDataType.Size)
					this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
				else {
					// Convert case label type to selector type

					ulong value = Convert.ToUInt64(caseLabel.Evaluate());
					if (selectorDataType == TypeNode.UInt)
						caseLabel = new UIntConstant((ushort)value);
					else if (selectorDataType == TypeNode.DInt)
						caseLabel = new UDIntConstant((uint)value);
					else
						caseLabel = new ULIntConstant(value);
				}
				return new NumericLabel(caseLabel);
			}
			else if (selectorDataType.IsUnsignedIntType && labelDataType.IsSignedIntType)
			{
				if (selectorDataType.Size < labelDataType.Size)
					this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
				else {
					// Convert case label type to selector type

					long value = Convert.ToInt64(caseLabel.Evaluate());
					if (value < 0)
						this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
					else if (selectorDataType == TypeNode.UInt)
						caseLabel = new UIntConstant((ushort)value);
					else if (selectorDataType == TypeNode.DInt)
						caseLabel = new UDIntConstant((uint)value);
					else
						caseLabel = new ULIntConstant((ulong)value);
				}
				return new NumericLabel(caseLabel);
			}
			else if (selectorDataType.IsBitStringType && labelDataType.IsBitStringType)
			{
				if (selectorDataType.Size < labelDataType.Size)
					this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
				else {
					// Convert case label type to selector type

					ulong value = Convert.ToUInt64(caseLabel.Evaluate());
					if (selectorDataType == TypeNode.Word)
						caseLabel = new WordConstant((ushort)value);
					else if (selectorDataType == TypeNode.DWord)
						caseLabel = new DWordConstant((uint)value);
					else
						caseLabel = new LWordConstant(value);
				}
				return new NumericLabel(caseLabel);
			}
			else if (selectorDataType.IsBitStringType && labelDataType.IsIntegerType)
			{
				if (selectorDataType.Size < labelDataType.Size)
					this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
				else {
					// Convert case label type to selector type

					long value = Convert.ToInt64(caseLabel.Evaluate());
					if (value < 0)
						this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
					else if (selectorDataType == TypeNode.Word)
						caseLabel = new UIntConstant((ushort)value);
					else if (selectorDataType == TypeNode.DWord)
						caseLabel = new DWordConstant((uint)value);
					else
						caseLabel = new LWordConstant((ulong)value);
				}
				return new NumericLabel(caseLabel);
			}
			this.report.SemanticError(86, caseLabel.ToString(), labelDataType.Name, selectorDataType.Name, location);
			return null;
		}
	}

	private SubrangeLabel CheckCaseLabel(SubRange subRange, LexLocation location)
	{
		if (subRange == null)
			return null;
		else {
			TypeNode selectorDataType = this.attributeStack.Top;
			TypeNode labelDataType = subRange.DataType;
			if (labelDataType == TypeNode.Error)
				return null;
			else if (! labelDataType.IsOrdinalType)
			{
				this.report.SemanticError(31, subRange.ToString(), location);
				return null;
			}
			else if (selectorDataType == TypeNode.Error)
				return new SubrangeLabel(subRange);
			else if (! selectorDataType.IsOrdinalType)
				return new SubrangeLabel(subRange);
			else if (selectorDataType == labelDataType)
			{
                SubRange selectorSubRange = selectorDataType.GetSubrange();
                if (selectorSubRange.AreDisjoint(subRange))
                {
					string subRangeStr = subRange.ToString();
                    string selDataTypeName = selectorDataType.Name;
                    this.report.SemanticError(172, subRangeStr, selDataTypeName, location);
                }
				else if (! selectorSubRange.Contains(subRange))
                {
                    string subRangeStr = subRange.ToString();
                    string selDataTypeName = selectorDataType.Name;
                    this.report.Warning(14, subRangeStr, selDataTypeName, location);
                }
                return new SubrangeLabel(subRange);
            }
			else if (selectorDataType.IsSignedIntType && (subRange is IntSubrange))
			{
				if (selectorDataType.Size == labelDataType.Size)
					return CheckSubRangeTypes(selectorDataType, subRange, location);
				else if (selectorDataType.Size < labelDataType.Size)
				{
					this.report.SemanticError(108, subRange.ToString(), selectorDataType.Name, location);
					return null;
				}
				else {
					// Convert subrange type to selector type
					IntSubrange intSubrange = (IntSubrange)subRange;
					long lowerBound = intSubrange.LowerBound;
					long upperBound = intSubrange.UpperBound;
					intSubrange     = new IntSubrange(lowerBound, upperBound, selectorDataType);
					return new SubrangeLabel(intSubrange);
				}
			}
			else if (selectorDataType.IsUnsignedIntType && (subRange is UIntSubrange))
			{
				if (selectorDataType.Size == labelDataType.Size)
					return CheckSubRangeTypes(selectorDataType, subRange, location);
				else if (selectorDataType.Size < labelDataType.Size)
				{
					this.report.SemanticError(108, subRange.ToString(), selectorDataType.Name, location);
					return null;
				}
				else {
				    // Convert subrange type to selector type
					UIntSubrange uintSubrange = (UIntSubrange)subRange;
					ulong lowerBound = uintSubrange.LowerBound;
					ulong upperBound = uintSubrange.UpperBound;
					uintSubrange     = new UIntSubrange(lowerBound, upperBound, selectorDataType);
					return new SubrangeLabel(uintSubrange);
				}
			}
			else if (selectorDataType.IsUnsignedIntType && labelDataType.IsSignedIntType)
			{
				if (selectorDataType.Size < labelDataType.Size)
				{
					this.report.SemanticError(108, subRange.ToString(), selectorDataType.Name, location);
					return null;
				}
				else {
				    IntSubrange intSubrange = (IntSubrange)subRange;
					long lowerBound = intSubrange.LowerBound;
					long upperBound = intSubrange.UpperBound;
					UIntSubrange uintSubrange = new UIntSubrange((ulong)lowerBound, (ulong)upperBound, selectorDataType); 
					if (selectorDataType.Size > labelDataType.Size)
						return new SubrangeLabel(uintSubrange);
					else
						return CheckSubRangeTypes(selectorDataType, uintSubrange, location);
				}
			}
			else if (selectorDataType.IsBitStringType && labelDataType.IsBitStringType)
			{
				if (selectorDataType.Size == labelDataType.Size)
					return CheckSubRangeTypes(selectorDataType, subRange, location);
				else if (selectorDataType.Size < labelDataType.Size)
				{
					this.report.SemanticError(108, subRange.ToString(), selectorDataType.Name, location);
					return null;
				}
				else {
					// Convert subrange type to selector type
					BitStringSubrange bitStringSubrange = (BitStringSubrange)subRange;
					ulong lowerBound  = bitStringSubrange.LowerBound;
					ulong upperBound  = bitStringSubrange.UpperBound;
					bitStringSubrange = new BitStringSubrange(lowerBound, upperBound, selectorDataType);
					return new SubrangeLabel(bitStringSubrange);
				}
			}
			else if (selectorDataType.IsBitStringType && (subRange is UIntSubrange))
			{
				if (selectorDataType.Size < labelDataType.Size)
				{
					this.report.SemanticError(108, subRange.ToString(), selectorDataType.Name, location);
					return null;
				}
				else {
					UIntSubrange uintSubrange = (UIntSubrange)subRange;
					ulong lowerBound = uintSubrange.LowerBound;
					ulong upperBound = uintSubrange.UpperBound;
					uintSubrange     = new UIntSubrange(lowerBound, upperBound, selectorDataType); 
					if (selectorDataType.Size > labelDataType.Size)
						return new SubrangeLabel(uintSubrange);
					else
						return CheckSubRangeTypes(selectorDataType, uintSubrange, location);
				}
			}
			else if (selectorDataType.IsEnumeratedType && labelDataType.IsEnumeratedType)
			{
				SubRange selectorSubrange = selectorDataType.GetSubrange();
				if (selectorSubrange.Contains(subRange))
					return new SubrangeLabel(subRange);
				else if (selectorSubrange.AreDisjoint(subRange))
				{
					this.report.SemanticError(-3, subRange.ToString(), selectorDataType.Name, location);
					return new SubrangeLabel(subRange);
				}
				else {
					this.report.Warning(14, subRange.ToString(), location);
					return new SubrangeLabel(subRange);
				}
			}
			else {
				this.report.SemanticError(86, selectorDataType.Name, subRange.ToString(), location);
				return null;
			}
		}
	}

	private void InstallDerivedType(string typeName, DataTypeSpec typeSpec, LexLocation location)
	{
		if (this.symbolTable.IsValidUserDefinedSymbol(typeName, location))
		{
			TypeNode baseType = typeSpec.DataType;
			Expression initialValue = typeSpec.InitialValue;
			this.symbolTable.InstallDerivedType(typeName, baseType, initialValue);
		}
		this.derivedTypeName = "";
	}

	private Expression MakeRealAddOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			float leftValue = Convert.ToSingle(left.Evaluate());
			if (leftValue == 0.0f)
				return right;
			else if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				float sum = leftValue + rightValue;
					
				if (float.IsPositiveInfinity(sum) || float.IsNegativeInfinity(sum))
				{
					sum = float.NaN;
					string text = left.ToString() + " + " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(sum);
			}
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return left;
			else if (rightValue < 0.0f)
			{
				right = MakeConstant(-rightValue);
				return new RealSubOperator(left, right);
			}
		}
		else if (right is RealUnaryMinusOperator)
		{
			right = ((UnaryOperator)right).Operand;
			Expression expr = new RealSubOperator(left, right);
		}
		return new RealAddOperator(left, right);
	}

	private Expression MakeLRealAddOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (Math.Abs(leftValue) == 0.0d)
				return right;
			else if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				double sum = leftValue + rightValue;
					
				if (double.IsPositiveInfinity(sum) || double.IsNegativeInfinity(sum))
				{
					sum = double.NaN;
					string text = left.ToString() + " + " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(sum);
			}
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (Math.Abs(rightValue) == 0.0d)
				return left;
			else if (rightValue < 0.0d)
			{
				right = MakeConstant(-rightValue);
				return new RealSubOperator(left, right);
			}
		}
		else if (right is LRealUnaryMinusOperator)
		{
			UnaryOperator unaryMinus = (UnaryOperator)right;
			return new LRealSubOperator(left, unaryMinus.Operand);
		}
		return new LRealAddOperator(left, right);
	}

	private Expression MakeIntAddOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (leftValue == 0)
				return right;
			else if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				if (rightValue == 0)
					return left;
				else {
					long sum = leftValue + rightValue;
					return MakeIntConstant(sum);
				}
			}
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return left;
		}
		else if (right is IntUnaryMinusOperator)
		{
			UnaryOperator unaryMinus = (UnaryOperator)right;
			return this.MakeIntSubOp(left, unaryMinus.Operand);
		}
		if (left.DataType == right.DataType)
			return new IntAddOperator(left, right, left.DataType);
		else if (left.DataType == TypeNode.LInt)
			return new IntAddOperator(left, this.MakeInt2LInt(right), TypeNode.LInt);
		else if (right.DataType == TypeNode.LInt)
			return new IntAddOperator(this.MakeInt2LInt(left), right, TypeNode.LInt);
		else {
			TypeNode resDataType = this.LargestDataType(left, right);
			return new IntAddOperator(left, right, resDataType);
		}	
	}

	private Expression MakeUIntAddop(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (leftValue == 0)
				return right;
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				if (rightValue == 0)
					return left;
				else {
					ulong sum = leftValue + rightValue;
					return this.MakeIntConstant(sum);
				}
			}
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return left;
		}
		TypeNode resultDataType = this.LargestDataType(left, right);
		return new UIntAddOperator(left, right, resultDataType);		
	}

	private Expression MakeIntUIntAddop(Expression left, Expression right, LexLocation location)
	{
		TypeNode resultDataType;
		if (left.DataType.Size > right.DataType.Size)
			resultDataType = left.DataType;
		else if (right.DataType == TypeNode.USInt)
			resultDataType = TypeNode.Int;
		else if (right.DataType == TypeNode.UInt)
			resultDataType = TypeNode.DInt;
		else if (right.DataType == TypeNode.UDInt)
			resultDataType = TypeNode.LInt;
		else {
			this.report.SemanticError(14, "+", left.DataType.Name, right.DataType.Name, location);
			return Expression.Error;
		}
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (leftValue == 0)
				return right;
			else if (right.IsConstant)
			{
				uint rightValue = Convert.ToUInt32(right.Evaluate());
				long sum = leftValue + rightValue;
				return MakeIntConstant(sum);
			}
		}
		else if (right.IsConstant)
		{
			uint rightValue = Convert.ToUInt32(right.Evaluate());
			if (rightValue == 0)
				return left;
		}
		return new IntAddOperator(left, right, resultDataType);
	}

	private Expression MakeLeftShiftOp(Expression expression, int power)
	{
		if (expression == null)
			return Expression.Error;
		else if (! expression.IsConstant)
			return new LeftShiftOperator(expression, power);
		else if (expression.DataType.IsSignedIntType)
		{
			long intValue = Convert.ToInt64(expression.Evaluate());
			return MakeIntConstant(intValue << power);
		}
		else {
			ulong intValue = Convert.ToUInt64(expression.Evaluate());
			return this.MakeIntConstant(intValue << power);
		}
	}

	private Expression MakeReal2LReal(Expression expression)
	{
		if (expression == null)
			return Expression.Error;
		else if (expression.DataType != TypeNode.Real)
			throw new STLangCompilerError("MakeReal2LReal() expects Real argument: " + expression);
		else if (! expression.IsConstant)
			return new Real2LRealOperator(expression);
		else
		{
			double value = Convert.ToDouble(expression.Evaluate());
			return MakeConstant(value);
		}
	}

	private Expression MakeLReal2Real(Expression expression)
	{
		if (expression == null)
			return Expression.Error;
		else if (expression.DataType != TypeNode.LReal)
			throw new STLangCompilerError("MakeLReal2Real() expects LReal argument: " + expression);
		else if (! expression.IsConstant)
			return new LReal2RealOperator(expression);
		else
		{
			float value = Convert.ToSingle(expression.Evaluate());
			return MakeConstant(value);
		}
	} 

	private Expression MakeInt2Real(Expression expression)
	{
		if (expression == null)
			return Expression.Error;
		else if (! expression.DataType.IsIntegerType)
			throw new STLangCompilerError("MakeInt2Real() expects integer argument: " + expression);
		else if (expression.IsConstant)
		{
			float value = Convert.ToSingle(expression.Evaluate());
			return MakeConstant(value);
		}
		else if (expression.DataType.Size == TypeNode.LInt.Size)
			return new LInt2RealOperator(expression);
		else
			return new Int2RealOperator(expression);
	}

	private Expression MakeInt2LReal(Expression expression)
	{
		if (expression == null)
			return Expression.Error;
		else if (! expression.DataType.IsIntegerType)
			throw new STLangCompilerError("MakeInt2LReal() expects integer argument: " + expression);
		else if (expression.IsConstant)
		{
			double value = Convert.ToDouble(expression.Evaluate());
			return MakeConstant(value);
		}
		else if (expression.DataType.Size == TypeNode.LInt.Size)
			return new LInt2LRealOperator(expression);
		else
			return new Int2LRealOperator(expression);
	}

	private Expression MakeInt2LInt(Expression expression)
	{
		if (expression == null)
			return Expression.Error;
		else if (! expression.DataType.IsIntegerType)
			throw new STLangCompilerError("MakeInt2LInt() expects integer argument: " + expression);
		else if (expression.IsConstant)
		{
			long value = Convert.ToInt64(expression.Evaluate());
			return new LIntConstant(value);
		}
		else if (expression.DataType.Size <= TypeNode.DInt.Size)
			return new Int2LIntOperator(expression);
		else
			return expression;
	}

	private Expression MakeTTAddOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			if (leftValue == TimeSpan.Zero)
				return right;
			else if (right.IsConstant)
			{
				TimeSpan rightValue = (TimeSpan)right.Evaluate();
				if (rightValue == TimeSpan.Zero)
					return left;
				else {
					TimeSpan sum; 
					try {
						sum = leftValue.Add(rightValue);
					}
					catch (System.OverflowException)
					{
						sum = TimeSpan.Zero;
						string text = left.ToString() + " + " + right.ToString();
						this.report.SemanticError(117, text, location);
					}
					return this.MakeConstant(sum);
				}
			}
		}
		else if (right.IsConstant)
		{
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			if (rightValue == TimeSpan.Zero)
				return left;
		}
		return new TTAddOperator(left, right);
	}

	private Expression MakeDTTimeAddOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			DateTime leftValue = Convert.ToDateTime(left.Evaluate());
			if (right.IsConstant)
			{
				TimeSpan rightValue = (TimeSpan)right.Evaluate();
				if (rightValue == TimeSpan.Zero)
					return left;
				else {
					DateTime sum; 
					try {
						sum = leftValue.Add(rightValue);
					}
					catch (System.ArgumentOutOfRangeException )
					{
						sum = DateTime.MinValue;
						string text = left.ToString() + " + " + right.ToString();
						this.report.SemanticError(117, text, location);
					}
					return this.MakeConstant(sum);
				}
			}
		}
		else if (right.IsConstant)
		{
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			if (rightValue == TimeSpan.Zero)
				return left;
		}
		return new DTTAddOperator(left, right);
	}

	private Expression MakeTTODAddOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			if (leftValue == TimeSpan.Zero)
				return right;
			else if (right.IsConstant)
			{
				TimeSpan timeOfDay; 
				TimeSpan rightValue = (TimeSpan)right.Evaluate();
				if (leftValue.Days != 0)
					leftValue -= new TimeSpan(leftValue.Days, 0, 0, 0);
				try {
					TimeSpan sum = leftValue.Add(rightValue);
					if (sum < TimeSpan.Zero)
						sum = sum.Add(new TimeSpan(0, 23, 59, 59, 999));
					int hours = sum.Hours;
					int minutes = sum.Minutes;
					int seconds = sum.Seconds;
					if (sum.Milliseconds == 0)
						timeOfDay = new TimeSpan(hours, minutes, seconds);
					else
						timeOfDay = new TimeSpan(hours, minutes, seconds, sum.Milliseconds);
				}
				catch (System.OverflowException)
				{
					timeOfDay = TimeSpan.Zero;
					string text = left.ToString() + " + " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeTODConstant(timeOfDay);
			}
		}
		else if (right.IsConstant)
		{
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			if (rightValue == TimeSpan.Zero)
				return left;
		}
		return new TTODAddOperator(left, right);
	}

	private Expression MakeIntSubOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				long difference = leftValue - rightValue;
				return MakeIntConstant(difference);
			}
			else if (leftValue == 0)
			{
				if (right is IntUnaryMinusOperator)
					return ((UnaryOperator)right).Operand;
				else 
					return new IntUnaryMinusOperator(right);
			}
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return left;
			else if (rightValue < 0)
			{
				right = MakeIntConstant(-rightValue);
				return this.MakeIntAddOp(left, right);
			}
		}
		else if (right is IntUnaryMinusOperator)
		{
			right = ((UnaryOperator)right).Operand;
			return this.MakeIntAddOp(left, right);
		}
		if (left.DataType == right.DataType)
			return new IntSubOperator(left, right, left.DataType);
		else if (left.DataType == TypeNode.LInt)
			return new IntSubOperator(left, this.MakeInt2LInt(right), TypeNode.LInt);
		else if (right.DataType == TypeNode.LInt)
			return new IntSubOperator(this.MakeInt2LInt(left), right, TypeNode.LInt);
		else {
			TypeNode resDataType = this.LargestDataType(left, right);
			return new IntSubOperator(left, right, resDataType);
		}	
	}

	private Expression MakeIntUIntSubOp(Expression left, Expression right, LexLocation location)
	{
		TypeNode resultDataType;
	
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				uint rightValue = Convert.ToUInt32(right.Evaluate());
				long difference = leftValue - rightValue;
				return MakeIntConstant(difference);
			}
		}
		if (left.DataType.Size > right.DataType.Size)
			resultDataType = left.DataType;
		else if (right.DataType == TypeNode.USInt)
			resultDataType = TypeNode.Int;
		else if (right.DataType == TypeNode.UInt)
			resultDataType = TypeNode.DInt;
		else if (right.DataType == TypeNode.UDInt)
			resultDataType = TypeNode.LInt;
		else {
			this.report.SemanticError(14, "-", left.DataType.Name, right.DataType.Name, location);
			return Expression.Error;
		}
		 return new UIntAddOperator(left, right, resultDataType);
	}

	private Expression MakeUIntSubOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (leftValue == 0)
				return right;
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				if (rightValue == 0)
					return left;
				else {
					ulong difference = leftValue - rightValue;
					return this.MakeIntConstant(difference);
				}
			}
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return left;
		}
		TypeNode resultDataType = this.LargestDataType(left, right);
		return new UIntSubOperator(left, right, resultDataType);		
	}

	private Expression MakeRealSubOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			float leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				float diff = leftValue - rightValue;
				if (float.IsPositiveInfinity(diff) || float.IsNegativeInfinity(diff))
				{
					diff = float.NaN;
					string text = left.ToString() + " - " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(diff);
			}
			else if (leftValue == 0.0f)
				return new RealUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return left;
		}
		else if (left is RealUnaryMinusOperator)
		{
			if (right is RealUnaryMinusOperator)
			{
				right = ((UnaryOperator)right).Operand;
				return new RealSubOperator(right, left);
			}
			else {
				left = ((UnaryOperator)left).Operand;
				Expression expr = new RealAddOperator(left, right);
				return new RealUnaryMinusOperator(expr);
			}
		}
		else if (right is RealUnaryMinusOperator)
		{
			right = ((UnaryOperator)right).Operand;
			return new RealAddOperator(left, right);
		}
		return new RealSubOperator(left, right);
	}

	private Expression MakeLRealSubOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				double diff = leftValue - rightValue;
				if (double.IsPositiveInfinity(diff) || double.IsNegativeInfinity(diff))
				{
					diff = double.NaN;
					string text = left.ToString() + " - " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(diff);
			}
			else if (leftValue == 0.0d)
				return new LRealUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return left;
		}
		else if (left is LRealUnaryMinusOperator)
		{
			if (right is LRealUnaryMinusOperator)
			{
				right = ((UnaryOperator)right).Operand;
				return new LRealSubOperator(right, left);
			}
			else {
				left = ((UnaryOperator)left).Operand;
				Expression expr = new LRealAddOperator(left, right);
				return new LRealUnaryMinusOperator(expr);
			}
		}
		else if (right is LRealUnaryMinusOperator)
		{
			right = ((UnaryOperator)right).Operand;
			return new LRealAddOperator(left, right);
		}
		return new LRealSubOperator(left, right);
	}

	private Expression MakeTimeSubOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			if (right.IsConstant)
			{
				TimeSpan difference;
				try {
					TimeSpan rightValue = (TimeSpan)right.Evaluate();
					difference = leftValue.Subtract(rightValue);
				}
				catch (System.OverflowException)
				{
					difference = TimeSpan.Zero;
					string text = left.ToString() + " - " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeConstant(difference);
			}
			else if (leftValue == TimeSpan.Zero)
				return new TimeUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			if (rightValue == TimeSpan.Zero)
				return left;
		}
		return new TimeSubOperator(left, right);
	}

	private Expression MakeDateTimeTimeSubOp(Expression left, Expression right, LexLocation location)
	{
		 if (! left.IsConstant || ! right.IsConstant)
			return new DTTimeSubOperator(left, right);
		else {
			DateTime difference;
			DateTime dateTime = Convert.ToDateTime(left.Evaluate());
			try {
				TimeSpan timeSpan =(TimeSpan)right.Evaluate();
				difference = dateTime.Subtract(timeSpan);
			}
			catch (System.ArgumentOutOfRangeException)
			{
				difference = DateTime.MinValue;
				string text = left.ToString() + " - " + right.ToString();
				this.report.SemanticError(118, text, location);
			}
			return this.MakeConstant(difference);
		}
	}

	private Expression MakeDateTimeSubOp(Expression left, Expression right, LexLocation location)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new DateTimeSubOperator(left, right);
		else {
			TimeSpan difference;
			DateTime leftValue = Convert.ToDateTime(left.Evaluate());
			try {
				DateTime rightValue = Convert.ToDateTime(right.Evaluate());
				difference = leftValue.Subtract(rightValue);
			}
			catch (System.ArgumentOutOfRangeException)
			{
				difference = TimeSpan.Zero;
				string text = left.ToString() + " - " + right.ToString();
				this.report.SemanticError(118, text, location);
			}
			return this.MakeConstant(difference);
		}
	}

	private Expression MakeDateSubOp(Expression left, Expression right, LexLocation location)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new DateSubOperator(left, right);
		else {
			TimeSpan difference;
			DateTime leftValue = Convert.ToDateTime(left.Evaluate());
			try {
				DateTime rightValue = Convert.ToDateTime(right.Evaluate());
				difference = leftValue.Subtract(rightValue);
			}
			catch (System.ArgumentOutOfRangeException)
			{
				difference = TimeSpan.Zero;
				string text = left.ToString() + " - " + right.ToString();
				this.report.SemanticError(118, text, location);
			}
			return this.MakeConstant(difference);
		}
	}

	private Expression MakeTimeOfDaySubOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant && right.IsConstant)
		{
			TimeSpan difference;
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			
			try {
				TimeSpan rightValue = (TimeSpan)right.Evaluate();
				difference = leftValue.Subtract(rightValue);
			}
			catch (System.OverflowException)
			{
				difference = TimeSpan.Zero;
				string text = left.ToString() + " - " + right.ToString();
				this.report.SemanticError(119, text, location);
			}
			return this.MakeConstant(difference);
		}
		return new TimeOfDaySubOperator(left, right);
	}

	private Expression MakeTimeOfDayTimeSubOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			if (leftValue == TimeSpan.Zero)
				return right;
			else if (right.IsConstant)
			{
				TimeSpan difference;
			
				try {
					TimeSpan rightValue = (TimeSpan)right.Evaluate();
					difference = leftValue.Subtract(rightValue);
				}
				catch (System.OverflowException)
				{
					difference = TimeSpan.Zero;
					string text = left.ToString() + " - " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeConstant(difference);
			}
		}
		return new TODTimeSubOperator(left, right);
	}

	private Expression MakeIntMulOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			
			if (leftValue == 0)
				return MakeIntConstant(0);
			else if (leftValue == 1)
				return right;
			else if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				long product = leftValue * rightValue;
				return MakeIntConstant(product);
			}
			else if (leftValue == -1)
				return new IntUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return MakeIntConstant(0);
			else if (rightValue == 1)
				return left;
			else if (rightValue == -1)
				return new IntUnaryMinusOperator(left);
		}
		else if ((left is IntUnaryMinusOperator) && (right is IntUnaryMinusOperator))
		{
			left = ((UnaryOperator)left).Operand;
			right = ((UnaryOperator)right).Operand;
		}
		if (left.DataType == right.DataType)
			return new IntMulOperator(left, right, left.DataType);
		else if (left.DataType == TypeNode.LInt)
			return new IntMulOperator(left, this.MakeInt2LInt(right), TypeNode.LInt);
		else if (right.DataType == TypeNode.LInt)
			return new IntMulOperator(this.MakeInt2LInt(left), right, TypeNode.LInt);
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			return new IntMulOperator(left, right, resultDataType);
		}
	}

	private Expression MakeUIntMulop(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			
			if (leftValue == 0)
				return MakeIntConstant((ulong)0);
			else if (leftValue == 1)
				return right;
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				ulong product = leftValue * rightValue;
				return this.MakeIntConstant(product);
			}
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return this.MakeIntConstant((ulong)0);
			else if (rightValue == 1)
				return left;
		}
		if (left.DataType == right.DataType)
			return new UIntMulOperator(left, right, left.DataType);
		else if (left.DataType == TypeNode.LInt)
			return new UIntMulOperator(left, this.MakeInt2LInt(right), TypeNode.LInt);
		else if (right.DataType == TypeNode.LInt)
			return new UIntMulOperator(this.MakeInt2LInt(left), right, TypeNode.LInt);
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			return new UIntMulOperator(left, right, resultDataType);
		}
	}

	private Expression MakeIntUIntMulop(Expression left, Expression right, LexLocation location)
	{
		TypeNode resultDataType;
		if (left.DataType.Size > right.DataType.Size)
			resultDataType = left.DataType;
		else if (right.DataType == TypeNode.USInt)
			resultDataType = TypeNode.Int;
		else if (right.DataType == TypeNode.UInt)
			resultDataType = TypeNode.DInt;
		else if (right.DataType == TypeNode.UDInt)
			resultDataType = TypeNode.LInt;
		else {
			this.report.SemanticError(14, "*", left.DataType.Name, right.DataType.Name, location);
			return Expression.Error;
		}
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (leftValue == 0)
				return MakeIntConstant(0);
			else if (leftValue == 1)
				return right;
			else if (right.IsConstant)
			{
				uint rightValue = Convert.ToUInt32(right.Evaluate());
				long product = leftValue * rightValue;
				return MakeIntConstant(product);
			}
			else if (leftValue == -1)
				return right;
		}
		else if (right.IsConstant)
		{
			uint rightValue = Convert.ToUInt32(right.Evaluate());
			if (rightValue == 0)
				return MakeIntConstant(0);
			else if (rightValue == 1)
				return left;
		}
		return new IntMulOperator(left, right, resultDataType);
	}

	private Expression MakeRealMulOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			float leftValue = Convert.ToSingle(left.Evaluate());
			if (leftValue == 0.0f)
				return MakeConstant(0.0f);
			else if (leftValue == 1.0f)
				return right;
			else if (right.IsConstant)
			{
				float product;

				try {
					float rightValue = Convert.ToSingle(right.Evaluate());
					product = leftValue * rightValue;
				}
				catch (System.OverflowException)
				{
					product = float.NaN;
					string text = left.ToString() + " * " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(product);
			}
			else if (leftValue == -1.0f)
				return new RealUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return MakeConstant(0.0f);
			else if (rightValue == 1.0f)
				return left;
			else if (rightValue == -1.0f)
				return new RealUnaryMinusOperator(left);
		}
		return new RealMulOperator(left, right);
	}

	private Expression MakeLRealMulOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (leftValue == 0.0d)
				return MakeConstant(0.0d);
			else if (leftValue == 1.0d)
				return right;
			else if (right.IsConstant)
			{
				double product;

				try {
					double rightValue = Convert.ToDouble(right.Evaluate());
					product = leftValue * rightValue;
				}
				catch (System.OverflowException)
				{
					product = double.NaN;
					string text = left.ToString() + " * " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(product);
			}
			else if (leftValue == -1.0d)
				return new LRealUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return MakeConstant(0.0d);
			else if (rightValue == 1.0d)
				return left;
			else if (rightValue == -1.0d)
				return new LRealUnaryMinusOperator(left);
		}
		return new LRealMulOperator(left, right);
	}

	private Expression MakeIntTimeMulOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan timeSpan = (TimeSpan)left.Evaluate();
			
			if (timeSpan == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
			else if (right.IsConstant)
			{
				long factor = Convert.ToInt64(right.Evaluate());
				long ticks = timeSpan.Ticks * factor;
				if (ticks < TimeSpan.MinValue.Ticks || ticks > TimeSpan.MaxValue.Ticks)
				{
					ticks = 0;
					string text = left.ToString() + " * " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeConstant(new TimeSpan(ticks));
			}
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return this.MakeConstant(TimeSpan.Zero);
			else if (rightValue == 1)
				return left;
			else if (rightValue == -1)
				return new TimeUnaryMinusOperator(left);
		}
		return new IntTimeMulOperator(left, right);
	}

	private Expression MakeRealTimeMulOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan timeSpan = (TimeSpan)left.Evaluate();
			
			if (timeSpan == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
			else if (right.IsConstant)
			{
				Single factor = Convert.ToSingle(right.Evaluate());
				long ticks = (long)(timeSpan.Ticks * factor);
				if (ticks < TimeSpan.MinValue.Ticks || ticks > TimeSpan.MaxValue.Ticks)
				{
					ticks = 0;
					string text = left.ToString() + " * " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeConstant(new TimeSpan(ticks));
			}
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return this.MakeConstant(TimeSpan.Zero);
			else if (rightValue == 1.0f)
				return left;
			else if (rightValue == -1.0f)
				return new TimeUnaryMinusOperator(left);
		}
		return new RealTimeMulOperator(left, right);
	}

	private Expression MakeLRealTimeMulOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan timeSpan = (TimeSpan)left.Evaluate();
			
			if (timeSpan == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
			else if (right.IsConstant)
			{
				double factor = Convert.ToDouble(right.Evaluate());
				long ticks = (long)(timeSpan.Ticks * factor);
				if (ticks < TimeSpan.MinValue.Ticks || ticks > TimeSpan.MaxValue.Ticks)
				{
					ticks = 0;
					string text = left.ToString() + " * " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeConstant(new TimeSpan(ticks));
			}
		}
		else if (right.IsConstant)
		{
			double factor = Convert.ToDouble(right.Evaluate());
			if (factor == 0.0d)
				return this.MakeConstant(TimeSpan.Zero);
			else if (factor == 1.0d)
				return left;
			else if (factor == -1.0d)
				return new TimeUnaryMinusOperator(left);
		}
		return new LRealTimeMulOperator(left, right);
	}

	private Expression MakeIntDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				if (rightValue == 0)
				{
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
				else {
					long quotient = leftValue / rightValue;
					return MakeIntConstant(quotient);
				}
			}
			else if (leftValue == 0)
				return MakeIntConstant((long)0);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1)
				return left;
			else if (rightValue == -1)
				return new IntUnaryMinusOperator(left);
			else {
				int power;
				if (this.IsPowerOf2((ulong)Math.Abs(rightValue), out power))
				{
					Expression expr = new LeftShiftOperator(left, power);
					if (rightValue < 0)
						expr = new IntUnaryMinusOperator(expr);
					return expr;
				}
			}
		}
		if (left.DataType == right.DataType)
			return new IntDivOperator(left, right, left.DataType);
		else if (left.DataType == TypeNode.LInt)
			return new IntDivOperator(left, this.MakeInt2LInt(right), TypeNode.LInt);
		else if (right.DataType == TypeNode.LInt)
			return new IntDivOperator(this.MakeInt2LInt(left), right, TypeNode.LInt);
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			return new IntDivOperator(left, right, resultDataType);
		}
	}

	private Expression MakeTimeIntDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				if (rightValue == 0)
				{
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
				else {
					long ticks = leftValue.Ticks/rightValue;
					return this.MakeConstant(new TimeSpan(ticks));
				}
			}
			else if (leftValue == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1)
				return left;
			else if (rightValue == -1)
				return new TimeUnaryMinusOperator(left);
		}
		return new TimeIntDivOperator(left, right);		
	}

	private Expression MakeTimeRealDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				if (rightValue == 0.0f)
				{
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
				else {
					double ticks = leftValue.Ticks/(double)rightValue;
					return this.MakeConstant(new TimeSpan((long)ticks));
				}
			}
			else if (leftValue == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1.0f)
				return left;
			else if (rightValue == -1.0f)
				return new TimeUnaryMinusOperator(left);
		}
		return new TimeLRealDivOperator(left, right);		
	}

	private Expression MakeTimeLRealDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				if (rightValue == 0.0d)
				{
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
				else {
					double ticks = leftValue.Ticks/rightValue;
					return this.MakeConstant(new TimeSpan((long)ticks));
				}
			}
			else if (leftValue == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1.0f)
				return left;
			else if (rightValue == -1.0f)
				return new TimeUnaryMinusOperator(left);
		}
		return new TimeRealDivOperator(left, right);		
	}

	private Expression MakeRealDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			float leftValue = Convert.ToSingle(left.Evaluate());
			
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				float quotient = leftValue / rightValue;
				if (! float.IsInfinity(quotient))
					return MakeConstant(quotient);
				else {
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
			}
			if (leftValue == 0.0f)
				return MakeConstant(0.0f);
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1.0f)
				return left;
			else if (rightValue == -1.0f)
				return new RealUnaryMinusOperator(left);
		}
		return new RealDivOperator(left, right);		
	}

	private Expression MakeLRealDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				double quotient   = leftValue / rightValue;
				if (! double.IsInfinity(quotient))
					return MakeConstant(quotient);
				else {
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
			}
			else if (leftValue == 0.0d)
				return MakeConstant(0.0d);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1.0d)
				return left;
			else if (rightValue == -1.0d)
				return new LRealUnaryMinusOperator(left);
		}
		return new LRealDivOperator(left, right);		
	}

	private Expression MakeIntUnaryMinusOp(Expression expression)
	{
		if (expression.IsConstant)
		{
			long value = Convert.ToInt64(expression.Evaluate());
			return MakeIntConstant(-value);
		}
		else if (expression is IntUnaryMinusOperator)
			return ((UnaryOperator)expression).Operand;
		else
			return new IntUnaryMinusOperator(expression);
	}

	private Expression MakeIntPowerOp(Expression left, Expression right)
	{
		if (right.IsConstant)
		{
			int exponent = Convert.ToInt32(right.Evaluate());
			if (exponent < 0)
				return MakeConstant(0);
			else if (exponent == 0)
				return MakeConstant(1);
			else if (exponent == 1)
				return left;
			else if (left.IsConstant)
			{
				if (left.DataType.IsSignedIntType)
				{
					long base_ = Convert.ToInt64(left.Evaluate());
					long result = this.IntPower(base_, exponent);
					return MakeIntConstant(result); 
				}
				else {
					ulong base_ = Convert.ToUInt64(left.Evaluate());
					ulong result = this.IntPower(base_, exponent);
					return this.MakeIntConstant(result); 
				}
			}
		}
		return new IntPowerOperator(left, right, left.DataType);
	}

	private Expression MakeRealPowerOp(Expression left, Expression right)
	{
		if (! right.IsConstant)
		{
			if (right.DataType.IsIntegerType)
				return new RealPowerOperator(left, new Int2RealOperator(right));
			else if (right.DataType == TypeNode.Real)
				return new RealPowerOperator(left, right);
			else {
				string msg;
				msg = "MakeRealPowerOp(): Real type exponent expected.";
				throw new STLangCompilerError(msg);
			}
		}
		else if (right.DataType.IsIntegerType)
		{
			int exponent = Convert.ToInt32(right.Evaluate());
			
			if (exponent == 0)
				return MakeConstant(1.0f);
			else if (exponent == 1)
				return left;
			else if (left.IsConstant)
			{
				double base_ = Convert.ToDouble(left.Evaluate());
				float result = (float)Math.Pow(base_, exponent);
				return MakeConstant(result);
			}
			else if (Math.Abs(exponent) > 4)
				right = MakeConstant((float)exponent);
		}
		else if (right.DataType == TypeNode.Real)
		{
			float exponent = Convert.ToSingle(right.Evaluate());
			if (exponent == 0.0f)
				return MakeConstant(1.0f);
			else if (exponent == 1.0f)
				return left;
			else if (left.IsConstant)
			{
				double base_ = Convert.ToDouble(left.Evaluate());
				float result = (float)Math.Pow(base_, exponent);
				return MakeConstant(result);
			}
		}
		return new RealPowerOperator(left, right);
	}

	private Expression MakeLRealPowerOp(Expression left, Expression right)
	{
		if (! right.IsConstant)
		{
			if (right.DataType.IsIntegerType)
				return new LRealPowerOperator(left, new Int2LRealOperator(right));
			else if (right.DataType == TypeNode.LReal)
				return new LRealPowerOperator(left, right);
			else {
				string msg;
				msg = "MakeRealPowerOp(): LReal type exponent expected.";
				throw new STLangCompilerError(msg);
			}
		}
		else if (right.DataType.IsIntegerType)
		{
			int exponent = Convert.ToInt32(right.Evaluate());
			
			if (exponent == 0)
				return MakeConstant(1.0d);
			else if (exponent == 1)
				return left;
			else if (left.IsConstant)
			{
				double base_ = Convert.ToDouble(left.Evaluate());
				double result = Math.Pow(base_, exponent);
				return MakeConstant(result);
			}
			else if (Math.Abs(exponent) > 4)
				right = MakeConstant((double)exponent);
		}
		else if (right.DataType == TypeNode.LReal)
		{
			double exponent = Convert.ToDouble(right.Evaluate());
			if (exponent == 0.0d)
				return MakeConstant(1.0d);
			else if (exponent == 1.0d)
				return left;
			else if (left.IsConstant)
			{
				double base_ = Convert.ToDouble(left.Evaluate());
				double result = Math.Pow(base_, exponent);
				return MakeConstant(result);
			}
		}
		return new LRealPowerOperator(left, right);
	}

	private Expression MakeIntModOp(Expression left, Expression right, LexLocation location)
	{
		if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (left.IsConstant)
			{
				ulong leftValue = Convert.ToUInt64(left.Evaluate());
				ulong result = leftValue % rightValue;
				if (left.DataType.IsUnsignedIntType || right.DataType.IsUnsignedIntType)
					return this.MakeIntConstant(result);
				else
					return MakeIntConstant((long)result);
			}
			else {
				int power;

				if (this.IsPowerOf2(rightValue, out power))
				{
					long bitMask = 1;
					bitMask <<= power;
					bitMask -= 1;
					right = MakeIntConstant(bitMask);
					return new BitAndOperator(left, right, right.DataType);
				}
			}
		}
		return new ModOperator(left, right);
	}

	private Expression MakeAddOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;

			if (leftDataType == TypeNode.Error || rightDataType == TypeNode.Error)
				return Expression.Error;
			else if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntAddOp(left, right);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeIntUIntAddop(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealAddOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealAddOp(this.MakeInt2LReal(left), right, location);
			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntUIntAddop(right, left, location);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntAddop(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealAddOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealAddOp(this.MakeInt2LReal(left), right, location);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealAddOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealAddOp(this.MakeReal2LReal(left), right, location);
				else if (rightDataType.IsIntegerType)
					return this.MakeRealAddOp(left, this.MakeInt2Real(right), location);
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealAddOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealAddOp(left, this.MakeReal2LReal(right), location);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealAddOp(left, this.MakeInt2LReal(right), location);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTTAddOp(left, right, location);
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTTODAddOp(left, right, location);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.Time)
				return this.MakeTTODAddOp(right, left, location);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.Time)
				return this.MakeDTTimeAddOp(left, right, location);
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.DateAndTime)
				return this.MakeDTTimeAddOp(right, left, location);
			//
			// Error. Incompatible operand types of operator +
			//
			this.report.SemanticError(14, "+", leftDataType.Name, rightDataType.Name, location);
			return Expression.Error;
		}
	}

	private Expression MakeSubOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;

			if (leftDataType == TypeNode.Error || rightDataType == TypeNode.Error)
				return Expression.Error;
			else if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntSubOp(left, right);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeIntUIntSubOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealSubOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealSubOp(this.MakeInt2LReal(left), right, location);
			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntUIntSubOp(right, left, location);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntSubOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealSubOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealSubOp(this.MakeInt2LReal(left), right, location);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealSubOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealSubOp(this.MakeReal2LReal(left), right, location);
				else if (rightDataType.IsIntegerType)
					return this.MakeRealSubOp(left, this.MakeInt2Real(right), location);
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealSubOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealSubOp(left, this.MakeReal2LReal(right), location);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealSubOp(left, this.MakeInt2LReal(right), location);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeSubOp(left, right, location);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDaySubOp(left, right, location);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.Time)
				return this.MakeTimeOfDayTimeSubOp(right, left, location);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.Time)
				return this.MakeDateTimeTimeSubOp(left, right, location);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeSubOp(right, left, location);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateSubOp(right, left, location);
			//
			// Error. Incompatible operand types of operator -
			//
			this.report.SemanticError(14, "-", leftDataType.Name, rightDataType.Name, location);
			return Expression.Error;
		}
	}

	private Expression MakeMulOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;

			if (leftDataType == TypeNode.Error || rightDataType == TypeNode.Error)
				return Expression.Error;
			else if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntMulOp(left, right);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeIntUIntMulop(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealMulOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealMulOp(this.MakeInt2LReal(left), right, location);
				else if (rightDataType == TypeNode.Time)
					return this.MakeIntTimeMulOp(right, left, location);
			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntUIntMulop(right, left, location);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntMulop(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealMulOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealMulOp(this.MakeInt2LReal(left), right, location);
				else if (rightDataType == TypeNode.Time)
					return this.MakeIntTimeMulOp(right, left, location);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealMulOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealMulOp(this.MakeReal2LReal(left), right, location);
				else if (rightDataType.IsIntegerType)
					return this.MakeRealMulOp(left, this.MakeInt2Real(right), location);
				else if (rightDataType == TypeNode.Time)
					return this.MakeRealTimeMulOp(right, left, location);
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealMulOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealMulOp(left, this.MakeReal2LReal(right), location);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealMulOp(left, this.MakeInt2LReal(right), location);
				else if (rightDataType == TypeNode.Time)
					return this.MakeLRealTimeMulOp(right, left, location);
			}
			else if (leftDataType == TypeNode.Time)
			{
				if (rightDataType.IsIntegerType)
					return this.MakeIntTimeMulOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealTimeMulOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealTimeMulOp(right, left, location);
			}
			//
			// Error. Incompatible operand types of operator *
			//
			this.report.SemanticError(14, "*", leftDataType.Name, rightDataType.Name, location);
			return Expression.Error;
		}
	}

	private Expression MakeDivOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;

			if (leftDataType == TypeNode.Error || rightDataType == TypeNode.Error)
				return Expression.Error;
			else if (leftDataType.IsIntegerType)
			{
				if (rightDataType.IsIntegerType)
					return this.MakeIntDivOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealDivOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealDivOp(this.MakeInt2LReal(left), right, location);
			}         
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealDivOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealDivOp(this.MakeReal2LReal(left), right, location);
				else if (rightDataType.IsIntegerType)
					return this.MakeRealDivOp(left, this.MakeInt2Real(right), location);
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealDivOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealDivOp(left, this.MakeReal2LReal(right), location);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealDivOp(left, this.MakeInt2LReal(right), location);
			}
			else if (leftDataType == TypeNode.Time)
			{
				if (rightDataType.IsIntegerType)
					return this.MakeTimeIntDivOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeTimeRealDivOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeTimeLRealDivOp(right, left, location);
			}
			//
			// Error. Incompatible operand types of operator /
			//
			this.report.SemanticError(14, "/", leftDataType.Name, rightDataType.Name, location);
			return Expression.Error;
		}
	}

	private Expression MakeRealUnaryMinusOp(Expression expression)
	{
		if (! expression.IsConstant)
			return new RealUnaryMinusOperator(expression);
		else {
			float realValue = -(float)expression.Evaluate();
			return MakeConstant(realValue);
		}
	}

	private Expression MakeLRealUnaryMinusOp(Expression expression)
	{
		if (! expression.IsConstant)
			return new LRealUnaryMinusOperator(expression);
		else {
			double doubleValue = -(double)expression.Evaluate();
			return MakeConstant(doubleValue);
		}
	}

	private Expression MakeTimeUnaryMinusOp(Expression expression)
	{
		if (! expression.IsConstant)
			return new LRealUnaryMinusOperator(expression);
		else {
			double doubleValue = -(double)expression.Evaluate();
			return MakeConstant(doubleValue);
		}
	}

	private Expression MakeUnaryMinusOperator(Expression expression, LexLocation location)
	{
		if (expression == null)
			return Expression.Error;
		else {
			TypeNode dataType = expression.DataType;
			if (dataType == TypeNode.Error)
				return expression;
			else if (dataType.IsSignedIntType)
				return this.MakeIntUnaryMinusOp(expression);
			else if (dataType.IsUnsignedIntType)
			{
				// unary minus applied to unsigned int type has no effect
				this.report.Warning(8, dataType.Name, location);
				return expression;
			}
			else if (dataType == TypeNode.Real)
				return this.MakeRealUnaryMinusOp(expression);
			else if (dataType == TypeNode.LReal)
				return this.MakeLRealUnaryMinusOp(expression);
			else if (dataType == TypeNode.Time)
				return this.MakeTimeUnaryMinusOp(expression);
			else {
				this.report.SemanticError(-14, "-", dataType.Name, location);
				return Expression.Error;
			}
		}
	}

	private Expression MakeUnaryPlusOperator(Expression expression, LexLocation location)
	{
		if (expression == null)
			return Expression.Error;
		else {
			TypeNode dataType = expression.DataType;
			if (dataType == TypeNode.Error)
				return expression;
			else if (dataType.IsNumericalType)
				return expression;
			else if (dataType == TypeNode.Time)
				return expression;
			else {
				this.report.SemanticError(-14, "+", dataType.Name, location);
				return Expression.Error;
			}
		}
	}

	private bool IsBitWiseType(Expression expression)
	{
		TypeNode dataType = expression.DataType;
		return dataType.IsBitStringType || (dataType.IsIntegerType && expression.IsConstant);
	}

	private Expression MakeAndOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else if (! this.IsBitWiseType(left) || ! this.IsBitWiseType(right))
		{
			string dataTypeName1 = left.DataType.Name;
			string dataTypeName2 = right.DataType.Name;
			this.report.SemanticError(14, "AND", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			if (left.IsConstant)
			{
				ulong leftValue = Convert.ToUInt64(left.Evaluate());
				if (leftValue == 0)
					return this.MakeConstant(leftValue, resultDataType);
				else if (this.BitCount(leftValue) == resultDataType.BitCount)
					return right;
				else if (right.IsConstant)
				{
					ulong rightValue = Convert.ToUInt64(right.Evaluate());
					ulong result = leftValue & rightValue;
					return this.MakeConstant(result, resultDataType);
				}
			}
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				if (rightValue == 0)
					return this.MakeConstant(rightValue, resultDataType);
				else if (this.BitCount(rightValue) == resultDataType.BitCount)
					return left;
			}
			if (resultDataType != TypeNode.Bool)
				return new BitAndOperator(left, right, resultDataType);
			else if (left is AndOperator)
			{
				((AndOperator)left).Add(right);
				return left;
			}
			else if (right is AndOperator)
			{
				((AndOperator)right).AddLeft(left);
				return right;
			}
			return new AndOperator(left, right);
		}
	}

	private Expression MakeIOrOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else if (! this.IsBitWiseType(left) || ! this.IsBitWiseType(right))
		{
			string dataTypeName1 = left.DataType.Name;
			string dataTypeName2 = right.DataType.Name;
			this.report.SemanticError(14, "OR", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			if (left.IsConstant)
			{
				ulong leftValue = Convert.ToUInt64(left.Evaluate());
				if (leftValue == 0)
					return right;
				else if (this.BitCount(leftValue) == resultDataType.BitCount)
					return left;
				else if (right.IsConstant)
				{
					ulong rightValue = Convert.ToUInt64(right.Evaluate());
					ulong result = leftValue | rightValue;
					return this.MakeConstant(result, resultDataType);
				}
			}
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				if (rightValue == 0)
					return left;
				else if (this.BitCount(rightValue) == resultDataType.BitCount)
					return right;
			}
			if (resultDataType != TypeNode.Bool)
				return new BitIOrOperator(left, right, resultDataType);
			else if (left is IOrOperator)
			{
				((IOrOperator)left).Add(right);
				return left;
			}
			else if (right is IOrOperator)
			{
				((IOrOperator)right).AddLeft(left);
				return right;
			}
			return new IOrOperator(left, right);
		}
	}

	private Expression MakeXOrOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else if (! this.IsBitWiseType(left) || ! this.IsBitWiseType(right))
		{
			string DataTypeName1 = left.DataType.Name;
			string DataTypeName2 = right.DataType.Name;
			this.report.SemanticError(14, "XOR", DataTypeName1, DataTypeName2, location);
			return Expression.Error;
		}
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			if (left.IsConstant)
			{
				ulong leftValue = Convert.ToUInt64(left.Evaluate());
				if (leftValue == 0)
					return right;
				else if (right.IsConstant)
				{
					ulong rightValue = Convert.ToUInt64(right.Evaluate());
					ulong result = leftValue ^ rightValue;
					return this.MakeConstant(result, resultDataType);
				}
			}
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				if (rightValue == 0)
					return left;
			}
			if (resultDataType != TypeNode.Bool)
				return new BitXOrOperator(left, right, resultDataType);
			else {
				Expression leftTree = left.DeMorgan();
				Expression rightTree = right.DeMorgan();
				if (leftTree is AndOperator)
					((AndOperator)leftTree).Add(right);
				else
					leftTree = new AndOperator(leftTree, right);
				if (rightTree is AndOperator)
					((AndOperator)rightTree).Add(left);
				else
					rightTree = new AndOperator(left, rightTree);
				return new IOrOperator(leftTree, rightTree);
			}	
		}
	}

	private Expression MakeNotOperator(Expression expression, LexLocation location)
	{
		if (expression == null)
			return Expression.Error;
		else if (expression is FunctionName)
		{
			this.report.SemanticError(148, expression.ToString(), location);
			return Expression.Error;
		}
		else if (expression.DataType == TypeNode.Error)
			return Expression.Error;
		else if (! this.IsBitWiseType(expression))
		{
			string dataTypeName = expression.DataType.Name;
			this.report.SemanticError(-14, "NOT", dataTypeName, location);
			return Expression.Error;
		}
		else if (expression.IsConstant)
		{
			ulong value = Convert.ToUInt64(expression.Evaluate());
			return this.MakeConstant(~value, expression.DataType);
		}
		if (expression.DataType == TypeNode.Bool)
			return expression.DeMorgan();
		else
			return new BitNotOperator(expression);
	}

	private Expression MakePowOperator(Expression base_, Expression exponent, LexLocation location)
	{
		if (base_ == null || exponent == null)
			return Expression.Error;
        else if (base_ is FunctionName)
		{
			this.report.SemanticError(148, base_.ToString(), location);
			return Expression.Error;
		}
		else if (exponent is FunctionName)
		{
			this.report.SemanticError(148, exponent.ToString(), location);
			return Expression.Error;
		}
		else if (base_.DataType == TypeNode.Error || exponent.DataType == TypeNode.Error)
			return Expression.Error;
		else if (base_.DataType == TypeNode.LReal)
		{
			if (exponent.DataType == TypeNode.LReal)
				return this.MakeLRealPowerOp(base_, exponent);
			else if (exponent.DataType == TypeNode.Real)
				return this.MakeLRealPowerOp(base_, this.MakeReal2LReal(exponent));
			else if (exponent.DataType.IsIntegerType)
				return this.MakeLRealPowerOp(base_, exponent);
		}
		else if (base_.DataType == TypeNode.Real)
		{
			if (exponent.DataType == TypeNode.Real)
				return this.MakeRealPowerOp(base_, exponent);
			else if (exponent.DataType == TypeNode.LReal)
				return this.MakeRealPowerOp(this.MakeReal2LReal(base_), exponent);
			else if (exponent.DataType.IsIntegerType)
				return this.MakeRealPowerOp(base_, exponent);
		}
		else if (base_.DataType.IsIntegerType)
		{
			if (exponent.DataType.IsIntegerType)
				return this.MakeIntPowerOp(base_, exponent);
			else if (exponent.DataType == TypeNode.LReal)
				return this.MakeLRealPowerOp(this.MakeInt2LReal(base_), exponent);
			else if (exponent.DataType == TypeNode.Real)
				return this.MakeRealPowerOp(this.MakeInt2Real(base_), exponent);
		}
		//
		// Error. Incompatible operand types of operator **
		//
		string dataTypeName1 = base_.DataType.Name;
		string dataTypeName2 = exponent.DataType.Name;
		this.report.SemanticError(14, " ** ", dataTypeName1, dataTypeName2, location);
		return Expression.Error;
	}

	private Expression MakeModOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else if (left.DataType.IsIntegerType && right.DataType.IsIntegerType)
			return this.MakeIntModOp(left, right, location);
		else {
			//
			// Error. Incompatible operand types of operator MOD
			//
			string dataTypeName1 = left.DataType.Name;
			string dataTypeName2 = right.DataType.Name;
			this.report.SemanticError(14, " MOD ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeIntGtrOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue > rightValue);
			}
			else if (leftValue == 0)
				return new IntLesOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntGtrOperator(left, right, true);
		}
		return new IntGtrOperator(left, right);
	}

	private Expression MakeUIntGtrOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				return this.MakeConstant(leftValue > rightValue);
			}
			else if (leftValue == 0)
				return new IntLesOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntGtrOperator(left, right, true);
		}
		return new IntGtrOperator(left, right);
	}

	private Expression MakeRealGtrOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				Single rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue > rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatLesOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatGtrOperator(left, right, true);
		}
		return new FloatGtrOperator(left, right);
	}

	private Expression MakeLRealGtrOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue > rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealLesOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealGtrOperator(left, right, true);
		}
		return new LRealGtrOperator(left, right);
	}

	private Expression MakeTimeGtrOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeGtrOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeDateTimeGtrOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeGtrOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeStringGtrOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringGtrOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) > 0);
		}
	}

	private Expression MakeWStringGtrOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringGtrOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) > 0);
		}
	}

	private Expression MakeTimeOfDayGtrOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new TimeOfDayGtrOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeIntLesOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue < rightValue);
			}
			else if (leftValue == 0)
				return new IntGtrOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntLesOperator(left, right, true);
		}
		return new IntLesOperator(left, right);
	}

	private Expression MakeUIntLesOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				return this.MakeConstant(leftValue < rightValue);
			}
			else if (leftValue == 0)
				return new IntGtrOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntLesOperator(left, right, true);
		}
		return new IntLesOperator(left, right);
	}

	private Expression MakeRealLesOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				Single rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue < rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatGtrOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatLesOperator(left, right, true);
		}
		return new FloatLesOperator(left, right);
	}

	private Expression MakeLRealLesOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue < rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealGtrOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealLesOperator(left, right, true);
		}
		return new LRealLesOperator(left, right);
	}

	private Expression MakeTimeLesOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeLesOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeDateTimeLesOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeLesOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeStringLesOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringLesOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) > 0);
		}
	}

	private Expression MakeWStringLesOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringLesOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) > 0);
		}
	}

	private Expression MakeTimeOfDayLesOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new TimeOfDayLesOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeUIntEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new IntEqlOperator(left, right);
		else {
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeIntEqlOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue == rightValue);
			}
			else if (leftValue == 0)
				return new IntEqlOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntEqlOperator(left, right, true);
		}
		return new IntEqlOperator(left, right);
	}

	private Expression MakeRealEqlOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue == rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatEqlOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatEqlOperator(left, right, true);
		}
		return new FloatEqlOperator(left, right);
	}

	private Expression MakeLRealEqlOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue == rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealEqlOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealEqlOperator(left, right, true);
		}
		return new LRealEqlOperator(left, right);
	}

	private Expression MakeTimeEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeEqlOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeDateTimeEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeEqlOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeStringEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringEqlOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeWStringEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringEqlOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeTimeOfDayEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeOfDayEqlOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeIntNeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue != rightValue);
			}
			else if (leftValue == 0)
				return new IntNeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntNeqOperator(left, right, true);
		}
		return new IntNeqOperator(left, right);
	}

	private Expression MakeUIntNeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				return this.MakeConstant(leftValue != rightValue);
			}
			else if (leftValue == 0)
				return new IntNeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntNeqOperator(left, right, true);
		}
		return new IntNeqOperator(left, right);
	}

	private Expression MakeRealNeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue != rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatNeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatNeqOperator(left, right, true);
		}
		return new FloatNeqOperator(left, right);
	}

	private Expression MakeLRealNeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue != rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealNeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealNeqOperator(left, right, true);
		}
		return new LRealNeqOperator(left, right);
	}

	private Expression MakeTimeNeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeNeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue != rightValue);
		}
	}

	private Expression MakeDateTimeNeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeNeqOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue != rightValue);
		}
	}

	private Expression MakeStringNeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringNeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) != 0);
		}
	}

	private Expression MakeWStringNeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringNeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) != 0);
		}
	}

	private Expression MakeTimeOfDayNeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new TimeOfDayGeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue != rightValue);
		}
	}

	private Expression MakeIntGeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue >= rightValue);
			}
			else if (leftValue == 0)
				return new IntGeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntGeqOperator(left, right, true);
		}
		return new IntGeqOperator(left, right);
	}

	private Expression MakeUIntGeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				return this.MakeConstant(leftValue >= rightValue);
			}
			else if (leftValue == 0)
				return new IntLeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntGeqOperator(left, right, true);
		}
		return new IntGeqOperator(left, right);
	}

	private Expression MakeRealGeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue >= rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatLeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatGeqOperator(left, right, true);
		}
		return new FloatGeqOperator(left, right);
	}

	private Expression MakeLRealGeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue >= rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealLeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealGeqOperator(left, right, true);
		}
		return new LRealGeqOperator(left, right);
	}

	private Expression MakeTimeGeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeGeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue >= rightValue);
		}
	}

	private Expression MakeDateTimeGeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeGeqOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue >= rightValue);
		}
	}

	private Expression MakeStringGeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringGeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) >= 0);
		}
	}
	
	private Expression MakeWStringGeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringGeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) >= 0);
		}
	}


	private Expression MakeTimeOfDayGeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new TimeOfDayGeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue >= rightValue);
		}
	}

	private Expression MakeIntLeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue <= rightValue);
			}
			else if (leftValue == 0)
				return new IntGeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntLeqOperator(left, right, true);
		}
		return new IntLeqOperator(left, right);
	}

	private Expression MakeUIntLeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				return this.MakeConstant(leftValue <= rightValue);
			}
			else if (leftValue == 0)
				return new IntGeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntLeqOperator(left, right, true);
		}
		return new IntLeqOperator(left, right);
	}

	private Expression MakeRealLeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue <= rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatGeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatLeqOperator(left, right, true);
		}
		return new FloatLeqOperator(left, right);
	}

	private Expression MakeLRealLeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue <= rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealGeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealLeqOperator(left, right, true);
		}
		return new LRealLeqOperator(left, right);
	}

	private Expression MakeTimeLeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeLeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue <= rightValue);
		}
	}

	private Expression MakeDateTimeLeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeLeqOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue <= rightValue);
		}
	}

	private Expression MakeStringLeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringLeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) <= 0);
		}
	}

	private Expression MakeWStringLeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringLeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) <= 0);
		}
	}

	private Expression MakeTimeOfDayLeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new TimeOfDayLeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue <= rightValue);
		}
	}

	private Expression MakeGtrOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, ">", location);
					return this.MakeIntGtrOp(left, right);
				}
				else if (rightDataType.IsSignedIntType)
					return this.MakeIntGtrOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealGtrOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGtrOp(this.MakeInt2LReal(left), right);

			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, ">", location);
					return this.MakeUIntGtrOp(left, right);
				}
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntGtrOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealGtrOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGtrOp(this.MakeInt2LReal(left), right);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealGtrOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGtrOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealGtrOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGtrOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealGtrOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealGtrOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntGtrOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntGtrOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeGtrOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayGtrOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeGtrOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeGtrOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringGtrOp(left, right);
			else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringGtrOp(left, right);
			//
			// Error. Incompatible operand types of operator >
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " > ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeLesOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, "<", location);
					return this.MakeIntLesOp(left, right);
				}
				else if (rightDataType.IsSignedIntType)
					return this.MakeIntLesOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealLesOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLesOp(this.MakeInt2LReal(left), right);

			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, "<", location);
					return this.MakeUIntLesOp(left, right);
				}
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntLesOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealLesOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLesOp(this.MakeInt2LReal(left), right);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealLesOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLesOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealLesOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLesOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealLesOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealLesOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntLesOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntLesOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeLesOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayLesOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeLesOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeLesOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringLesOp(left, right);
			else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringLesOp(left, right);
			//
			// Error. Incompatible operand types of operator <
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " < ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeEqlOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntEqlOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealEqlOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealEqlOp(this.MakeInt2LReal(left), right);
				else if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, "=", location);
					return this.MakeIntEqlOp(left, right);
				}
			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
					return this.MakeIntEqlOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealEqlOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealEqlOp(this.MakeInt2LReal(left), right);
				else if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, "=", location);
					return this.MakeIntEqlOp(left, right);
				}
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealEqlOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealEqlOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealEqlOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealEqlOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealEqlOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealEqlOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntEqlOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntEqlOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeEqlOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayEqlOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeEqlOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeEqlOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringEqlOp(left, right);
			else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringEqlOp(left, right);
			//
			// Error. Incompatible operand types of operator =
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " = ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeNeqOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, "<>", location);
					return this.MakeIntNeqOp(left, right);
				}
				else if (rightDataType.IsSignedIntType)
					return this.MakeIntNeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealNeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealNeqOp(this.MakeInt2LReal(left), right);

			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, "<>", location);
					return this.MakeUIntNeqOp(left, right);
				}
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntNeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealNeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealNeqOp(this.MakeInt2LReal(left), right);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealNeqOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealNeqOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealNeqOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealNeqOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealNeqOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealNeqOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntNeqOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntNeqOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeNeqOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayNeqOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeNeqOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeNeqOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringNeqOp(left, right);
		    else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringNeqOp(left, right);
			//
			// Error. Incompatible operand types of operator <>
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " <> ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeGeqOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, ">=", location);
					return this.MakeIntGeqOp(left, right);
				}
				else if (rightDataType.IsSignedIntType)
					return this.MakeIntGeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealGeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGeqOp(this.MakeInt2LReal(left), right);

			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, "<>", location);
					return this.MakeUIntGeqOp(left, right);
				}
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntGeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealGeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGeqOp(this.MakeInt2LReal(left), right);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealGeqOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGeqOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealGeqOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGeqOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealGeqOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealGeqOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntGeqOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntGeqOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeGeqOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayGeqOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeGeqOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeGeqOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringGeqOp(left, right);
			else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringGeqOp(left, right);
			//
			// Error. Incompatible operand types of operator >=
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " >= ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeLeqOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, ">=", location);
					return this.MakeIntLeqOp(left, right);
				}
				else if (rightDataType.IsSignedIntType)
					return this.MakeIntLeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealLeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLeqOp(this.MakeInt2LReal(left), right);

			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, "<>", location);
					return this.MakeUIntLeqOp(left, right);
				}
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntLeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealLeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLeqOp(this.MakeInt2LReal(left), right);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealLeqOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLeqOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealLeqOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLeqOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealLeqOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealLeqOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntLeqOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntLeqOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeLeqOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayLeqOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeLeqOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeLeqOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringLeqOp(left, right);
			else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringLeqOp(left, right);
			//
			// Error. Incompatible operand types of operator <=
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " <= ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private ProgramOrganizationUnitCall MakePOUCall(string name, LexLocation location)
	{
		STLangSymbol symbol;
		if (! this.symbolTable.Lookup(name, out symbol, location))
		{
			STLangSymbol undefinedPOU;
			this.report.SemanticError(0, name, location);
			undefinedPOU = this.symbolTable.InstallUndefinedFunction(name, 10);
			return new STLangFunctionCall(undefinedPOU, location);
		}
		else if (symbol.IsFunction)
			return new STLangFunctionCall(symbol, location);
		else if (symbol.IsFunctionBlockInstance)
			return new STLangFunctionBlockCall(symbol, location);
		else
		{
			this.report.SemanticError(5, symbol.TypeName, name, location);
			return null;
		}
	}

	private ProgramOrganizationUnitCall MakePOUCall(string name, POUParameter argument, LexLocation location)
	{
		STLangSymbol symbol;
		if (! this.symbolTable.Lookup(name, out symbol, location))
		{
			STLangSymbol undefinedPOU;
			this.report.SemanticError(0, name, location);
			undefinedPOU = this.symbolTable.InstallUndefinedFunction(name, 10);
			return new STLangFunctionCall(undefinedPOU, argument, location);
		}
		else if (symbol.IsFunction)
		{
			if (argument.DataType == TypeNode.Bool && ! (symbol is SELFunctionSymbol))
			{
				if (argument.IsInputParameter && argument.RValue.IsCompoundExpression)
				{
					Expression input = new LoadBoolValueOperator(argument.RValue);
					LexLocation loc = argument.LexicalLocation;
					string inputName = argument.FormalName;
					argument = new InputParameter(inputName, input, loc);
				}
			}
			return new STLangFunctionCall(symbol, argument, location);
		}
		else if (symbol.IsFunctionBlockInstance)
		{
			FunctionBlockType dataType = symbol.DataType as FunctionBlockType;
			this.CheckFunctionBlockParameter(name, dataType, argument, location);
			if (argument.DataType == TypeNode.Bool && argument.RValue.IsCompoundExpression)
			{
				if (argument.IsInputParameter)
				{
					Expression input = new LoadBoolValueOperator(argument.RValue);
					LexLocation loc = argument.LexicalLocation;
					string inputName = argument.FormalName;
					argument = new InputParameter(inputName, input, loc);
				}
			}
			return new STLangFunctionBlockCall(symbol, argument, location);
		}
		else
		{
			this.report.SemanticError(5, symbol.TypeName, name, location);
			return null;
		}
	}

	private ProgramOrganizationUnitCall AddPOUParameter(ProgramOrganizationUnitCall pou, POUParameter argument)
	{
		if (pou == null)
			return null;
		else {
			if (pou.IsInputArgAssignment && ! argument.IsInputArgAssignment)
				this.report.SemanticError(185, argument.ToString(), argument.LexicalLocation);
			else if (! pou.IsInputArgAssignment && argument.IsInputArgAssignment)
				this.report.SemanticError(185,  argument.ToString(), argument.LexicalLocation);
			if (argument.DataType == TypeNode.Bool && argument.RValue.IsCompoundExpression)
			{
				if (argument.IsInputParameter)
				{
					Expression input = new LoadBoolValueOperator(argument.RValue);
					LexLocation loc = argument.LexicalLocation;
					string inputName = argument.FormalName;
					argument = new InputParameter(inputName, input, loc);
				}
			}
			if (pou.IsFunction)
			{
				pou.Add(argument);
				return pou;
			}
			else if (pou.IsFunctionBlock)
			{
				this.CheckFunctionBlockParameter(pou, argument);
				pou.Add(argument);
				return pou;
			}
		}
		throw new STLangCompilerError("AddPOUParameter(): Unknown type of POU.");
	}

	private ProgramOrganizationUnitCall MakePOUCall(ProgramOrganizationUnitCall pou, LexLocation location)
	{
		return pou;
	}

	private Expression MakeFunctionCall(ProgramOrganizationUnitCall pou)
	{
		if (pou == null)
			return Expression.Error;
		else if (pou.IsFunctionBlock)
		{
			// Error: Function block used as a function
			//
			this.report.SemanticError(135, pou.Name, pou.Location);
			return Expression.Error;
		}
		else {
			Expression functionCall = pou.MakeSyntaxTreeNode();
			if (! this.symbolTable.IsRecursiveCall(functionCall))
				return functionCall;
			else {
				// Error: Illegal recursive call
				//
				this.report.SemanticError(90, pou.Name, pou.Location);
				return Expression.Error;
			}
		}
	}

	private Statement MakeFunctionBlockCallStatement(ProgramOrganizationUnitCall pou)
	{
		if (pou == null)
			return Statement.Empty;
		else if (pou.IsFunction)
		{
			// Warning: Function call found where function block call was expected.
			//
			this.report.Warning(16, pou.Name, pou.Location);
			return Statement.Empty;
		}
		else
		{
			Expression expression = pou.MakeSyntaxTreeNode();
			return new FunctionBlockCallStatement(expression);
		}
	}

	private POUParameter MakeParameter(Expression argument, LexLocation location)
	{
		if (argument == null)
			return new InputParameter(Expression.Error, location);
		else if (argument is FunctionName)
		{
			this.report.SemanticError(148, argument.ToString(), location);
			return new InputParameter(Expression.Error, location);
		}
		return new InputParameter(argument, location);
	}

	private POUParameter MakeParameter(string formalParam, Tokens assignToken, Expression argument, LexLocation location, bool inverted = false)
	{
		if (argument == null)
			argument = Expression.Error;
		else if (argument is FunctionName)
			this.report.SemanticError(148, argument.ToString(), location);
		if (assignToken == Tokens.OUTPUT_ASSIGN)
			return new OutputParameter(formalParam, argument, inverted, location);
		else if (assignToken == Tokens.ASSIGN)
		{
			if (inverted)
				this.report.SyntaxError(184, formalParam, location);
			return new InputParameter(formalParam, argument, location);
		}
		throw new STLangCompilerError("MakeParameter(): Unkown assignment token.");
	}

	private void CheckFunctionBlockParameter(ProgramOrganizationUnitCall pou, POUParameter argument)
	{
		FunctionBlockType functionBlock;
		functionBlock = pou.Symbol.DataType as FunctionBlockType;
		this.CheckFunctionBlockParameter(pou.Name, functionBlock, argument, pou.Location);
	}

	private void CheckFunctionBlockParameter(string pouName, FunctionBlockType functionBlock, POUParameter argument, LexLocation location)
	{
		InstanceSymbol formal;
		string formalName = argument.FormalName;

		if (formalName.Length == 0)
			this.report.SemanticError(174, pouName, argument.LexicalLocation);
		else if (! functionBlock.LookUp(formalName, out formal))
			this.report.SemanticError(141, formalName, pouName, argument.LexicalLocation);
		else if (argument.RValue != null)
		{
			argument.Position = formal.Position;
			if (argument.IsOutputParameter)
			{
				Expression lValue;

				lValue = formal.MakeSyntaxTreeNode(argument.LexicalLocation);
				argument.LValue = lValue;
			}
			Expression actual = argument.RValue;
			TypeNode actualDataType = actual.DataType;
			LexLocation formalLoc = argument.LexicalLocation;
			switch (formal.VariableType)
			{
				case STVarType.VAR_INPUT:
				break;

				case STVarType.VAR_INOUT:
					//
					// Check that the actual argument is an l-value
					//
					if (! actual.IsLValue && actualDataType != TypeNode.Error)
						this.report.SemanticError(78, pouName, formalName, formalLoc);
					if (! argument.IsInputParameter)
						this.report.SemanticError(175, formalName, formalLoc);
					break;

				case STVarType.VAR_OUTPUT:
					if (! actual.IsLValue && actualDataType != TypeNode.Error)
						this.report.SemanticError(189, pouName, formalName, formalLoc);
					if (! argument.IsOutputParameter)
					{
						if (! actual.IsLValue)
							this.report.SemanticError(176, formalName, formalLoc);
						else
							this.report.SemanticError(173, actual.ToString(), formalName, formalLoc);
					}
					break;

				default:
					this.report.SemanticError(180, formalName, formalLoc);
					break;
			}
			TypeNode formalDataType = formal.DataType;
			float conversionCost = formalDataType.ConversionCost(actual);
			if (conversionCost > 0.0 && actualDataType != TypeNode.Error)
			{
				if (actual.IsConstant)
				{
					if (formalDataType == TypeNode.LReal)
					{
						if (actualDataType == TypeNode.Real || actualDataType.IsIntegerType)
						{
							double doubleValue;
							doubleValue = Convert.ToDouble(actual.Evaluate());
							actual = MakeConstant(doubleValue);
						}
						else {
							string typeName = formalDataType.Name;
							string constValue = actual.ToString();
							this.report.SemanticError(177, formalName, constValue, typeName, location);
							actual = Expression.Error;
						}
					}
					else if (formalDataType == TypeNode.Real)
					{
						if (actualDataType.IsIntegerType)
						{
							float floatValue;
							floatValue = Convert.ToSingle(actual.Evaluate());
							actual = MakeConstant(floatValue);
						}
						else {
							string typeName = formalDataType.Name;
							string constValue = actual.ToString();
							this.report.SemanticError(177, formalName, constValue, typeName, location);
							actual = Expression.Error;
						}
					}
					else if (formalDataType.IsIntegerType)
					{
						if (actualDataType.IsIntegerType)
						{
							if (actualDataType.Size > formalDataType.Size)
							{
								string typeName = formalDataType.Name;
								string constValue = actual.ToString();
								this.report.SemanticError(178, constValue, formalName, typeName, location);
							}
						}
						else {
							string typeName = formalDataType.Name;
							string constValue = actual.ToString();
							this.report.SemanticError(177, formalName, constValue, typeName, location);
							actual = Expression.Error;
						}
					}
					else if (formalDataType.IsBitStringType)
					{
						if (actualDataType.IsBitStringType)
						{
							if (actualDataType.Size > formalDataType.Size)
							{
								string typeName = formalDataType.Name;
								string constValue = actual.ToString();
								this.report.SemanticError(178, constValue, formalName, typeName, location);
							}
						}
						else if (actualDataType.IsIntegerType)
						{
							if (actualDataType.Size > formalDataType.Size)
							{
								string typeName = formalDataType.Name;
								string constValue = actual.ToString();
								this.report.SemanticError(178, constValue, formalName, typeName, location);
							}
							else {
								ulong value = Convert.ToUInt64(actual.Evaluate());
								actual = this.MakeConstant(value, formalDataType);
							}
						}
						else {
							string typeName = formalDataType.Name;
							string constValue = actual.ToString();
							this.report.SemanticError(177, formalName, constValue, typeName, location);
							actual = Expression.Error;
						}
					}
				}
				else if (formalDataType == TypeNode.LReal)
				{
					if (actualDataType.IsIntegerType)
						actual = this.MakeInt2LReal(actual);
					else if (actualDataType == TypeNode.Real)
						actual = this.MakeReal2LReal(actual);
					else if (this.ConversionOperatorExists(TypeNode.LReal, actualDataType))
					{
						actual = Expression.Error;
						this.report.SemanticError(64, actualDataType.Name, formalDataType.Name, location);
					}
					else {
						actual = Expression.Error;
						this.report.SemanticError(150, actualDataType.Name, formalDataType.Name, location);
					}
				}
				else if (formalDataType == TypeNode.Real)
				{
					if (actualDataType.IsIntegerType)
						actual = this.MakeInt2Real(actual);
					else if (this.ConversionOperatorExists(TypeNode.Real, actualDataType))
					{
						actual = Expression.Error;
						this.report.SemanticError(64, actualDataType.Name, formalDataType.Name, location);
					}
					else {
						actual = Expression.Error;
						this.report.SemanticError(150, actualDataType.Name, formalDataType.Name, location);
					}
				}
			}
		}
	}

	private void CheckVarTypeQualUsage(STVarType variableType, STVarQualifier qualifier, LexLocation loc1, LexLocation loc2)
	{
		this.variableType = variableType;
		this.variableQualifier = qualifier;

		// Kolla att kombinationen POU-typ + variabeltyp + attribut är giltig.

		switch (variableType)
		{
		case STVarType.VAR:
			break;

		case STVarType.VAR_INPUT:
			if (qualifier == STVarQualifier.CONSTANT)
				this.report.SemanticError(158, "VAR_INPUT", "CONSTANT", loc1);
			break;

		case STVarType.VAR_OUTPUT:
			if (qualifier == STVarQualifier.CONSTANT)
				this.report.SemanticError(158, "VAR_OUTPUT", "CONSTANT", loc1);
			break;

		case STVarType.VAR_INOUT:
			if (qualifier != STVarQualifier.NONE)
				this.report.SemanticError(158, "VAR_INOUT", variableType.ToString(), loc1);
			break;

		case STVarType.VAR_GLOBAL:
			this.report.SemanticError(156, "VAR_GLOBAL", loc1);
			break;

		case STVarType.VAR_CONFIG:
			if (qualifier != STVarQualifier.NONE)
				this.report.SemanticError(158, "VAR_ACCESS", variableType.ToString(), loc1);
			break;

		case STVarType.VAR_EXTERNAL:
			if (this.isFunctionDecl)
				this.report.SemanticError(156, "VAR_EXTERNAL", loc1);
			if (qualifier == STVarQualifier.RETAIN) 
				this.report.SemanticError(158, "VAR_EXTERNAL", "RETAIN", loc1);
			else if (qualifier == STVarQualifier.NON_RETAIN)
				this.report.SemanticError(158, "VAR_EXTERNAL", "NON_RETAIN", loc1);
			break;

		case STVarType.VAR_TEMP:
			if (this.isFunctionDecl)
				this.report.SemanticError(46, "VAR_TEMP", loc1);
			if (qualifier == STVarQualifier.RETAIN) 
				this.report.SemanticError(158, "VAR_TEMP", "RETAIN", loc1);
			else if (qualifier == STVarQualifier.NON_RETAIN)
				this.report.SemanticError(158, "VAR_TEMP", "NON_RETAIN", loc1);
			break;

		case STVarType.VAR_ACCESS:
			this.report.SemanticError(156, "VAR_ACCESS", loc1);
			if (qualifier != STVarQualifier.NONE)
				this.report.SemanticError(158, "VAR_ACCESS", variableType.ToString(), loc1);
			break;

		default:
			break;
		}
	}

	private void CheckDeclQualifierUsage(TypeNode dataType, STVarQualifier varQualifier, STDeclQualifier declQualifier, LexLocation location)
	{
		switch (declQualifier)
		{
		case STDeclQualifier.NONE:
			break;

		case STDeclQualifier.READ_ONLY:
		case STDeclQualifier.WRITE_ONLY:
			if (this.variableType != STVarType.VAR_ACCESS)
			{
				string varType = this.variableType.ToString();
				string edgeQual = declQualifier.ToString();
				this.report.SemanticError(158, varType, edgeQual, location);
			}
			break;

		case STDeclQualifier.F_EDGE:
		case STDeclQualifier.R_EDGE:
			if (this.isFunctionDecl)
				this.report.SemanticError(159, declQualifier.ToString(), location);
			if (dataType != TypeNode.Bool)
				this.report.SemanticError(160, declQualifier.ToString(), location);
			break;
		}
		if (dataType.IsFunctionBlockType && varQualifier == STVarQualifier.CONSTANT)
			this.report.SemanticError(179, dataType.Name, location);
	}

	private ProgramOrganizationUnitType ProgOrgType
	{
		get 
		{
			if (this.isFunctionDecl)
				return ProgramOrganizationUnitType.FUNCTION;
			else if (this.isFunctionBlockDecl)
				return ProgramOrganizationUnitType.FUNCTION_BLOCK;
			else
				return ProgramOrganizationUnitType.PROGRAM;
		}
	}

	private DeclarationStatement MakeFormalParameterDecl(STVarType varType, STVarQualifier varQual, List<VarDeclStatement> formalParDeclList)
	{
		return new IOParameterDeclaration(varType, varQual, formalParDeclList, this.ProgOrgType);
	}

	private DeclarationStatement MakeLocalVariableDecl(STVarType varType, STVarQualifier varQual, List<VarDeclStatement> localVarDeclList)
	{
		return new LocalVarDeclaration(localVarDeclList, varType, varQual, this.ProgOrgType);
	}

	private POUVarDeclarations MakeEmptyPOUVarDecl()
	{
		return new POUVarDeclarations();
	}

	private List<VarDeclStatement> MakeEmptyVarDecl()
	{
		return new List<VarDeclStatement>();
	}

	private List<VarDeclStatement> MakeVariableDeclList(VarDeclStatement varInitDecl)
	{
		List<VarDeclStatement> varInitDeclList = new List<VarDeclStatement>();
		if (varInitDecl != null)
			varInitDeclList.Add(varInitDecl);
		return varInitDeclList;
	}

	private List<VarDeclStatement> AddToVariableDeclList(List<VarDeclStatement> varInitDeclList, VarDeclStatement varInitDecl)
	{
		if (varInitDeclList == null)
			varInitDeclList = new List<VarDeclStatement>();
		if (varInitDecl != null)
			varInitDeclList.Add(varInitDecl);
		return varInitDeclList;
	}

	private POUVarDeclarations MakePOUVarDeclList(DeclarationStatement declaration)
	{
		POUVarDeclarations pouVarDeclarations = new POUVarDeclarations();
		if (declaration != null)
			pouVarDeclarations.Add(declaration);
		return pouVarDeclarations;
	}

	private POUVarDeclarations AddPOUVarDeclToList(POUVarDeclarations pouDeclList, DeclarationStatement declaration)
	{
		if (pouDeclList == null)
			pouDeclList = new POUVarDeclarations();
		if (declaration != null)
			pouDeclList.Add(declaration);
		return pouDeclList;
	}

	private void StoreArrayInitializer(ArrayInitializer arrayInit)
	{
		TypeNode elementType = arrayInit.BasicElementType;
		int alignment = (int)elementType.Alignment;
		byte[] bytes = arrayInit.GetBytes();
		int offset = ByteCodeGenerator.StoreByteArray(bytes, alignment);
		arrayInit.AbsoluteAddress = MakeIntConstant(offset);
	}

	private VarDeclStatement MakeVarDeclStatement(List<MemoryObject> variables, TypeNode dataType, STVarType varType, 
	                                    STDeclQualifier declQual, Expression initialValue, int elementCount = 1)
	{
		Expression declSize;
		if (varType == STVarType.VAR_INOUT)
		{
		    // Store offset of variable as a DINT
			//
			int byteCount = variables.Count*(int)TypeNode.DInt.Size;
			declSize = MakeIntConstant(byteCount);
			return new ElementaryVarDeclStatement(variables, dataType, declQual, initialValue, declSize);
		}
		else if (dataType.IsElementaryType)
		{
			int byteCount = variables.Count*(int)dataType.Size;
			declSize = MakeIntConstant(byteCount);
			return new ElementaryVarDeclStatement(variables, dataType, declQual, initialValue, declSize);
		}
		else if (dataType.IsTextType)
		{
            //
            // Store information about string buffer offset and size.
            //
			int stringType = dataType.IsStringType ? 0 : 1;
            foreach (MemoryObject variable in variables)
            {
                if (variable.Location is StringLocation)
                {
                    StringLocation stringLocation;

                    stringLocation = (StringLocation)variable.Location;
                    int bufferSize = (int)variable.DataType.Size;
                    int bufferOffset = stringLocation.BufferOffset;
					int index = stringLocation.Index;
					ByteCodeGenerator.StoreStringVariableData(bufferOffset, index, bufferSize, stringType);
                }
            }
			int byteCount = variables.Count*(int)dataType.Size;
			declSize = MakeIntConstant(byteCount);
			return new ElementaryVarDeclStatement(variables, dataType, declQual, initialValue, declSize);
		}
		else if (dataType.IsStructType)
		{
			VarDeclStatement memberInitStat;
			List<VarDeclStatement> memberInitCollection;
			int byteCount = variables.Count*(int)dataType.Size;
			FieldSymbol field = ((StructType)dataType.BaseType).FirstField;

			declSize = MakeIntConstant(byteCount);
			memberInitCollection = new List<VarDeclStatement>();
			if (initialValue is StructInitializer)
			{
				Expression initializer;
				List<MemoryObject> members;
				StructInitializer structInit = (StructInitializer)initialValue;
				while (field != null)
				{
					if (structInit.Contains(field.Name, out initializer))
					{
						members = this.CreateMemberList(variables, field.Name);
						memberInitStat = this.MakeVarDeclStatement(members, field.DataType, varType, declQual, initializer, elementCount);
						memberInitCollection.Add(memberInitStat);
					}
					field = field.Next;
				}
			}
			return new StructVarDeclStatement(variables, dataType, declQual, initialValue, declSize, memberInitCollection);
		}
		else if (dataType.IsFunctionBlockType)
		{
			if (initialValue is FunctionBlockInitializer)
			{
				int byteCount;
				InstanceSymbol member;
				Expression initializer;
				List<MemoryObject> members;
				VarDeclStatement memberDeclStat;
				List<VarDeclStatement> memberDeclStats;
				FunctionBlockInitializer functionBlockInit;

				byteCount = variables.Count*(int)dataType.Size;
				declSize = MakeIntConstant(byteCount);
				memberDeclStats = new List<VarDeclStatement>();
				functionBlockInit = (FunctionBlockInitializer)initialValue;
				member = ((FunctionBlockType)dataType.BaseType).FirstMember;
				while (member != null)
				{
					if (functionBlockInit.Contains(member.Name, out initializer))
					{
						members = this.CreateMemberList(variables, member.Name);
						memberDeclStat = this.MakeVarDeclStatement(members, member.DataType, varType, declQual, initializer, elementCount);
						memberDeclStats.Add(memberDeclStat);
					}
					member = member.Next;
				}
				return new FunctionBlockVarDeclStat(variables, dataType, declQual, initialValue, declSize, memberDeclStats);
			}
		}
		else if (dataType.IsArrayType)
		{
		    ArrayType array = (ArrayType)dataType;
            TypeNode elementType = array.BasicElementType;

			if (elementType.IsElementaryType || elementType.IsTextType)
            {
				if (initialValue is DefaultArrayInitializer)
				{
					int initValCase;
					if (initialValue.IsZero)
					{
						initValCase = 0;
						int byteCount = variables.Count*(int)dataType.Size;
						declSize = MakeIntConstant(byteCount);
					}
					else {
						initValCase = 1;
						uint size = elementType.Size;
						long elemCount = (dataType.Size / size)*variables.Count;
						declSize = MakeIntConstant(elemCount);
					}
					if (elementType.IsTextType)
					{
						int stringType = elementType.IsStringType ? 0 : 1;
						int bufferSize = (int)elementType.Size;
						int elemCount = (int)(dataType.Size / bufferSize);
						foreach (MemoryObject variable in variables)
						{
							if (variable.Location is StringLocation)
							{
								StringLocation stringLocation;

								stringLocation = (StringLocation)variable.Location;
								int bufferOffset = stringLocation.BufferOffset;
								int index = stringLocation.Index;
								ByteCodeGenerator.StoreStringVariableData(bufferOffset, index, bufferSize, stringType, elemCount);
							}
						}
					}
					return new ArrayVarDeclStatement(variables, dataType, declQual, initialValue, declSize, initValCase);
				}
				else if (initialValue is ArrayInitializer)
				{
					STVarQualifier varQual = this.variableQualifier;
					ArrayInitializer arrayInit = (ArrayInitializer)initialValue;
					if (elementType.IsTextType)
					{
						int stringType = elementType.IsStringType ? 0 : 1;
						int bufferSize = (int)elementType.Size;
						int elemCount = (int)(dataType.Size / bufferSize);
						foreach (MemoryObject variable in variables)
						{
							if (variable.Location is StringLocation)
							{
								StringLocation stringLocation;

								stringLocation = (StringLocation)variable.Location;
								int bufferOffset = stringLocation.BufferOffset;
								int index = stringLocation.Index;
								ByteCodeGenerator.StoreStringVariableData(bufferOffset, index, bufferSize, stringType, elemCount);
							}
						}
					}
					if (arrayInit.IsConstant)
					{
						this.StoreArrayInitializer(arrayInit);
						declSize = MakeIntConstant((long)dataType.Size);
						if (this.IsConstantVarDecl(varQual))
							return new ArrayVarDeclStatement(variables, dataType, declQual, arrayInit, declSize, 3);
						else
							return new ArrayVarDeclStatement(variables, dataType, declQual, arrayInit, declSize, 2);
					}
					else {
						int constCount = 0;
						IEnumerable<Expression> initializerList;

						initializerList = arrayInit.FlattenedInitializerList;
						foreach (Expression initValue in initializerList)
						{
							if (initValue.IsConstant)
								constCount++;
						}
						double constRatio = (double)constCount/initializerList.Count();
						if (constRatio < 0.7)
						{
							declSize = MakeIntConstant(initializerList.Count());
							if (this.IsConstantVarDecl(varQual))
								return new ArrayVarDeclStatement(variables, dataType, declQual, initialValue, declSize, 3, constRatio);
							else
								return new ArrayVarDeclStatement(variables, dataType, declQual, initialValue, declSize, 2, constRatio);
						}
						else {
							int i,offset;
							int baseIndex; 
							Expression defaultValue;
							ArrayInitializer newArrayInit;
							List<AssignmentStat> assignStatList;
							List<Expression> constInitList,nonConstInitList;

							constInitList = new List<Expression>();
							nonConstInitList = new List<Expression>();
							defaultValue = elementType.DefaultValue;
							declSize = MakeIntConstant((long)dataType.Size);
							foreach (Expression initValue in initializerList)
							{
								if (initValue.IsConstant)
									constInitList.Add(initValue);
								else {
									constInitList.Add(defaultValue);
									nonConstInitList.Add(initValue);
								}
							}
							assignStatList = new List<AssignmentStat>();
							newArrayInit = arrayInit.CreateInitList(constInitList);
							this.StoreArrayInitializer(newArrayInit);
							foreach (MemoryObject variable in variables)
							{
								i = 0;
								offset = 0;
								baseIndex = variable.Location.Index;
								foreach (Expression initValue in initializerList)
								{
									if (! initValue.IsConstant)
									{
										Expression lValue;
										MemoryLocation location;
										AssignmentStat assignStat;
                                        string name = variable + "[" + offset + "]";
										Expression rValue = nonConstInitList[i++];
										location = new ElementaryLocation(baseIndex + offset, elementType);
										lValue = new MemoryObject(name, location, elementType, variable.Symbol, 4);
										assignStat = new SimpleAssignmentStat(lValue, rValue);
										assignStatList.Add(assignStat);
									}
									offset++;
								}
							}
							if (this.IsConstantVarDecl(varQual))
								return new ArrayVarDeclStatement(variables, dataType, declQual, newArrayInit, declSize, 3, constRatio, assignStatList);
							else
								return new ArrayVarDeclStatement(variables, dataType, declQual, newArrayInit, declSize, 2, constRatio, assignStatList);
						}
					}
				}
			}
			else if (elementType.IsStructType)
			{
				VarDeclStatement memberInitStat;
				InitializerList flattenedInitList;
				StructType structure = (StructType)elementType.BaseType;
				FieldSymbol field = structure.FirstField;
				List<VarDeclStatement> memberInitCollection;
				Expression size = MakeIntConstant((long)dataType.Size);

				memberInitCollection = new List<VarDeclStatement>();
			    if (initialValue is ArrayOfStructInitializer)
				{
					List<MemoryObject> members;
					ArrayOfStructInitializer arrayOfStructInit;
					arrayOfStructInit = (ArrayOfStructInitializer)initialValue;
					elementCount = (int)(array.Size/elementType.Size)*elementCount;

					while (field != null)
					{
						members = this.CreateMemberList(variables, field); 
						flattenedInitList = arrayOfStructInit.GetFlattenedInitializerList(field.Name);
						memberInitStat = this.MakeVarDeclStatement(members, flattenedInitList.DataType, varType, declQual, flattenedInitList, elementCount);
						memberInitCollection.Add(memberInitStat);
						field = field.Next;
					}
				}
				return new ArrayOfStructVarDeclStatement(variables, dataType, declQual, initialValue, size, memberInitCollection);
			}
			else if (elementType.IsFunctionBlockType)
			{
			}
		}
		Expression zeroSize = MakeIntConstant((long)0);
		return new ElementaryVarDeclStatement(variables, dataType, declQual, initialValue, zeroSize);
	}

	private List<MemoryObject> CreateMemberList(List<MemoryObject> variables, FieldSymbol field)
	{
		InstanceSymbol symbol;
		List<MemoryObject> members = new List<MemoryObject>();

		foreach (MemoryObject variable in variables)
		{
			symbol = variable.Symbol;
			if (symbol.IsArrayInstance)
			{
                InstanceSymbol elementSymbol;
                ArrayInstanceSymbol arraySymbol;

				arraySymbol = (ArrayInstanceSymbol)symbol;
                elementSymbol = arraySymbol.ElementSymbol;
                if (elementSymbol.IsStructInstance)
                {
                    InstanceSymbol memberSymbol;
                    StructInstanceSymbol structure;

                    structure = (StructInstanceSymbol)elementSymbol;
                    if (structure.LookUp(field.Name, out memberSymbol))
					{
						MemoryObject member;

						member = (MemoryObject)memberSymbol.MakeSyntaxTreeNode();
                        members.Add(member);
					}
                }
			}
		}
		return members;
	}

	private List<MemoryObject> CreateMemberList(List<MemoryObject> variables, string member)
	{
		InstanceSymbol symbol;
		List<MemoryObject> members = new List<MemoryObject>();

		foreach (MemoryObject variable in variables)
		{
			symbol = variable.Symbol;
            if (symbol.IsCompoundInstanceSymbol)
            {
                InstanceSymbol memberSymbol;
                CompoundInstanceSymbol compoundSymbol;

                compoundSymbol = (CompoundInstanceSymbol)symbol;
                if (compoundSymbol.LookUp(member, out memberSymbol))
				{
					MemoryObject memberObject;

					memberObject = (MemoryObject)memberSymbol.MakeSyntaxTreeNode();
                    members.Add(memberObject);
				}
            }
		}
		return members;
	}

	private VarDeclStatement InstallLocalVars(List<string> identifiers, TypeNode dataType, STDeclQualifier declQual, LexLocation location)
	{
		if (identifiers == null)
			return null;
		else if (identifiers.Count == 0)
			return null;
		else {
			STVarType varType = this.variableType;
			Expression initialValue = dataType.DefaultValue;
			STVarQualifier varQual = this.variableQualifier;
			List<InstanceSymbol> symbols = new List<InstanceSymbol>();

			this.CheckDeclQualifierUsage(dataType, varQual, declQual, location);
			foreach (string name in identifiers)
			{
				InstanceSymbol symbol;
				symbol = this.rwMemoryManager.CreateSymbol(name, dataType, varType, varQual, declQual, initialValue, this.variablePosition);
				symbols.Add(symbol);
				this.variablePosition++;
			}
			this.symbolTable.InstallLocalVariables(symbols);
			if (this.IsConstantVarDecl(varQual))
            {
                // Error. Constant variables must be assigned a value in the declaration.
                this.report.SemanticError(9, location);
				// CONSTANT variables (with constant initializers) are initialized at compile time
                if (dataType.IsElementaryType)
                    return null;
            }
            MemoryObject variable;
            List<MemoryObject> variables = new List<MemoryObject>();

            foreach (InstanceSymbol symbol in symbols)
            {
                variable = (MemoryObject)symbol.MakeSyntaxTreeNode();
                variables.Add(variable);
            }
            return this.MakeVarDeclStatement(variables, dataType, varType, declQual, initialValue);
		}
	}

	private bool IsConstantVarDecl(STVarQualifier varQual)
	{
		return varQual == STVarQualifier.CONSTANT 
		    || varQual == STVarQualifier.CONSTANT_RETAIN;
	}

	private VarDeclStatement InstallLocalVars(List<string> identifiers, TypeNode dataType, STDeclQualifier declQual, Expression initialValue, LexLocation location)
	{
		this.Pop(); // Remove datatype saved on stack.
		if (identifiers == null)
			return null;
		else if (identifiers.Count == 0)
			return null;
		else {
			STVarType varType = this.variableType;
			STVarQualifier varQual = this.variableQualifier;
			List<InstanceSymbol> symbols = new List<InstanceSymbol>();

			this.CheckDeclQualifierUsage(dataType, varQual, declQual, location);
			foreach (string name in identifiers)
			{
				InstanceSymbol symbol;
				int pos = this.variablePosition++;
				symbol = this.rwMemoryManager.CreateSymbol(name, dataType, varType, varQual, declQual, initialValue, pos);
				symbols.Add(symbol);
			}
			this.symbolTable.InstallLocalVariables(symbols);
			if (this.IsConstantVarDecl(varQual) && initialValue.IsConstant && dataType.IsElementaryType)
				return null;  // Don't reserve memory for CONSTANT variables (with constant initializers) of elementary type.
			else {
				MemoryObject variable;
				List<MemoryObject> variables = new List<MemoryObject>();

				foreach (InstanceSymbol symbol in symbols)
				{
					variable = (MemoryObject)symbol.MakeSyntaxTreeNode();
					variables.Add(variable);
				}
				if (initialValue.IsLValue && !dataType.IsElementaryType)
				{
					MemoryObject memoryObject = (MemoryObject)initialValue;

					initialValue = memoryObject.InitialValue;
				}
				return this.MakeVarDeclStatement(variables, dataType, varType, declQual, initialValue);
			}
		}
	}

	private VarDeclStatement InstallSymbolicVariable(string name, DataTypeSpec dataTypeSpec, TokenDirectVar directVar, LexLocation loc)
	{
		if (! this.symbolTable.IsValidUserDefinedSymbol(name, loc))
			return null;
		else {
			InstanceSymbol symbol;
			TypeNode dataType = dataTypeSpec.DataType;
			STDeclQualifier declQual = dataTypeSpec.DeclQualifier;
			Expression initialValue = dataTypeSpec.InitialValue;
			this.symbolTable.InstallDirectVariable(name, dataType, this.variableType, this.variableQualifier,
			                                       dataTypeSpec.DeclQualifier, directVar.Size, directVar.Location, 
												   directVar.Address, out symbol);
			Expression size = MakeIntConstant((long)dataType.Size);
			List<MemoryObject> variables = new List<MemoryObject>();
			variables.Add((MemoryObject)symbol.MakeSyntaxTreeNode());
			return new ElementaryVarDeclStatement(variables, dataType, declQual, size, initialValue);
		}
	}

	private VarDeclStatement InstallDirectVariable(TokenDirectVar directVar, DataTypeSpec dataTypeSpec, LexLocation loc)
	{
		string name = directVar.ToString();
		if (! this.symbolTable.IsValidUserDefinedSymbol(name, loc))
			return null;
		else if (! this.isProgramDecl)
		{
			this.report.SemanticError(186, name, loc);
			return null;
		}
		else {
			InstanceSymbol symbol;
			TypeNode dataType = dataTypeSpec.DataType;
			STDeclQualifier declQual = dataTypeSpec.DeclQualifier;
			Expression initialValue = dataTypeSpec.InitialValue;
			this.symbolTable.InstallDirectVariable(name, dataType, this.variableType, this.variableQualifier,
			                                       dataTypeSpec.DeclQualifier, directVar.Size, directVar.Location, 
												   directVar.Address, out symbol);
			Expression size = MakeIntConstant((long)dataType.Size);
			List<MemoryObject> variables = new List<MemoryObject>();
			variables.Add((MemoryObject)symbol.MakeSyntaxTreeNode());
			return new ElementaryVarDeclStatement(variables, dataType, declQual, size, initialValue);
		}
	}

	private Expression CheckInitialValue(Expression initialValue, LexLocation location)
	{	
		TypeNode declDataType = this.attributeStack.Top;

		if (initialValue == null)
			return declDataType.DefaultValue;
		else if (declDataType == TypeNode.Error)
			return Expression.Error;
		else if (initialValue.DataType == TypeNode.Error)
			return declDataType.DefaultValue;
		else if (initialValue is FunctionName)
		{
			this.report.SemanticError(148, initialValue.ToString(), location);
			return declDataType.DefaultValue;
		}
		else {
			TypeNode initValDataType = initialValue.DataType;

			if (initValDataType == TypeNode.Bool && initialValue.IsCompoundExpression)
				initialValue = new LoadBoolValueOperator(initialValue);
			if (declDataType == initValDataType)
			{
				if (declDataType.IsOrdinalType && declDataType.IsSubrangeType)
				{
					if (initialValue.IsConstant)
					{
						if (declDataType.IsSignedIntType)
						{
							long numericValue = Convert.ToInt64(initialValue.Evaluate());
							if (! declDataType.IsInRange(numericValue))
							{
								string strValue = initialValue.ToString();
								string typeName = declDataType.Name;
								this.report.SemanticError(171, strValue, typeName, location);
							}
						}
						else {
							ulong numericValue = Convert.ToUInt64(initialValue.Evaluate());
							if (! declDataType.IsInRange(numericValue))
							{
								string strValue = initialValue.ToString();
								string typeName = declDataType.Name;
								this.report.SemanticError(171, strValue, typeName, location);
							}
						}
					}
					else if (initValDataType.IsSubrangeType)
					{
						SubRange initSubrange = initValDataType.GetSubrange();
						SubRange declSubrange = declDataType.GetSubrange();
						if (declSubrange.AreDisjoint(initSubrange))
							this.report.SemanticError(11, declDataType.Name, initValDataType.Name, location);
					}
				}
				return initialValue;
			}
			else if (declDataType == TypeNode.LReal && initValDataType.IsIntegerType)
			{
				if (! initialValue.IsConstant)
					return new Int2LRealOperator(initialValue);
				else {
					double doubleValue = Convert.ToDouble(initialValue.Evaluate());
					return MakeConstant(doubleValue);
				}
			}
			else if (declDataType == TypeNode.LReal && initValDataType == TypeNode.Real)
			{
				if (! initialValue.IsConstant)
					return new Real2LRealOperator(initialValue);
				else {
					double doubleValue = Convert.ToDouble(initialValue.Evaluate());
					return MakeConstant(doubleValue);
				}
			}
			else if (declDataType == TypeNode.Real && initValDataType == TypeNode.LReal)
			{
				if (! initialValue.IsConstant)
					this.report.SemanticError(27, declDataType.Name, initValDataType.Name, location);
				else {
					float floatValue = Convert.ToSingle(initialValue.Evaluate());
					return MakeConstant(floatValue);
				}
			}
			else if (declDataType == TypeNode.Real && initValDataType.IsIntegerType)
			{
				if (! initialValue.IsConstant)
					return new Int2RealOperator(initialValue);
				else {
					float singleValue = Convert.ToSingle(initialValue.Evaluate());
					return MakeConstant(singleValue);
				}
			}
			else if (declDataType.IsIntegerType && initValDataType.IsIntegerType)
			{
				if (declDataType.IsUnsignedIntType && initValDataType.IsSignedIntType
				 || declDataType.IsSignedIntType && initValDataType.IsUnsignedIntType
				 || declDataType.Size < initValDataType.Size)
				{
					this.report.SemanticError(64, initValDataType.Name, declDataType.Name, location);
					initialValue = declDataType.DefaultValue;
				}
			}
			else if (declDataType.IsBitStringType && initValDataType.IsIntegerType)
			{
				if (! initialValue.IsConstant)
					this.report.SemanticError(64, initValDataType.Name, declDataType.Name, location);
				else {
					ulong value = Convert.ToUInt64(initialValue.Evaluate());
					if (declDataType.Size < initValDataType.Size)
						this.report.SemanticError(64, initValDataType.Name, declDataType.Name, location);
					return this.MakeConstant(value, declDataType);
				}
			}
			else if (declDataType.IsBitStringType && initValDataType.IsBitStringType)
			{
				if (declDataType.Size < initValDataType.Size)
					this.report.SemanticError(64, initValDataType.Name, declDataType.Name, location);
			}
			else if (declDataType.IsStringType && initValDataType.IsStringType)
			{
				if (declDataType.Size < initValDataType.Size)
					this.report.SemanticError(35, initialValue.ToString(), location);
			}
			else
				this.report.SemanticError(27, declDataType.Name, initValDataType.Name, location);
			return initialValue;
		}
	}

	private List<object> MakeExpressionList(Expression expression, LexLocation location)
	{
		if (expression == null)
			return new List<object>{Expression.Error};
		else if (expression is FunctionName)
		{
			this.report.SemanticError(148, expression.ToString(), location);
			return new List<object>{Expression.Error};
		}
		else
			return new List<object>{expression};
	}

	private List<object> MakeExpressionList(List<object> exprList, Expression expression, LexLocation location)
	{
		if (expression == null)
			exprList.Add(Expression.Error);
		else if (expression is FunctionName)
		{
			this.report.SemanticError(148, expression.ToString(), location);
			exprList.Add(Expression.Error);
		}
		else
			exprList.Add(expression);
		return exprList;
	}

	private Expression MakeSymbolicVariable(Expression expression)
	{
		if (expression == null || expression == Expression.Error)
			return Expression.Error;
		else if (! expression.IsLValue)
			return expression;
		else if (expression.DataType.IsArrayType)
		{
			ArrayType array = (ArrayType)expression.DataType;
			TypeNode elementType = array.BasicElementType;

			if (elementType.IsElementaryType || elementType.IsTextType)
			{
                Expression absoluteAddress;
				Expression size = MakeIntConstant(array.Size);
                MemoryObject lValue = (MemoryObject)expression;
				absoluteAddress = this.rwMemoryManager.GetAbsoluteAddress(lValue.Symbol);
				if (lValue.Offset != null)
				{
					Expression factor = MakeIntConstant(elementType.Size);
					Expression offset = this.MakeIntMulOp(lValue.Offset, factor);
                    absoluteAddress = this.MakeIntAddOp(offset, absoluteAddress);
				}
				lValue.Location.AbsoluteAddress = absoluteAddress;
				lValue.Location.Size = size;
			}
		}
		return expression;
	}

	private Expression MakeSimpleVariable(string identifier, LexLocation location)
	{
		STLangSymbol symbol;
		if (this.isSubrangeDecl)
		{
			if (! this.symbolTable.Lookup(identifier, this.subrangeDataType, out symbol, location))
			{
				this.report.SemanticError(0, identifier, location);
				this.symbolTable.InstallUndeclaredVariable(identifier, out symbol);
			}
		}
		else if (! this.symbolTable.Lookup(identifier, out symbol, location))
		{
			this.report.SemanticError(0, identifier, location);
			this.symbolTable.InstallUndeclaredVariable(identifier, out symbol);
		}
		return symbol.MakeSyntaxTreeNode(location);
	}

	private Expression MakeSimpleVariable(Expression expression, string memberName, LexLocation location)
	{
		if (expression == null)
			return Expression.Error;
		else if (expression == Expression.Error)
			return Expression.Error;
		else if (! expression.IsLValue)
		{
			this.report.SemanticError(3, expression.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode dataType = expression.DataType;
			if (dataType.IsStructType)
			{
				MemoryObject memoryObject = (MemoryObject)expression;
				InstanceSymbol symbol = memoryObject.Symbol;
				if (symbol.IsArrayInstance)
                {
					ArrayInstanceSymbol arrayInstance;

					arrayInstance = (ArrayInstanceSymbol)symbol;
					symbol = arrayInstance.ElementSymbol;
					if (! symbol.IsStructInstance)
					{
						string msg = "MakeSimpleVariable() failed.";
						msg += " StructInstanceSymbol expected: " + symbol.Name;
						throw new STLangCompilerError(msg);
					}
                }
				InstanceSymbol member;
				StructInstanceSymbol structure = (StructInstanceSymbol)symbol;
				if (! structure.LookUp(memberName, out member))
				{
					this.report.SemanticError(4, memberName, dataType.Name, location);
					return Expression.Error;
				}
				else
				{
					int length = memoryObject.Length + 2;
					Expression offset = memoryObject.Offset;
					string stringValue = expression + "." + memberName;
					return new MemoryObject(member, offset, stringValue, length);
				}
			}
			else if (dataType == TypeNode.Error)
				return Expression.Error;
			else if (dataType.IsFunctionBlockType)
			{
				MemoryObject memoryObject = (MemoryObject)expression;
				InstanceSymbol symbol = memoryObject.Symbol;
				if (! symbol.IsFunctionBlockInstance)
				{
					string msg = "MakeSimpleVariable() failed.";
					msg += " FunctionBlockInstanceSymbol expected: " + symbol.Name;
					throw new STLangCompilerError(msg);
				}
				else
				{
					InstanceSymbol member;
					FunctionBlockInstanceSymbol functionBlock;

					functionBlock = (FunctionBlockInstanceSymbol)symbol;
					if (! functionBlock.LookUp(memberName, out member))
					{
						this.report.SemanticError(136, memberName, dataType.Name, location);
						return Expression.Error;
					}
					else if (member.IsLocalVariable)
					{
						string varType = member.VariableType.ToString();
						this.report.SemanticError(137, varType, memberName, dataType.Name, location);
						return Expression.Error;
					}
					else {
						int length = memoryObject.Length + 2;
						Expression offset = memoryObject.Offset;
						string stringValue = expression + "." + memberName;
						return new MemoryObject(member, offset, stringValue, length);
					}
				}
			}
		}
		this.report.SemanticError(3, expression.ToString(), location);
        return Expression.Error;
	}

	private void CheckArrayIndex(Expression index, ArrayType array, string varName, LexLocation location)
	{
		long indexValue = Convert.ToInt64(index.Evaluate());
		if (indexValue < array.LowerBound)
			this.report.SemanticError(123, indexValue, varName, array.LowerBound, location);
		else if (indexValue > array.UpperBound)
			this.report.SemanticError(124, indexValue, varName, array.UpperBound, location);
	}

	private Expression MakeIndexedVariable(IndexedVariable variable)
	{
		if (variable == null)
			return Expression.Error;
		else {
			string name = variable.Name + "]";
			int length = variable.Length + 1; 
			MemoryLocation location = variable.Offset;
			InstanceSymbol symbol = variable.Symbol;
			int constantPart = variable.ConstantPart;
			Expression variablePart = variable.VariablePart;
			TypeNode dataType = variable.DataType;
			this.isIndexExpr = false;
			if (variablePart == null)
				throw new STLangCompilerError("MakeIndexedVariable() failed: Offset is null.");
			else if (dataType.IsElementaryType || dataType.IsTextType)
			{
				if (variablePart.IsConstant)
				{
					int varPart = Convert.ToInt32(variablePart.Evaluate());
					int offset = varPart - constantPart;
					if (! symbol.IsConstant)
					{
						int index = location.Index + offset;
						location = new ElementaryLocation(index, dataType);
						return new MemoryObject(name, location, dataType, symbol, length);
					}
					else if (symbol.InitialValue is ArrayInitializer)
					{
						// Constant array with constant array index. Get array element
						// at position 'offset' in the array initializer.
						//
						ArrayInitializer arrayInit;
						arrayInit = (ArrayInitializer)symbol.InitialValue;
						Expression rValue = arrayInit.GetElementAt(offset);
						return new MemoryObject(rValue, name, symbol, length);
					}
					else if (symbol.InitialValue is ArrayOfStructInitializer)
					{
						ArrayOfStructInitializer arrayInit;
						arrayInit = (ArrayOfStructInitializer)symbol.InitialValue;
						Expression rValue = arrayInit.GetElementAt(offset);
						return new MemoryObject(rValue, name, symbol, length);
					}
					throw new STLangCompilerError("ArrayInitializer type expected.");
				}
				else if (constantPart == 0)
					return new MemoryObject(name, location, variablePart, dataType, symbol, length);
				else 
				{
				    if (variablePart is IntAddOperator)
					{
						Expression rightOperand;
						rightOperand = ((IntAddOperator)variablePart).RightOperand;
						if (rightOperand.IsConstant)
							constantPart = Convert.ToInt32(rightOperand.Evaluate()) - constantPart;
					}
					Expression constant = MakeIntConstant(constantPart);
					Expression offset = new IntSubOperator(variablePart, constant, TypeNode.DInt);
					return new MemoryObject(name, location, offset, dataType, symbol, length);
				}
			}
			else if (dataType.IsArrayType)
			{
				ArrayType array = (ArrayType)dataType;
				long elementWidth = (long)array.Size/array.BasicElementType.Size;
				Expression elemWidth = MakeIntConstant(elementWidth);
				Expression offset = this.MakeIntMulOp(variablePart, elemWidth);
				if (constantPart != 0)
				{
					long value = constantPart*elementWidth;
					Expression constant = MakeIntConstant(value);
					offset = this.MakeIntSubOp(offset, constant);
				}
				Expression size = MakeIntConstant((long)array.Size);
				if (!offset.IsConstant)
					return new MemoryObject(name, location, offset, dataType, symbol, length);
				else
				{
					int value = Convert.ToInt32(offset.Evaluate());
					location = location.AddOffset(value);
					return new MemoryObject(name, location, dataType, symbol, length);
				}
			}
			else if (dataType.IsStructType)
			{
			}
			return Expression.Error;
		}
	}

	private IndexedVariable MakeIndexedVariable(IndexedVariable variable, Expression index, LexLocation loc1, LexLocation loc2)
	{
		if (variable == null)
			return null;
		else if (index == null)
			return variable;
		else if (! index.DataType.IsIntegerType && index.DataType != TypeNode.Error)
			this.report.SemanticError(30, index.ToString(), loc2);
		if (! variable.DataType.IsArrayType)
		{
			string parameter = variable.Name + "," + index + "]";
			this.report.SemanticError(167, parameter, loc1);
			return variable;
		}
		else {
			Expression variablePart;
			InstanceSymbol symbol = variable.Symbol;
			MemoryLocation offset = variable.Offset;
			int constantPart = variable.ConstantPart;
			string name = variable.Name + "," + index;
			int length = variable.Length + index.Length;
			ArrayType array = (ArrayType)variable.DataType;
			if (index.IsConstant)
				this.CheckArrayIndex(index, array, variable.Symbol.Name, loc2);
			else if (! index.IsLinear()  || !index.ConstantForLoopBounds(this.forLoopDataList))
				index = this.MakeRangeCheckOperator(index, array);
			else {
				int lowerBound = array.LowerBound;
				int upperBound = array.UpperBound;
				int powerSetSize = 1 << this.forLoopDataList.Count;
				for (int word = 0; word < powerSetSize; word++)
				{
					int indexValue = index.Evaluate(word, this.forLoopDataList);
					if (indexValue < lowerBound || indexValue > upperBound)
					{
						index = this.MakeRangeCheckOperator(index, array);
						break;
					}
				}
			}
			Expression factor = MakeIntConstant(array.Range);
			variablePart = this.MakeIntMulOp(variable.VariablePart, factor);
			variablePart = this.MakeIntAddOp(variablePart, index);
			constantPart = array.Range*constantPart + array.LowerBound;
			TypeNode elemType = array.ElementType;
			return new IndexedVariable(offset, elemType, variablePart, constantPart, symbol, name, length);
		}
	}

	private Expression MakeRangeCheckOperator(Expression index, ArrayType array)
	{
		Expression lowerBound = MakeIntConstant(array.LowerBound);
		Expression upperBound = MakeIntConstant(array.UpperBound);
		return new RangeCheckOperator(index, lowerBound, upperBound);
	}

	private IndexedVariable MakeIndexedVariable(Expression expression, Expression index, LexLocation loc1, LexLocation loc2)
	{
		if (expression == null || index == null)
			return null;
		else if (! index.DataType.IsIntegerType && index.DataType != TypeNode.Error)
			this.report.SemanticError(30, index.ToString(), loc2);
		if (expression.DataType == TypeNode.Error)
			return null;
		if (! expression.IsLValue)
		{
			this.report.SemanticError(2, expression.ToString(), loc1);
			return null;
		}
		else if (! expression.DataType.IsArrayType)
		{
			this.report.SemanticError(2, expression.ToString(), loc1);
			return null;
		}
		else {
			MemoryObject lValue = (MemoryObject)expression;
			MemoryLocation location = lValue.Location;
			InstanceSymbol symbol = lValue.Symbol;
			Expression offset = lValue.Offset;
			ArrayType array = (ArrayType)expression.DataType;
			TypeNode elemType = array.ElementType;
			int constPart = array.LowerBound;
			int length = index.Length + 2;
			string name = lValue + "[" + index;
			if (index.IsConstant)
				this.CheckArrayIndex(index, array, symbol.Name, loc2);
			else if (! index.IsLinear() || !index.ConstantForLoopBounds(this.forLoopDataList))
				index = this.MakeRangeCheckOperator(index, array);
			else {
				int lowerBound = array.LowerBound;
				int upperBound = array.UpperBound;
				int powerSetSize = 1 << this.forLoopDataList.Count;
				for (int word = 0; word < powerSetSize; word++)
				{
					int indexValue = index.Evaluate(word, this.forLoopDataList);
					if (indexValue < lowerBound || indexValue > upperBound)
					{
						index = this.MakeRangeCheckOperator(index, array);
						break;
					}
				}
			}
			if (offset == null)
				return new IndexedVariable(location, elemType, index, constPart, symbol, name, length);
			else if (offset is IntSubOperator)
			{
				BinaryOperator binaryOp = (BinaryOperator)offset;
				Expression variablePart = binaryOp.LeftOperand;
				Expression factor = MakeIntConstant(array.Range);
				object constantValue = binaryOp.RightOperand.Evaluate();
				int constantPart = Convert.ToInt32(constantValue);
				variablePart = this.MakeIntMulOp(variablePart, factor);
				variablePart = this.MakeIntAddOp(variablePart, index);
				constantPart = array.Range*constantPart + array.LowerBound;
				return new IndexedVariable(location, elemType, variablePart, constantPart, symbol, name, length);
			}
			return null;
		}
	}

	private Expression MakeDirectVariable(TokenDirectVar directVar, LexLocation location)
	{
		STLangSymbol symbol;
		string name = directVar.ToString();
		if (! this.symbolTable.Lookup(name, out symbol, location))
		{
			this.report.SemanticError(129, name, location);
			this.symbolTable.InstallUndeclaredDirectVariable(directVar, out symbol);
		}
		return symbol.MakeSyntaxTreeNode(location);
	}

	private List<CaseLabel> MakeCaseLabelList(CaseLabel caseLabel, LexLocation location)
	{
		List<CaseLabel> caseLabelList = new List<CaseLabel>();
		return this.AddCaseLabelToList(caseLabelList, caseLabel, location);
	}

	private CaseElement MakeCaseElement(List<CaseLabel> constList, StatementList statList)
	{
		this.PopTop();
		CaseElement caseElem = new CaseElement();
		if (constList == null)
			constList = new List<CaseLabel>();
		caseElem.LabelList = constList;
		caseElem.StatementList = statList;
		return caseElem;
	}

	private CaseElement MakeDefaultCaseElement(StatementList statList)
	{
		this.PopTop();
		CaseElement defaultCaseElem = new CaseElement();
		defaultCaseElem.StatementList = statList;
		defaultCaseElem.LabelList = null; // Empty list
		return defaultCaseElem;
	}

	private List<CaseElement> MakeCaseElementList(object caseElement)
	{
		List<CaseElement> caseElemList = new List<CaseElement>();
		if (caseElement != null)
			caseElemList.Add((CaseElement)caseElement);
		return caseElemList;
	}

	private List<CaseElement> AddCaseElementToList(List<CaseElement> caseElemList, object caseElem, LexLocation location)
	{
		if (caseElemList == null || caseElem == null)
			return caseElemList;
		else if (! (caseElem is CaseElement))
			throw new STLangCompilerError("Type of parameter caseElem must be CaseElement");
		else {
			CaseElement caseElement = (CaseElement)caseElem;
			if (caseElement.LabelList != null)
				caseElemList.Add(caseElement);
			else {
				// caseElement is a default statment. Make sure that there isn't another 
				// default statement in the list.

				CaseElement defaultStat;
				defaultStat = caseElemList.Find(caseEl => caseEl.LabelList == null);
				if (defaultStat == null)
					caseElemList.Add(caseElement);
				else
					this.report.SemanticError(146, location);
			}
			return caseElemList;
		}
	}

	private List<CaseLabel> AddCaseLabelToList(List<CaseLabel> caseLabelList, CaseLabel caseLabel, LexLocation loc)
	{
		if (caseLabel == null)
			return caseLabelList;
		else if (caseLabel is NumericLabel)
		{
			NumericLabel numericLabel = (NumericLabel)caseLabel;
			foreach (CaseLabel thisCaseLabel in this.caseLabelList)
			{
				if (! thisCaseLabel.AreDisjoint(numericLabel))
				{
					int errorCode = thisCaseLabel is NumericLabel ? 33 : 53;
					this.report.SemanticError(errorCode, numericLabel.ToString(), thisCaseLabel.ToString(), loc);
					return caseLabelList;
				}
			}
			caseLabelList.Add(caseLabel);
			this.caseLabelList.Add(caseLabel);
			return caseLabelList;
		}
		else 
		{
			SubrangeLabel subRangeLabel = (SubrangeLabel)caseLabel;
			foreach (CaseLabel thisCaseLabel in this.caseLabelList)
			{
				if (! thisCaseLabel.AreDisjoint(subRangeLabel))
				{
					int errorCode = thisCaseLabel is NumericLabel ? 53 : 52;
					this.report.SemanticError(errorCode, thisCaseLabel.ToString(), subRangeLabel.ToString(), loc);
					return caseLabelList;
				}
			}
			caseLabelList.Add(caseLabel);
			this.caseLabelList.Add(caseLabel);
			return caseLabelList;
		}
	}

	private Expression CheckIfBoolCondition(string statement, Expression expression, LexLocation location)
	{
		if (expression == null)
			return Expression.Error;
		else if (expression.DataType == TypeNode.Error)
			return Expression.Error;
		else if (expression is FunctionName)
		{
			this.report.SemanticError(148, expression.ToString(), location);
			return Expression.Error;
		}
		else if (expression.DataType == TypeNode.Bool)
			return expression;
		else {
			this.report.SemanticError(34, statement, location);
			return Expression.Error;
		}
	}

	private Statement MakeWhileStatement(Expression expression, StatementList statementList, LexLocation location)
	{
		this.PopTop();
		this.loopNestingDepth--;
		if (expression == null || statementList == null)
			return Statement.Empty;
		else {
			if (expression.IsConstant)
			{
				bool conditonIsTrue = Convert.ToBoolean(expression.Evaluate());
				if (conditonIsTrue && !statementList.ContainsExit)
					this.report.SemanticError(92, location);
			}
			return new WhileStatement(expression.InvertRelation(), statementList);
		}
	}

	private Statement MakeRepeatStatement(StatementList statementList = null, Expression expression = null, LexLocation location = null)
	{
		this.PopTop();
		this.loopNestingDepth--;
		if (statementList == null || expression == null)
			return Statement.Empty;
		else {
			if (expression.IsConstant)
			{
				bool conditonIsFalse = !Convert.ToBoolean(expression.Evaluate());
				if (conditonIsFalse && !statementList.ContainsExit)
					this.report.SemanticError(93, location);
			}
			return new RepeatStatement(statementList, expression.InvertRelation());
		}
	}

	private List<object> MakeElseIfStatement(Expression expression, StatementList statementList)
	{
		this.PopTop();
		ElseIfStatement elseIfStat;
		elseIfStat = new ElseIfStatement(expression.InvertRelation(), statementList);
		return new List<object>{ elseIfStat };
	}

	private Statement MakeIfStatement(Expression condition, StatementList thenStat, List<object> objList, StatementList elseStat)
	{
		if (objList == null)
			return new IfStatement(condition.InvertRelation(), thenStat, elseStat);
		else {
			List<ElseIfStatement> elseIfStatList;
			elseIfStatList = objList.Cast<ElseIfStatement>().ToList();
			return new IfStatement(condition.InvertRelation(), thenStat, elseStat, elseIfStatList);
		}
	}

	private List<object> AddElseIfStatementToList(List<object> elseIfList, Expression expr, StatementList statList)
	{
		if (statList == null)
			return elseIfList;
		else {
			ElseIfStatement elseIfStat;
			elseIfStat = new ElseIfStatement(expr.InvertRelation(), statList);
			elseIfList.Add(elseIfStat);
			return elseIfList;
		}
	}

	private void InstallFunctionProtoType(string name, TypeNode resultDataType, POUVarDeclarations varDecls, LexLocation loc)
	{
		this.symbolTable.InstallFunctionProtoType(name, resultDataType, varDecls, loc);
	}

	private void InstallFunctionBlockProtoType(string name, POUVarDeclarations pouVarDecls, LexLocation loc)
	{
		uint byteCount;
		FunctionBlockType dataType;
		List<InstanceSymbol> members;
		List<InstanceSymbol> instanceSymbols;

		string typeID = "{" + name + "}";
        instanceSymbols = pouVarDecls.InputParameters.ToList();
        members = instanceSymbols.Cast<InstanceSymbol>().ToList();
		byteCount = (uint)this.rwMemoryManager.RWDataSegmentSize;
        Expression size = MakeIntConstant((long)byteCount);
		pouVarDecls.Size = size;
		dataType = new FunctionBlockType(name, members, byteCount, size, typeID);
		this.symbolTable.InstallFunctionBlockProtoType(name, dataType, pouVarDecls, loc);
	}

	private ExitStatement MakeExitStatement(LexLocation location)
	{
		if (this.loopNestingDepth == 0)
			this.report.SemanticError(21, location);
		return new ExitStatement();
	}

	private ReturnStatement MakeReturnStatement(LexLocation location)
	{
		if (this.isFunctionDecl)
			this.CheckFunctionValueIsDefined(location);
		return new ReturnStatement();
	}

	private ReturnStatement MakeReturnStatement2(LexLocation location)
	{
		this.report.SyntaxError(47, location);
		return new ReturnStatement();
	}

	private void PushForLoopData(Expression expression, ForLoopData forLoopData)
	{
		if (expression != null && forLoopData != null)
		{
			Predicate<ForLoopData> searchCond;
			MemoryObject memoryObj = (MemoryObject)expression;
			searchCond = forLoop => forLoop.ControlVariable.Symbol == memoryObj.Symbol;
			if (this.forLoopDataList.Find(searchCond) == null)
			{
				memoryObj.Symbol.IsForLoopCtrlVar = true;
				forLoopData.ControlVariable = memoryObj;
				this.forLoopDataList.Add(forLoopData);
			}
		}
	}

	private MemoryObject GenerateTemporary(Expression expr)
    {
        return this.rwMemoryManager.GenerateTemporary(expr);
    }

    private MemoryObject GenerateTemporary(TypeNode dataType)
    {
        return this.rwMemoryManager.GenerateTemporary(dataType);
    }

	private Statement MakeForLoopStatement(Expression controlVar, ForLoopData forLoop, StatementList statList)
	{
		this.PopTop();
		this.loopNestingDepth--;
		this.PopForLoopVariables();
		if (controlVar == null || forLoop == null)
			return Statement.Empty;
		else {
			Expression initValue = forLoop.InitialValue;
			Expression stopValue = forLoop.StopValue;
			Expression increment = forLoop.Increment;

			if (initValue == null || stopValue == null || increment == null)
				return Statement.Empty;
			else {
				Expression condition;
				bool executeLoopOnce = false;

				if (increment.IsConstant)
				{
					if (stopValue.IsCompoundExpression)
					{
						MemoryObject temporary = this.GenerateTemporary(controlVar);
						int incr = Convert.ToInt32(increment.Evaluate());
						if (incr > 0)
							condition = new IntLeqOperator(controlVar, temporary);
						else 
							condition = new IntGeqOperator(controlVar, temporary);
						return new ForStatement((MemoryObject)controlVar, initValue, stopValue, temporary, condition, increment, statList);
					}
					else {
						int incrValue = Convert.ToInt32(increment.Evaluate());
						if (incrValue > 0)
							condition = new IntLeqOperator(controlVar, stopValue);
						else 
							condition = new IntGeqOperator(controlVar, stopValue);
						if (initValue.IsConstant && stopValue.IsConstant)
						{
							int initVal = Convert.ToInt32(initValue.Evaluate());
							int stopVal = Convert.ToInt32(stopValue.Evaluate());
							if (incrValue > 0)
								executeLoopOnce = initVal <= stopVal;
							else 
								executeLoopOnce = initVal >= stopVal;
						}
					}
				}
				else if (initValue.IsConstant && stopValue.IsConstant)
				{
					int initVal = Convert.ToInt32(initValue.Evaluate());
					int stopVal = Convert.ToInt32(stopValue.Evaluate());
					if (initVal <= stopVal)
					{
						condition = new IntLeqOperator(controlVar, stopValue);
						executeLoopOnce = initVal <= stopVal;
					}
					else {
						condition = new IntGeqOperator(controlVar, stopValue);
						executeLoopOnce = initVal >= stopVal;
					}
				}
				else if (! stopValue.IsCompoundExpression)
					condition = new IntLeqOperator(controlVar, stopValue);
				else {
					MemoryObject temporary;
					temporary = this.GenerateTemporary(controlVar);
					condition = new IntLeqOperator(controlVar, temporary);
					return new ForStatement((MemoryObject)controlVar, initValue, stopValue, temporary, condition, increment, statList);
				} 
				return new ForStatement((MemoryObject)controlVar, initValue, condition, increment, statList, executeLoopOnce);
			}
		}
	}

	private Statement MakeCaseStatement(Expression controlExpr, List<CaseElement> caseElemList, LexLocation location)
	{
		this.PopCaseLabelList();
		if (caseElemList.Count == 0)
		{
			this.report.Warning(26, location);
			return Statement.Empty;
		}
		else {
			CaseElement defaultStatement;
			
			defaultStatement = caseElemList.Find(caseElem => caseElem.LabelList == null);
			if (defaultStatement == null)
				return new CaseStatement(controlExpr, caseElemList);
			else {
				caseElemList.Remove(defaultStatement);
				if (caseElemList.Count == 0)
					this.report.Warning(27, location);
				return new CaseStatement(controlExpr, caseElemList, defaultStatement);
			}
		}
	}

	private ForLoopData MakeForLoopData(Expression initialValue, Expression stopValue, Expression increment, LexLocation loc1 = null, LexLocation loc2 = null, LexLocation loc3 = null)
	{
		ForLoopData forLoopData = new ForLoopData();
		if (initialValue == null)
			initialValue = MakeIntConstant((long)0);
		else if (initialValue is FunctionName)
		{
			this.report.SemanticError(148, initialValue.ToString(), loc1);
			initialValue = MakeIntConstant((long)0);
		}
		if (stopValue == null)
			stopValue = Expression.Error;
		else if (stopValue is FunctionName)
		{
			this.report.SemanticError(148, stopValue.ToString(), loc2);
			stopValue = Expression.Error;
		}
		if (increment == null)
			increment = MakeIntConstant((long)1);
		else if (increment is FunctionName)
		{
			this.report.SemanticError(148, increment.ToString(), loc3);
			increment = MakeIntConstant((long)1);
		}
		forLoopData.InitialValue = initialValue;
		forLoopData.StopValue = stopValue;
		forLoopData.Increment = increment;
		this.forLoopVarKind = 0x0;
		this.loopNestingDepth++;
		return forLoopData;
	}

	private Expression SaveControlVariable(Expression expr, LexLocation location)
	{
		if (expr == null)
			return Expression.Error;
		else if (expr is FunctionName)
		{
			this.report.SemanticError(148, expr.ToString(), location);
			return Expression.Error;
		}
		else if (! expr.IsLValue)
		{
			// Error: expr is not an L-Value
			this.report.SemanticError(54, expr.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode dataType = expr.DataType;
			MemoryObject variable = (MemoryObject)expr;
			InstanceSymbol varSymbol = variable.Symbol;
			if (variable.IsConstant)
				this.report.SemanticError(8, expr.ToString(), location);
			if ((dataType.IsSignedIntType || dataType == TypeNode.Error) && variable.IsSimpleVariable)
				this.RegisterForLoopVariable(varSymbol, ForLoopVariableType.CONTROL_VARIABLE, location);
			else {
				if (! variable.IsSimpleVariable)
					this.report.SemanticError(49, varSymbol.Name, location); // Control variable can't be an element of an array or struct
				if (! dataType.IsSignedIntType && dataType != TypeNode.Error)
					this.report.SemanticError(132, varSymbol.Name, location); // Control variable must be of a signed integer type
			}
			return expr;
		}
	}

	private void CheckIfForLoopVar(Expression expr, LexLocation location)
	{
		if (expr == null)
			return;
		else if (expr is MemoryObject && this.forLoopVarKind != 0)
		{
			ForLoopVariableType loopVarKind;
			MemoryObject memObject = (MemoryObject)expr;

			if (this.forLoopVarKind == 0x1)
				loopVarKind = ForLoopVariableType.CONTROL_VARIABLE;
			else if (this.forLoopVarKind == 0x2)
				loopVarKind = ForLoopVariableType.START_VARIABLE;
			else if (this.forLoopVarKind == 0x4)
				loopVarKind = ForLoopVariableType.STOP_VARIABLE;
			else if (this.forLoopVarKind == 0x8)
				loopVarKind = ForLoopVariableType.INCR_VARIABLE;
			else
				loopVarKind = ForLoopVariableType.NONE;
			this.RegisterForLoopVariable(memObject.Symbol, loopVarKind, location);
		}
	}

	private bool ConversionOperatorExists(TypeNode fromType, TypeNode toType)
	{
		if (fromType == TypeNode.Error || toType == TypeNode.Error)
			return false;
		else if (!fromType.IsElementaryType || !toType.IsElementaryType)
			return false;
		else if (fromType.IsSubrangeType || toType.IsSubrangeType)
			return true;
		else {
			STLangSymbol symbol;
			string conversionOp;

			conversionOp = string.Format("{0}_TO_{1}", fromType.Name, toType.Name);
			return this.symbolTable.Lookup(conversionOp, out symbol, null);
		}
	}

	private Statement MakeAssignmentStatement(STLangSymbol lSymbol, STLangSymbol rSymbol, Expression lIndex = null, Expression rIndex = null)
	{
		TypeNode dataType = lSymbol.DataType;
		if (dataType.IsStructType)
		{
			if (! lSymbol.IsStructInstance || ! rSymbol.IsStructInstance)
				throw new STLangCompilerError(Resources.MAKEASSGNSTAT1);
			else {
				Statement assignmentStat;
				CompoundAssignmentStat compoundAssignStat;		
				StructInstanceSymbol lStruct = (StructInstanceSymbol)lSymbol;
				StructInstanceSymbol rStruct = (StructInstanceSymbol)rSymbol;
				InstanceSymbol lMember = lStruct.FirstMember;
				InstanceSymbol rMember = rStruct.FirstMember;

				compoundAssignStat = new CompoundAssignmentStat();
				while (lMember != null && rMember != null)
				{
					assignmentStat = this.MakeAssignmentStatement(lMember, rMember, lIndex, rIndex);
					compoundAssignStat.Add(assignmentStat);
					lMember = lMember.Next;
					rMember = rMember.Next;
				}
				return compoundAssignStat;
			}
		}
		else if (dataType.IsArrayType)
		{
			if (! lSymbol.IsArrayInstance || ! rSymbol.IsArrayInstance)
				throw new STLangCompilerError(Resources.MAKEASSGNSTAT2);
			else {
				ArrayType array = (ArrayType)dataType;
				TypeNode elementType = array.BasicElementType;

				if (elementType.IsStructType || elementType.IsArrayType)
				{
					ArrayInstanceSymbol lArray = (ArrayInstanceSymbol)lSymbol;
					ArrayInstanceSymbol rArray = (ArrayInstanceSymbol)rSymbol;
					STLangSymbol lElement = lArray.ElementSymbol;
					STLangSymbol rElement = rArray.ElementSymbol;
					return this.MakeAssignmentStatement(lElement, rElement, lIndex, rIndex);
				}
				else {
					long sizeOfDataType = dataType.Size;
					Expression size = MakeIntConstant(sizeOfDataType);
					this.rwMemoryManager.SetAbsoluteAddress(lSymbol);
					this.rwMemoryManager.SetAbsoluteAddress(rSymbol);
					Expression lValue = lSymbol.MakeSyntaxTreeNode();
					Expression rValue = rSymbol.MakeSyntaxTreeNode();
					((MemoryObject)lValue).Location.Size = size;
					((MemoryObject)rValue).Location.Size = size;
					return new SimpleAssignmentStat(lValue, rValue);
				}
			}
		}
		else if (dataType.IsElementaryType || dataType.IsTextType)
		{
	        // Obs! Om man allokerar mer minne för att spara undan värdet av ett 
		    // deluttryck efter ett anrop av SetAbsoluteAddress() kan absolutad- 
            // ressen bli fel. Man borde egentligen spara undan lSymbol och rSymbol
            // i en lista för att senare fylla i absolutadressen.

			int elementCount = lSymbol.Location.ElementCount;
			Expression lValue = lSymbol.MakeSyntaxTreeNode();
			Expression rValue = rSymbol.MakeSyntaxTreeNode();
			if (elementCount > 1)
			{ 
				// Array assignment

				long sizeOfDataType = lSymbol.DataType.Size * elementCount;
				Expression size = MakeIntConstant(sizeOfDataType);
				this.rwMemoryManager.SetAbsoluteAddress(lSymbol);
				this.rwMemoryManager.SetAbsoluteAddress(rSymbol);
				((MemoryObject)lValue).Location.Size = size;
				((MemoryObject)rValue).Location.Size = size;
			}
			return new SimpleAssignmentStat(lValue, rValue);
		}
		return Statement.Empty;
	}

	private Statement MakeAssignmentStatement(Expression lExpression, Expression rValue, LexLocation location)
	{
		if (lExpression == null || rValue == null)
			return Statement.Empty;
		else if (lExpression == Expression.Error)
			return Statement.Empty;
		else if (rValue is FunctionName)
		{
			this.report.SemanticError(148, rValue.ToString(), location);
			return Statement.Empty;
		}
		else if (lExpression is FunctionName)
		{
			TypeNode rValueDataType = rValue.DataType;
			TypeNode resultType = lExpression.DataType;
			if (rValue.DataType == TypeNode.Bool && rValue.IsCompoundExpression)
				rValue = new LoadBoolValueOperator(rValue);
			if (! this.symbolTable.IsCurrentFunction(lExpression))
			{
				this.report.SemanticError(149, lExpression.ToString(), location);
				return Statement.Empty;
			}
			else if (resultType == TypeNode.Error || rValueDataType == TypeNode.Error)
				return new FunctionResultStatement(Expression.Error);
			else if (resultType == rValueDataType)
				return new FunctionResultStatement(rValue);
			else if (resultType.IsIntegerType && rValueDataType.IsIntegerType)
			{
				if (rValueDataType.Size <= resultType.Size)
					return new FunctionResultStatement(rValue);
			}
			else if (resultType.IsBitStringType)
			{
				if (rValueDataType.IsBitStringType)
				{
					if (rValueDataType.Size <= resultType.Size)
						return new FunctionResultStatement(rValue);
				}
				else if (rValueDataType.IsIntegerType)
				{
					if (rValue.IsConstant && rValueDataType.Size <= resultType.Size)
						return new FunctionResultStatement(rValue);
				}
			}
			else if (resultType == TypeNode.Real)
			{
				if (rValueDataType.IsIntegerType)
				{
					if (! rValue.IsConstant)
						rValue = this.MakeInt2Real(rValue); // Insert conversion operator
					else {
						// Convert constant value from integer to float
						float floatValue = Convert.ToSingle(rValue.Evaluate());
						rValue = MakeConstant(floatValue);
					}
					return new FunctionResultStatement(rValue);
				}
			}
			else if (resultType == TypeNode.LReal)
			{
				if (rValueDataType.IsIntegerType)
				{
					if (! rValue.IsConstant)
						rValue = new Int2LRealOperator(rValue); // Insert conversion operator
					else {
						// Convert constant value from integer to double
						double doubleValue = Convert.ToDouble(rValue.Evaluate());
						rValue = MakeConstant(doubleValue);
					}
					return new FunctionResultStatement(rValue);
				}
				else if (rValueDataType == TypeNode.Real)
				{
					if (! rValue.IsConstant)
						rValue = new Real2LRealOperator(rValue);
					else {
						double doubleValue = Convert.ToDouble(rValue.Evaluate());
						rValue = MakeConstant(doubleValue);
					}
					return new FunctionResultStatement(rValue);
				}
			}
			if (this.ConversionOperatorExists(rValueDataType, resultType))
				this.report.SemanticError(64, rValueDataType.Name, resultType.Name, location);
			else
				this.report.SemanticError(150, rValueDataType.Name, resultType.Name, location);
			return Statement.Empty;
		}
		else if (! lExpression.IsLValue)
		{
			this.report.SemanticError(54, lExpression.ToString(), location);
			return Statement.Empty;
		}
		else {
			TypeNode rValueDataType = rValue.DataType;
			TypeNode lValueDataType = lExpression.DataType;
			MemoryObject lmemObject = (MemoryObject)lExpression;
			InstanceSymbol symbol = lmemObject.Symbol;
			foreach (Hashtable forLoopVars in this.forLoopVarTable)
			{
				if (forLoopVars.Contains(symbol))
				{
					ForLoopVariableType forLoopVarType;
					forLoopVarType = (ForLoopVariableType)forLoopVars[symbol];
					if ((forLoopVarType & ForLoopVariableType.CONTROL_VARIABLE) != 0)
						this.report.SemanticError(125, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.START_VARIABLE) != 0)
						this.report.SemanticError(126, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.STOP_VARIABLE) != 0)
						this.report.SemanticError(127, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.INCR_VARIABLE) != 0)
						this.report.Warning(15, symbol.Name, location);
				}
			}
			if (rValue.DataType == TypeNode.Bool && rValue.IsCompoundExpression)
				rValue = new LoadBoolValueOperator(rValue);
			if (lExpression.IsConstant)
			{
				if (lmemObject.IsSimpleVariable)
					this.report.SemanticError(169, lExpression.ToString(), location);
				else
					this.report.SemanticError(170, lExpression.ToString(), location);
			}
			else if (lExpression.IsConstantLValue)
			{
				if (lmemObject.IsSimpleVariable)
					this.report.SemanticError(168, lExpression.ToString(), location);
				else
					this.report.SemanticError(170, lExpression.ToString(), location);
			}
			if (lValueDataType == rValueDataType)
			{
				if (rValueDataType.IsStructType)
				{
					MemoryObject rmemObject = (MemoryObject)rValue;
					STLangSymbol lSymbol = lmemObject.Symbol;
					STLangSymbol rSymbol = rmemObject.Symbol;
					return this.MakeAssignmentStatement(lSymbol, rSymbol);
				}
     			else if (rValueDataType.IsArrayType)
				{
					MemoryObject rmemObject = (MemoryObject)rValue;
					STLangSymbol lSymbol = lmemObject.Symbol;
					STLangSymbol rSymbol = rmemObject.Symbol;
					Expression lIndex = lmemObject.Offset;
					Expression rIndex = rmemObject.Offset;
					return this.MakeAssignmentStatement(lSymbol, rSymbol, lIndex, rIndex);
				}
				else if (lValueDataType.IsOrdinalType && lValueDataType.IsSubrangeType)
				{
					if (rValue.IsConstant)
					{
						if (lValueDataType.IsSignedIntType)
						{
							long numericValue = Convert.ToInt64(rValue.Evaluate());
							if (! lValueDataType.IsInRange(numericValue))
							{
								string strValue = rValue.ToString();
								string typeName = lValueDataType.Name;
								this.report.SemanticError(171, strValue, typeName, location);
							}
						}
						else {
							ulong numericValue = Convert.ToUInt64(rValue.Evaluate());
							if (! lValueDataType.IsInRange(numericValue))
							{
								string strValue = rValue.ToString();
								string typeName = lValueDataType.Name;
								this.report.SemanticError(171, strValue, typeName, location);
							}
						}
					}
					else if (rValueDataType.IsSubrangeType)
					{
						SubRange rValueSubrange = rValueDataType.GetSubrange();
						SubRange lValueSubrange = lValueDataType.GetSubrange();
						if (lValueSubrange.AreDisjoint(rValueSubrange))
						{
							string lValName = lValueDataType.Name;
							string rValName = rValueDataType.Name;
							this.report.SemanticError(11, lValName, rValName, location);
						}
					}
				}
				return new SimpleAssignmentStat(lExpression, rValue);
			}
			else if (lValueDataType == TypeNode.Error || rValueDataType == TypeNode.Error)
				return new SimpleAssignmentStat(lExpression, rValue);
			else if (lValueDataType.IsIntegerType && rValueDataType.IsIntegerType)
			{
				if (rValueDataType.Size <= lValueDataType.Size)
					return new SimpleAssignmentStat(lExpression, rValue);
			}
			else if (lValueDataType.IsBitStringType)
			{
				if (rValueDataType.IsBitStringType)
				{
					if (rValueDataType.Size <= lValueDataType.Size)
						return new SimpleAssignmentStat(lExpression, rValue);
				}
				else if (rValueDataType.IsIntegerType)
				{
					if (rValue.IsConstant && rValueDataType.Size <= lValueDataType.Size)
						return new SimpleAssignmentStat(lExpression, rValue);
				}
			}
			else if (lValueDataType == TypeNode.Real)
			{
				if (rValueDataType.IsIntegerType)
				{
					if (! rValue.IsConstant)
						rValue = this.MakeInt2Real(rValue); // Insert conversion operator
					else {
						// Convert constant value from integer to float
						float floatValue = Convert.ToSingle(rValue.Evaluate());
						rValue = MakeConstant(floatValue);
					}
					return new SimpleAssignmentStat(lExpression, rValue);
				}
			}
			else if (lValueDataType == TypeNode.LReal)
			{
				if (rValueDataType.IsIntegerType)
				{
					if (! rValue.IsConstant)
						rValue = new Int2LRealOperator(rValue); // Insert conversion operator
					else {
						// Convert constant value from integer to double
						double doubleValue = Convert.ToDouble(rValue.Evaluate());
						rValue = MakeConstant(doubleValue);
					}
					return new SimpleAssignmentStat(lExpression, rValue);
				}
				else if (rValueDataType == TypeNode.Real)
				{
					if (! rValue.IsConstant)
						rValue = new Real2LRealOperator(rValue);
					else {
						double doubleValue = Convert.ToDouble(rValue.Evaluate());
						rValue = MakeConstant(doubleValue);
					}
					return new SimpleAssignmentStat(lExpression, rValue);
				}
			}
			else if (lValueDataType.IsStringType && rValueDataType.IsStringType)
			{
				if (lValueDataType.Size >= rValueDataType.Size)
					return new SimpleAssignmentStat(lExpression, rValue);
				else {
					this.report.SemanticError(188, rValue.ToString(), lExpression.ToString(), location);
					return Statement.Empty;
				}
			}
			else if (lValueDataType.IsWStringType && rValueDataType.IsWStringType)
			{
				if (lValueDataType.Size >= rValueDataType.Size)
					return new SimpleAssignmentStat(lExpression, rValue);
				else {
					this.report.SemanticError(188, rValue.ToString(), lExpression.ToString(), location);
					return Statement.Empty;
				}
			}
			if (this.ConversionOperatorExists(rValueDataType, lValueDataType))
				this.report.SemanticError(64, rValueDataType.Name, lValueDataType.Name, location);
			else
				this.report.SemanticError(150, rValueDataType.Name, lValueDataType.Name, location);
			return Statement.Empty;
		}
	}

	private StatementList MakeStatementList(Statement statement)
	{
		StatementList statementList = new StatementList();
		if (statement != null && statement != Statement.Empty)
		{
			statementList.Add(statement);
			this.CopyValue(statement.IsFunctionValueDefined);
		}
		return statementList;
	}

	private StatementList AddToStatementList(StatementList statementList, Statement statement, LexLocation location)
	{
		if (statementList != null && statement != null)
		{
			if (statement == Statement.Empty)
				return statementList;
			else if (statementList.Count > 0 && statementList.Last.ControlFlowTerminates)
				this.report.Warning(2, location);
			else {
				statementList.Add(statement);
				this.CopyValue(statement.IsFunctionValueDefined);
			}
		}
		return statementList;
	}

	private StatementList MakeCaseStatList(Statement statement)
	{
		StatementList statementList = new StatementList();
		if (statement != null && statement != Statement.Empty)
		{
			statementList.Add(statement);
			this.CopyValue(statement.IsFunctionValueDefined);
		}
		this.CheckForEndOfCaseStatList();
		return statementList;
	}

	private StatementList AddToCaseStatList(StatementList statementList, Statement statement, LexLocation location)
	{
		if (statementList != null && statement != null)
		{
			if (statement == Statement.Empty)
				return statementList;
			else if (statementList.Count > 0 && statementList.ControlFlowTerminates)
				this.report.Warning(2, location);
			else {
				statementList.Add(statement);
				this.CopyValue(statement.IsFunctionValueDefined);
			}
		}
		this.CheckForEndOfCaseStatList();
		return statementList;
	}

	private void CheckForEndOfCaseStatList()
	{
		STLangScanner scanner = (STLangScanner)this.Scanner;
		Tokens token = scanner.GetNextToken();
		switch (token)
		{
		case Tokens.IF:
		case Tokens.ELSE:
		case Tokens.WHILE:
		case Tokens.FOR:
		case Tokens.REPEAT:
		case Tokens.CASE:
		case Tokens.EXIT:
		case Tokens.END_CASE:
			// Control flow statement. 
			scanner.DoPushBack(false); 
		    break;

        case Tokens.TRUE:           
		case Tokens.FALSE:        
		case Tokens.INT_LIT:      
		case Tokens.REAL_LIT:     
		case Tokens.TOD_LIT:      
		case Tokens.TIME_LIT:     
		case Tokens.DATE_LIT:     
		case Tokens.DT_LIT:        
		case Tokens.STRING_LIT:        
		case Tokens.WSTRING_LIT:     
		case Tokens.TYPED_INT:       
		case Tokens.TYPED_REAL:   
		case Tokens.TYPED_ENUM:
		    // Constant ==> End of statement.
			scanner.DoPushBack(true);
			break;

		case Tokens.IDENT:
			token = scanner.GetNextToken();
			if (token == Tokens.ASSIGN)
				scanner.DoPushBack(false);
			else if (token == Tokens.DOTDOT || (char)token == ',' || (char)token == ':')
				scanner.DoPushBack(true);
			else if ((char)token != '(')
				scanner.DoPushBack(false);
			else {
				// Determine whether it is a function call or function block call
				STLangSymbol symbol;
				string ident = scanner.GetBufferedValue(0).Ident;

				if (! this.symbolTable.Lookup(ident, out symbol, null))
					scanner.DoPushBack(false);
				else if (symbol.IsFunctionBlock)
					scanner.DoPushBack(false); // Statement
				else
					scanner.DoPushBack(true);  // Expression
			}
			break;

		default:
			scanner.DoPushBack(true);
			break;
        }
	}

	private void PushSymbolTable(int declarationType = -1)
	{
		if (declarationType == 0)
			this.isFunctionDecl = true;
		else if (declarationType == 1)
			this.isFunctionBlockDecl = true;
		else if (declarationType == 2)
			this.isProgramDecl = true;
		this.symbolTable.Push();
	}

	private void PopSymbolTable()
	{
		this.symbolTable.Pop();
	}

	private void StoreInputOutputData(POUVarDeclarations pouDeclarations)
	{
		IEnumerable<InstanceSymbol> inputs = pouDeclarations.InputParameters;
		IEnumerable<InstanceSymbol> outputs = pouDeclarations.OutputParameters;
		IEnumerable<InstanceSymbol> retainedVars = pouDeclarations.RetainedVariables;

		foreach (InstanceSymbol input in inputs)
			ByteCodeGenerator.StoreInputParameter(input.Name, input.Position);
		foreach (InstanceSymbol output in outputs)
			ByteCodeGenerator.StoreOutputParameter(output.Name, output.Location.Index);
		foreach (InstanceSymbol retainedVar in retainedVars)
			ByteCodeGenerator.StoreRetainedVariable(retainedVar.Name, retainedVar.Location.Index);
		ByteCodeGenerator.StoreIOParameterCount();
	}

	// void GenerateInitInputs(POUVarDeclarations pouDeclarations)
	//
	// Generates code that initializes input parameters (VAR_INPUT).
	//
	private void GenerateInitInputs(POUVarDeclarations pouDeclarations)
	{
		Expression inputParam;
		IEnumerable<InstanceSymbol> inputs;

		inputs = pouDeclarations.InputParameters.Reverse();
		foreach (InstanceSymbol input in inputs)
		{
			inputParam = input.MakeSyntaxTreeNode(null);
			inputParam.GenerateStore();
		}
	}

	// void GenerateInitLocalVars(POUVarDeclarations pouDeclarations)
	//
	// Generates code that initializes local variables (VAR, VAR_TEMP (and VAR_OUTPUT in functions).
	//
	private void GenerateInitLocalVars(POUVarDeclarations pouDeclaration, bool isFunction)
    {
		IEnumerable<DeclarationStatement> localVariables;
		if (isFunction)
		{
			localVariables = pouDeclaration.LocalVariables;
			foreach (DeclarationStatement localVariable in localVariables)
			{
				localVariable.GenerateCode();
			}
		}
		else {
		}
	}

	private void GenerateStatementList(StatementList statementList)
	{
		if (statementList == null)
			throw new STLangCompilerError(Resources.GENFCNBODY);
		else
			statementList.GenerateCode();
	}

    string GetBaseName(string sourceFileName)
    {
        char[] separators = new char[] { '.' };
        string[] result = sourceFileName.Split(separators);
        if (result.Length > 0)
            return result[0];
        else
            return "";
    }

    private void GenerateObjectCode(string path, string sourceFile)
    {
		string executableFile;
		POUVarDeclarations varDeclarations;
		RWMemoryLayoutManager rwMemoryManager;
		ROMemoryLayoutManager roMemoryManager;
		IEnumerable<ProgramOrganizationUnitSymbol> pouSymbols;

		roMemoryManager = new ROMemoryLayoutManager();
		GenericConstant.ConstMemoryManager = roMemoryManager;
		pouSymbols = this.symbolTable.ProgramOrganizationUnits;
		executableFile = this.GetBaseName(sourceFile) + ".xstl";
		foreach (ProgramOrganizationUnitSymbol pouSymbol in pouSymbols)
		{
			foreach (ProgramOrganizationUnit pou in pouSymbol.Definitions)
			{
				varDeclarations = pou.VarDeclarations;
				rwMemoryManager = pou.RWMemoryLayout;
				constantTable = pou.ConstantTable;
				this.StoreInputOutputData(varDeclarations);
				this.GenerateInitInputs(varDeclarations);
                this.GenerateInitLocalVars(varDeclarations, pouSymbol.IsFunction);
                this.GenerateStatementList(pou.Body);
				ByteCodeGenerator.StorePOUName(pou.Name);
				ByteCodeGenerator.StoreRWDataSegmentInfo(rwMemoryManager);
				ByteCodeGenerator.StoreConstantTable(constantTable);
				ByteCodeGenerator.StoreRODataSegmentInfo(roMemoryManager);
				ByteCodeGenerator.OptimizeByteCode();
				ByteCodeGenerator.CreateExecutable(path, executableFile);
				roMemoryManager.Reset();
			}
		}
    }

	internal STLangPOUObject GenerateObjectCode(bool overWrite)
    {
		STLangPOUObject pouObject;
		POUVarDeclarations varDeclarations;
		RWMemoryLayoutManager rwMemoryManager;
		ROMemoryLayoutManager roMemoryManager;
		IEnumerable<ProgramOrganizationUnitSymbol> pouSymbolList;
		List<STLangPOUObject> pouObjectList = new List<STLangPOUObject>();

		roMemoryManager = new ROMemoryLayoutManager();
		GenericConstant.ConstMemoryManager = roMemoryManager;
		pouSymbolList = this.symbolTable.ProgramOrganizationUnits;
		foreach (ProgramOrganizationUnitSymbol pouSymbol in pouSymbolList)
		{
			foreach (ProgramOrganizationUnit pou in pouSymbol.Definitions)
			{
				rwMemoryManager = pou.RWMemoryLayout;
				varDeclarations = pou.VarDeclarations;
				constantTable = pou.ConstantTable;
				this.StoreInputOutputData(varDeclarations);
				this.GenerateInitInputs(varDeclarations);
                this.GenerateInitLocalVars(varDeclarations, pouSymbol.IsFunction);
                this.GenerateStatementList(pou.Body);
				ByteCodeGenerator.StorePOUName(pou.Name);
				ByteCodeGenerator.StoreRWDataSegmentInfo(rwMemoryManager);
				ByteCodeGenerator.StoreConstantTable(constantTable);
				ByteCodeGenerator.StoreRODataSegmentInfo(roMemoryManager);
				ByteCodeGenerator.OptimizeByteCode();
				pouObject = ByteCodeGenerator.CreateExecutable(pou.Name, overWrite);
				pouObjectList.Add(pouObject);
				roMemoryManager.Reset();
			}
		}
		return pouObjectList[0];
    }

	public bool Parse(string path, string sourceFile)
	{
		this.ReInitializeParser();
		bool result = this.Parse();
		if (!result || this.Errors > 0)
			return false;
		else {
			this.GenerateObjectCode(path, sourceFile);
			return true;
		}
	}
}
}
