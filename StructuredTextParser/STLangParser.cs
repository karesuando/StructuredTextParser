// This code was generated by the Gardens Point Parser Generator
// Copyright (c) Wayne Kelly, John Gough, QUT 2005-2014
// (see accompanying GPPGcopyright.rtf)

// GPPG version 1.5.2
// Machine:  DESKTOP-N9PK5LB
// DateTime: 2022-06-13 08:03:10
// UserName: cyber
// Input file <stlang.y - 2022-06-13 08:03:04>

// options: no-lines gplex

using System;
using System.Collections.Generic;
using System.CodeDom.Compiler;
using System.Globalization;
using System.Text;
using QUT.Gppg;
using System.Linq;
using System.Collections;
using STLang.Symbols;
using STLang.Scanner;
using STLang.Subranges;
using STLang.DataTypes;
using STLang.Statements;
using STLang.Extensions;
using STLang.Expressions;
using STLang.SymbolTable;
using STLang.ErrorManager;
using STLang.MemoryLayout;
using STLang.ParserUtility;
using STLang.VMInstructions;
using STLang.ConstantTokens;
using STLang.AttributeStack;
using STLang.POUDefinitions;
using STLang.ByteCodegenerator;
using STLang.ConstantPoolHandler;
using STLang.ImplDependentParams;
using StructuredTextParser.Properties;
using STLang.RuntimeWrapper;

namespace STLang.Parser
{
public enum Tokens {error=95,EOF=96,
    WHILE=97,REPEAT=98,UNTIL=99,FOR=100,IF=101,TO=102,
    DO=103,THEN=104,ELSE=105,CASE=106,END_CASE=107,ELSIF=108,
    END_FOR=109,END_WHILE=110,END_IF=111,END_REPEAT=112,EXIT=113,BY=114,
    ASSIGN=115,OUTPUT_ASSIGN=116,PROGRAM=117,END_PROGRAM=118,ARRAY=119,OF=120,
    STRUCT=121,END_STRUCT=122,OVERLAP=123,FUNCTION=124,END_FUNCTION=125,FUNCTION_BLOCK=126,
    END_FUNCTION_BLOCK=127,TYPE=128,END_TYPE=129,INT=130,SINT=131,DINT=132,
    LINT=133,USINT=134,UINT=135,UDINT=136,ULINT=137,REAL=138,
    LREAL=139,DATE=140,TIME=141,TIME_OF_DAY=142,TOD=143,DATE_AND_TIME=144,
    DT=145,STRING=146,WSTRING=147,BOOL=148,BYTE=149,CHAR=150,
    WCHAR=151,WORD=152,DWORD=153,LWORD=154,DOTDOT=155,ANY=156,
    ANY_INT=157,ANY_DERIVED=158,ANY_ELEMENTARY=159,ANY_MAGNITUDE=160,ANY_STRING=161,ANY_REAL=162,
    ANY_BIT=163,ANY_NUM=164,ANY_DATE=165,R_EDGE=166,F_EDGE=167,VAR=168,
    VAR_INPUT=169,VAR_OUTPUT=170,VAR_IN_OUT=171,VAR_EXTERNAL=172,AT=173,VAR_GLOBAL=174,
    VAR_TEMP=175,VAR_ACCESS=176,VAR_CONFIG=177,END_VAR=178,CONSTANT=179,RETAIN=180,
    NON_RETAIN=181,TRUE=182,FALSE=183,RETURN=184,READ_ONLY=185,WRITE_ONLY=186,
    READ_WRITE=187,DUMMY_TOKEN=188,CONFIGURATION=189,END_CONFIGURATION=190,INITIAL_STEP=191,END_STEP=192,
    RESOURCE=193,END_RESOURCE=194,WITH=195,TASK=196,TRANSITION=197,END_TRANSITION=198,
    WHEN=199,INT_LIT=200,REAL_LIT=201,TYPED_INT=202,TYPED_REAL=203,TYPED_ENUM=204,
    DATE_LIT=205,DT_LIT=206,TIME_LIT=207,TOD_LIT=208,STRING_LIT=209,WSTRING_LIT=210,
    IDENT=211,DIRECT_VAR=212,IOR=213,XOR=214,AND=215,NEQ=216,
    GEQ=217,LEQ=218,MOD=219,UMINUS=220,NOT=221,POW=222};

public partial struct ValueType
{
	public Tokens Token;
	public string Ident;
	public TokenInt LInt;
	public TokenDate Date;
	public TokenTime Time;
	public TokenDouble LReal;
	public TokenTOD TimeOfDay;
	public TokenDateTime DateTime;
	public TokenTypedInt TypedInt;
	public TokenTypedReal TypedReal;
	public TokenTypedEnum TypedEnum;
	public TokenDirectVar DirectVar;
	public SubRange Subrange;
	public string String;
	public object Object;
	public Statement Stat;
	public StatementList StatList;
	public DeclarationStatement Declaration;
	public POUVarDeclarations POUVariableDecls;
	public Expression Expression;
	public List<object> GenericList;
	public VarDeclStatement VarInitDecl;
	public List<VarDeclStatement> POUVarDecl;
	public CaseLabel CaseLabel;
	public List<SubRange> Subranges;
	public List<string> IdentifierList;
	public List<CaseLabel> CaseLabelList;
	public List<CaseElement> CaseElementList;
	public InitializerList InitList;
	public STVarType VarType;
	public STVarQualifier VarQualifier;
	public STDeclQualifier EdgeQualifier;
	public TypeNode DataType; 
	public ForLoopData ForList; 
	public DataTypeSpec TypeSpec;
	public POUParameter POUParameter;
	public StructDeclaration StructDecl;
	public StructMemberDeclaration MemberDecl;
	public ProgramOrganizationUnitCall POU;
	public IndexedVariable IndexedVariable;
	public NamedValueList NamedValueList;
	public NamedValue NamedValue;
	public bool Boolean;
}
// Abstract base class for GPLEX scanners
[GeneratedCodeAttribute( "Gardens Point Parser Generator", "1.5.2")]
public abstract class ScanBase : AbstractScanner<ValueType,LexLocation> {
  private LexLocation __yylloc = new LexLocation();
  public override LexLocation yylloc { get { return __yylloc; } set { __yylloc = value; } }
  protected virtual bool yywrap() { return true; }
}

// Utility class for encapsulating token information
[GeneratedCodeAttribute( "Gardens Point Parser Generator", "1.5.2")]
public class ScanObj {
  public int token;
  public ValueType yylval;
  public LexLocation yylloc;
  public ScanObj( int t, ValueType val, LexLocation loc ) {
    this.token = t; this.yylval = val; this.yylloc = loc;
  }
}

[GeneratedCodeAttribute( "Gardens Point Parser Generator", "1.5.2")]
public partial class STLangParser: ShiftReduceParser<ValueType, LexLocation>
{
#pragma warning disable 649
  private static Dictionary<int, string> aliases;
#pragma warning restore 649
  private static Rule[] rules = new Rule[342];
  private static State[] states = new State[553];
  private static string[] nonTerms = new string[] {
      "subrange", "statement_list", "opt_else_stat", "while_statement_body", 
      "for_statement_body", "default_statement", "function_body", "function_block_body", 
      "program_body", "case_stat_list", "var_init_decl", "var_declaration", "var_decl_list", 
      "elsif_stat", "opt_elsif_stat", "case_element_list", "case_elem_list", 
      "identifier_list", "enum_ident_seq", "case_label_list", "array_init_list", 
      "array_init_seq", "struct_init_list", "struct_init_seq", "initializer_seq", 
      "statement", "assignment_stat", "repeat_statement_body", "case_label", 
      "subrange_list", "struct_member_decls", "struct_member_decl", "case_element", 
      "function_decl", "elementary_type", "array_type", "structure_type", "subrange_type", 
      "enumerated_type", "derived_type", "non_generic_type", "string_type", "data_type", 
      "generic_type", "namedvalue_type", "expression", "constant", "condition_DO", 
      "condition_THEN", "expression_OF", "variable", "simple_variable", "symbolic_variable", 
      "initial_value", "until_condition", "control_variable", "optional_by_stat", 
      "initializer", "var_decl", "temp_var_decl", "extern_var_decl", "global_var_decl", 
      "access_var_decl", "config_var_decl", "input_var_decl", "output_var_decl", 
      "inout_var_decl", "data_type_decl", "pou_variable_decl", "pou_call_sequence", 
      "prog_org_unit_call", "pou_parameter", "pou_variable_decls", "pou_var_decl_list", 
      "indexed_variable", "for_list_DO", "data_type_spec", "opt_var_qualifier", 
      "opt_decl_qualifier", "enum_identifier", "assign", "opt_overlap_spec", 
      "named_value", "namedvalue_list", "main", "$accept", "Anon@1", "pou_declarations", 
      "pou_declaration", "function_block_decl", "program_decl", "Anon@2", "Anon@3", 
      "semicolon", "Anon@4", "Anon@5", "Anon@6", "Anon@7", "Anon@8", "type_decl_list", 
      "Anon@9", "type_decl", "Anon@10", "Anon@11", "Anon@12", "Anon@13", "Anon@14", 
      "Anon@15", "Anon@16", "Anon@17", "Anon@18", "Anon@19", "Anon@20", "Anon@21", 
      "Anon@22", "Anon@23", "Anon@24", "Anon@25", "Anon@26", "Anon@27", "Anon@28", 
      "Anon@29", "Anon@30", "Anon@31", "Anon@32", "Anon@33", "Anon@34", "Anon@35", 
      "Anon@36", };

  static STLangParser() {
    states[0] = new State(-2,new int[]{-85,1,-87,3});
    states[1] = new State(new int[]{96,2});
    states[2] = new State(-1);
    states[3] = new State(new int[]{124,7,126,531,117,542,128,514},new int[]{-88,4,-89,552,-34,6,-90,530,-91,541,-68,551});
    states[4] = new State(new int[]{124,7,126,531,117,542,128,514,96,-3},new int[]{-89,5,-34,6,-90,530,-91,541,-68,551});
    states[5] = new State(-5);
    states[6] = new State(-6);
    states[7] = new State(new int[]{211,8});
    states[8] = new State(new int[]{58,9});
    states[9] = new State(new int[]{131,322,130,323,132,324,133,325,134,326,135,327,136,328,137,329,138,330,139,331,140,332,142,333,143,334,144,335,145,336,141,337,148,338,149,339,152,340,153,341,154,342,151,343,150,344,211,395,146,397,147,401},new int[]{-41,10,-35,412,-40,413,-42,414});
    states[10] = new State(-271,new int[]{-113,11});
    states[11] = new State(new int[]{168,251,175,458,172,465,174,472,176,479,177,486,169,493,170,500,171,507,128,514,95,-319,97,-319,98,-319,101,-319,100,-319,106,-319,211,-319,212,-319,113,-319,184,-319,59,-319},new int[]{-73,12,-74,248,-69,529,-59,250,-60,457,-61,464,-62,471,-63,478,-64,485,-65,492,-66,499,-67,506,-68,513});
    states[12] = new State(-272,new int[]{-114,13});
    states[13] = new State(new int[]{95,232,97,-189,98,-189,101,-189,100,-189,106,-189,211,-189,212,-189,113,-189,184,-189,59,-189},new int[]{-7,14,-2,15,-105,201});
    states[14] = new State(-273);
    states[15] = new State(new int[]{125,16,95,19,97,21,98,28,101,135,100,144,106,154,211,81,212,125,113,172,184,173,59,-206},new int[]{-26,17,-27,166,-51,167,-53,114,-52,117,-75,121,-71,175,-70,92});
    states[16] = new State(-265);
    states[17] = new State(new int[]{59,18});
    states[18] = new State(-191);
    states[19] = new State(new int[]{125,20});
    states[20] = new State(-266);
    states[21] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,95,246},new int[]{-48,22,-46,244,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[22] = new State(new int[]{95,242,97,-189,98,-189,101,-189,100,-189,106,-189,211,-189,212,-189,113,-189,184,-189,59,-189},new int[]{-4,23,-2,24,-105,201});
    states[23] = new State(-193);
    states[24] = new State(new int[]{110,25,95,26,97,21,98,28,101,135,100,144,106,154,211,81,212,125,113,172,184,173,59,-206},new int[]{-26,17,-27,166,-51,167,-53,114,-52,117,-75,121,-71,175,-70,92});
    states[25] = new State(-207);
    states[26] = new State(new int[]{110,27});
    states[27] = new State(-208);
    states[28] = new State(-194,new int[]{-106,29});
    states[29] = new State(new int[]{95,240,97,-189,98,-189,101,-189,100,-189,106,-189,211,-189,212,-189,113,-189,184,-189,59,-189},new int[]{-28,30,-2,31,-105,201});
    states[30] = new State(-195);
    states[31] = new State(new int[]{99,32,95,132,97,21,98,28,101,135,100,144,106,154,211,81,212,125,113,172,184,173,59,-206},new int[]{-26,17,-27,166,-51,167,-53,114,-52,117,-75,121,-71,175,-70,92});
    states[32] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,95,130},new int[]{-55,33,-46,34,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[33] = new State(-210);
    states[34] = new State(new int[]{112,35,61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,59,-224});
    states[35] = new State(-222);
    states[36] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,37,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[37] = new State(new int[]{97,-159,60,38,62,40,95,-159,217,44,218,46,215,-159,213,-159,214,-159,222,54,219,56,38,-159,43,60,45,62,42,64,47,66,103,-159,98,-159,101,-159,100,-159,106,-159,211,-159,212,-159,113,-159,184,-159,59,-159,112,-159,41,-159,44,-159,93,-159,104,-159,102,-159,120,-159,199,-159,105,-159,107,-159,155,-159,58,-159,221,-159,40,-159,182,-159,183,-159,200,-159,201,-159,208,-159,207,-159,205,-159,206,-159,209,-159,210,-159,202,-159,203,-159,204,-159,114,-159,178,-159,173,-159,122,-159,129,-159});
    states[38] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,39,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[39] = new State(new int[]{61,-160,101,-160,98,-160,216,-160,97,-160,95,-160,215,-160,213,-160,214,-160,222,54,219,56,38,-160,43,60,45,62,42,64,47,66,103,-160,100,-160,106,-160,211,-160,212,-160,113,-160,184,-160,59,-160,112,-160,41,-160,44,-160,93,-160,104,-160,102,-160,120,-160,199,-160,105,-160,107,-160,155,-160,58,-160,221,-160,40,-160,182,-160,183,-160,200,-160,201,-160,208,-160,207,-160,205,-160,206,-160,209,-160,210,-160,202,-160,203,-160,204,-160,114,-160,178,-160,173,-160,122,-160,129,-160});
    states[40] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,41,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[41] = new State(new int[]{61,-161,101,-161,98,-161,216,-161,97,-161,95,-161,215,-161,213,-161,214,-161,222,54,219,56,38,-161,43,60,45,62,42,64,47,66,103,-161,100,-161,106,-161,211,-161,212,-161,113,-161,184,-161,59,-161,112,-161,41,-161,44,-161,93,-161,104,-161,102,-161,120,-161,199,-161,105,-161,107,-161,155,-161,58,-161,221,-161,40,-161,182,-161,183,-161,200,-161,201,-161,208,-161,207,-161,205,-161,206,-161,209,-161,210,-161,202,-161,203,-161,204,-161,114,-161,178,-161,173,-161,122,-161,129,-161});
    states[42] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,43,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[43] = new State(new int[]{97,-162,60,38,62,40,95,-162,217,44,218,46,215,-162,213,-162,214,-162,222,54,219,56,38,-162,43,60,45,62,42,64,47,66,103,-162,98,-162,101,-162,100,-162,106,-162,211,-162,212,-162,113,-162,184,-162,59,-162,112,-162,41,-162,44,-162,93,-162,104,-162,102,-162,120,-162,199,-162,105,-162,107,-162,155,-162,58,-162,221,-162,40,-162,182,-162,183,-162,200,-162,201,-162,208,-162,207,-162,205,-162,206,-162,209,-162,210,-162,202,-162,203,-162,204,-162,114,-162,178,-162,173,-162,122,-162,129,-162});
    states[44] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,45,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[45] = new State(new int[]{61,-163,101,-163,98,-163,216,-163,97,-163,95,-163,215,-163,213,-163,214,-163,222,54,219,56,38,-163,43,60,45,62,42,64,47,66,103,-163,100,-163,106,-163,211,-163,212,-163,113,-163,184,-163,59,-163,112,-163,41,-163,44,-163,93,-163,104,-163,102,-163,120,-163,199,-163,105,-163,107,-163,155,-163,58,-163,221,-163,40,-163,182,-163,183,-163,200,-163,201,-163,208,-163,207,-163,205,-163,206,-163,209,-163,210,-163,202,-163,203,-163,204,-163,114,-163,178,-163,173,-163,122,-163,129,-163});
    states[46] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,47,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[47] = new State(new int[]{61,-164,101,-164,98,-164,216,-164,97,-164,95,-164,215,-164,213,-164,214,-164,222,54,219,56,38,-164,43,60,45,62,42,64,47,66,103,-164,100,-164,106,-164,211,-164,212,-164,113,-164,184,-164,59,-164,112,-164,41,-164,44,-164,93,-164,104,-164,102,-164,120,-164,199,-164,105,-164,107,-164,155,-164,58,-164,221,-164,40,-164,182,-164,183,-164,200,-164,201,-164,208,-164,207,-164,205,-164,206,-164,209,-164,210,-164,202,-164,203,-164,204,-164,114,-164,178,-164,173,-164,122,-164,129,-164});
    states[48] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,49,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[49] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,-165,213,-165,214,-165,222,54,219,56,38,-165,43,60,45,62,42,64,47,66,103,-165,95,-165,97,-165,98,-165,101,-165,100,-165,106,-165,211,-165,212,-165,113,-165,184,-165,59,-165,112,-165,41,-165,44,-165,93,-165,104,-165,102,-165,120,-165,199,-165,105,-165,107,-165,155,-165,58,-165,221,-165,40,-165,182,-165,183,-165,200,-165,201,-165,208,-165,207,-165,205,-165,206,-165,209,-165,210,-165,202,-165,203,-165,204,-165,114,-165,178,-165,173,-165,122,-165,129,-165});
    states[50] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,51,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[51] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,-166,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,103,-166,95,-166,97,-166,98,-166,101,-166,100,-166,106,-166,211,-166,212,-166,113,-166,184,-166,59,-166,112,-166,41,-166,44,-166,93,-166,104,-166,102,-166,120,-166,199,-166,105,-166,107,-166,155,-166,58,-166,221,-166,40,-166,182,-166,183,-166,200,-166,201,-166,208,-166,207,-166,205,-166,206,-166,209,-166,210,-166,202,-166,203,-166,204,-166,114,-166,178,-166,173,-166,122,-166,129,-166});
    states[52] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,53,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[53] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,-167,214,-167,222,54,219,56,38,58,43,60,45,62,42,64,47,66,103,-167,95,-167,97,-167,98,-167,101,-167,100,-167,106,-167,211,-167,212,-167,113,-167,184,-167,59,-167,112,-167,41,-167,44,-167,93,-167,104,-167,102,-167,120,-167,199,-167,105,-167,107,-167,155,-167,58,-167,221,-167,40,-167,182,-167,183,-167,200,-167,201,-167,208,-167,207,-167,205,-167,206,-167,209,-167,210,-167,202,-167,203,-167,204,-167,114,-167,178,-167,173,-167,122,-167,129,-167});
    states[54] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,55,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[55] = new State(new int[]{61,-168,60,-168,62,-168,216,-168,217,-168,218,-168,215,-168,213,-168,214,-168,222,54,219,-168,38,-168,43,-168,45,-168,42,-168,47,-168,103,-168,95,-168,97,-168,98,-168,101,-168,100,-168,106,-168,211,-168,212,-168,113,-168,184,-168,59,-168,112,-168,41,-168,44,-168,93,-168,104,-168,102,-168,120,-168,199,-168,105,-168,107,-168,155,-168,58,-168,221,-168,40,-168,182,-168,183,-168,200,-168,201,-168,208,-168,207,-168,205,-168,206,-168,209,-168,210,-168,202,-168,203,-168,204,-168,114,-168,178,-168,173,-168,122,-168,129,-168});
    states[56] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,57,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[57] = new State(new int[]{61,-169,60,-169,62,-169,216,-169,217,-169,218,-169,215,-169,213,-169,214,-169,222,54,219,-169,38,-169,43,-169,45,-169,42,-169,47,-169,103,-169,95,-169,97,-169,98,-169,101,-169,100,-169,106,-169,211,-169,212,-169,113,-169,184,-169,59,-169,112,-169,41,-169,44,-169,93,-169,104,-169,102,-169,120,-169,199,-169,105,-169,107,-169,155,-169,58,-169,221,-169,40,-169,182,-169,183,-169,200,-169,201,-169,208,-169,207,-169,205,-169,206,-169,209,-169,210,-169,202,-169,203,-169,204,-169,114,-169,178,-169,173,-169,122,-169,129,-169});
    states[58] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,59,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[59] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,-170,213,-170,214,-170,222,54,219,56,38,-170,43,60,45,62,42,64,47,66,103,-170,95,-170,97,-170,98,-170,101,-170,100,-170,106,-170,211,-170,212,-170,113,-170,184,-170,59,-170,112,-170,41,-170,44,-170,93,-170,104,-170,102,-170,120,-170,199,-170,105,-170,107,-170,155,-170,58,-170,221,-170,40,-170,182,-170,183,-170,200,-170,201,-170,208,-170,207,-170,205,-170,206,-170,209,-170,210,-170,202,-170,203,-170,204,-170,114,-170,178,-170,173,-170,122,-170,129,-170});
    states[60] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,61,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[61] = new State(new int[]{61,-171,60,-171,62,-171,216,-171,217,-171,218,-171,215,-171,213,-171,214,-171,222,54,219,56,38,-171,43,-171,45,-171,42,64,47,66,103,-171,95,-171,97,-171,98,-171,101,-171,100,-171,106,-171,211,-171,212,-171,113,-171,184,-171,59,-171,112,-171,41,-171,44,-171,93,-171,104,-171,102,-171,120,-171,199,-171,105,-171,107,-171,155,-171,58,-171,221,-171,40,-171,182,-171,183,-171,200,-171,201,-171,208,-171,207,-171,205,-171,206,-171,209,-171,210,-171,202,-171,203,-171,204,-171,114,-171,178,-171,173,-171,122,-171,129,-171});
    states[62] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,63,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[63] = new State(new int[]{61,-172,60,-172,62,-172,216,-172,217,-172,218,-172,215,-172,213,-172,214,-172,222,54,219,56,38,-172,43,-172,45,-172,42,64,47,66,103,-172,95,-172,97,-172,98,-172,101,-172,100,-172,106,-172,211,-172,212,-172,113,-172,184,-172,59,-172,112,-172,41,-172,44,-172,93,-172,104,-172,102,-172,120,-172,199,-172,105,-172,107,-172,155,-172,58,-172,221,-172,40,-172,182,-172,183,-172,200,-172,201,-172,208,-172,207,-172,205,-172,206,-172,209,-172,210,-172,202,-172,203,-172,204,-172,114,-172,178,-172,173,-172,122,-172,129,-172});
    states[64] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,65,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[65] = new State(new int[]{61,-173,60,-173,62,-173,216,-173,217,-173,218,-173,215,-173,213,-173,214,-173,222,54,219,-173,38,-173,43,-173,45,-173,42,-173,47,-173,103,-173,95,-173,97,-173,98,-173,101,-173,100,-173,106,-173,211,-173,212,-173,113,-173,184,-173,59,-173,112,-173,41,-173,44,-173,93,-173,104,-173,102,-173,120,-173,199,-173,105,-173,107,-173,155,-173,58,-173,221,-173,40,-173,182,-173,183,-173,200,-173,201,-173,208,-173,207,-173,205,-173,206,-173,209,-173,210,-173,202,-173,203,-173,204,-173,114,-173,178,-173,173,-173,122,-173,129,-173});
    states[66] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,67,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[67] = new State(new int[]{61,-174,60,-174,62,-174,216,-174,217,-174,218,-174,215,-174,213,-174,214,-174,222,54,219,-174,38,-174,43,-174,45,-174,42,-174,47,-174,103,-174,95,-174,97,-174,98,-174,101,-174,100,-174,106,-174,211,-174,212,-174,113,-174,184,-174,59,-174,112,-174,41,-174,44,-174,93,-174,104,-174,102,-174,120,-174,199,-174,105,-174,107,-174,155,-174,58,-174,221,-174,40,-174,182,-174,183,-174,200,-174,201,-174,208,-174,207,-174,205,-174,206,-174,209,-174,210,-174,202,-174,203,-174,204,-174,114,-174,178,-174,173,-174,122,-174,129,-174});
    states[68] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,69,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[69] = new State(new int[]{61,-156,60,-156,62,-156,216,-156,217,-156,218,-156,215,-156,213,-156,214,-156,222,54,219,-156,38,-156,43,-156,45,-156,42,-156,47,-156,103,-156,95,-156,97,-156,98,-156,101,-156,100,-156,106,-156,211,-156,212,-156,113,-156,184,-156,59,-156,112,-156,41,-156,44,-156,93,-156,104,-156,102,-156,120,-156,199,-156,105,-156,107,-156,155,-156,58,-156,221,-156,40,-156,182,-156,183,-156,200,-156,201,-156,208,-156,207,-156,205,-156,206,-156,209,-156,210,-156,202,-156,203,-156,204,-156,114,-156,178,-156,173,-156,122,-156,129,-156});
    states[70] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,71,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[71] = new State(new int[]{61,-157,60,-157,62,-157,216,-157,217,-157,218,-157,215,-157,213,-157,214,-157,222,54,219,-157,38,-157,43,-157,45,-157,42,-157,47,-157,103,-157,95,-157,97,-157,98,-157,101,-157,100,-157,106,-157,211,-157,212,-157,113,-157,184,-157,59,-157,112,-157,41,-157,44,-157,93,-157,104,-157,102,-157,120,-157,199,-157,105,-157,107,-157,155,-157,58,-157,221,-157,40,-157,182,-157,183,-157,200,-157,201,-157,208,-157,207,-157,205,-157,206,-157,209,-157,210,-157,202,-157,203,-157,204,-157,114,-157,178,-157,173,-157,122,-157,129,-157});
    states[72] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,73,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[73] = new State(new int[]{61,-158,60,-158,62,-158,216,-158,217,-158,218,-158,215,-158,213,-158,214,-158,222,54,219,-158,38,-158,43,-158,45,-158,42,-158,47,-158,103,-158,95,-158,97,-158,98,-158,101,-158,100,-158,106,-158,211,-158,212,-158,113,-158,184,-158,59,-158,112,-158,41,-158,44,-158,93,-158,104,-158,102,-158,120,-158,199,-158,105,-158,107,-158,155,-158,58,-158,221,-158,40,-158,182,-158,183,-158,200,-158,201,-158,208,-158,207,-158,205,-158,206,-158,209,-158,210,-158,202,-158,203,-158,204,-158,114,-158,178,-158,173,-158,122,-158,129,-158});
    states[74] = new State(new int[]{95,78,221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,75,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[75] = new State(new int[]{41,76,95,77,61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66});
    states[76] = new State(-175);
    states[77] = new State(-176);
    states[78] = new State(new int[]{41,79});
    states[79] = new State(-180);
    states[80] = new State(-177);
    states[81] = new State(new int[]{40,82,91,-154,46,-154,115,-154,61,-154,103,-154,60,-154,62,-154,216,-154,217,-154,218,-154,215,-154,213,-154,214,-154,222,-154,219,-154,38,-154,43,-154,45,-154,42,-154,47,-154,95,-154,97,-154,98,-154,101,-154,100,-154,106,-154,211,-154,212,-154,113,-154,184,-154,59,-154,112,-154,41,-154,44,-154,93,-154,104,-154,102,-154,120,-154,199,-154,105,-154,107,-154,155,-154,58,-154,221,-154,182,-154,183,-154,200,-154,201,-154,208,-154,207,-154,205,-154,206,-154,209,-154,210,-154,202,-154,203,-154,204,-154,114,-154,178,-154,173,-154,122,-154,129,-154});
    states[82] = new State(new int[]{41,83,95,84,221,88,45,70,43,72,40,74,211,96,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-72,86,-46,87,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[83] = new State(-186);
    states[84] = new State(new int[]{41,85});
    states[85] = new State(-187);
    states[86] = new State(-184);
    states[87] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,41,-181,44,-181});
    states[88] = new State(new int[]{211,89,221,68,45,70,43,72,40,74,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,69,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[89] = new State(new int[]{40,82,115,128,116,129,91,-154,46,-154,61,-154,60,-154,62,-154,216,-154,217,-154,218,-154,215,-154,213,-154,214,-154,222,-154,219,-154,38,-154,43,-154,45,-154,42,-154,47,-154,41,-154,44,-154},new int[]{-81,90});
    states[90] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,91,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[91] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,41,-183,44,-183});
    states[92] = new State(new int[]{41,93,44,94});
    states[93] = new State(-188);
    states[94] = new State(new int[]{221,88,45,70,43,72,40,74,211,96,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-72,95,-46,87,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[95] = new State(-185);
    states[96] = new State(new int[]{40,82,115,128,116,129,91,-154,46,-154,61,-154,60,-154,62,-154,216,-154,217,-154,218,-154,215,-154,213,-154,214,-154,222,-154,219,-154,38,-154,43,-154,45,-154,42,-154,47,-154,41,-154,44,-154},new int[]{-81,97});
    states[97] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,98,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[98] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,41,-182,44,-182});
    states[99] = new State(-178);
    states[100] = new State(-133);
    states[101] = new State(-134);
    states[102] = new State(-135);
    states[103] = new State(-136);
    states[104] = new State(-137);
    states[105] = new State(-138);
    states[106] = new State(-139);
    states[107] = new State(-140);
    states[108] = new State(-141);
    states[109] = new State(-142);
    states[110] = new State(-143);
    states[111] = new State(-144);
    states[112] = new State(-145);
    states[113] = new State(-179);
    states[114] = new State(new int[]{46,115,115,-146,61,-146,103,-146,60,-146,62,-146,216,-146,217,-146,218,-146,215,-146,213,-146,214,-146,222,-146,219,-146,38,-146,43,-146,45,-146,42,-146,47,-146,95,-146,97,-146,98,-146,101,-146,100,-146,106,-146,211,-146,212,-146,113,-146,184,-146,59,-146,112,-146,41,-146,44,-146,93,-146,104,-146,102,-146,120,-146,199,-146,105,-146,107,-146,155,-146,58,-146,221,-146,40,-146,182,-146,183,-146,200,-146,201,-146,208,-146,207,-146,205,-146,206,-146,209,-146,210,-146,202,-146,203,-146,204,-146,114,-146,178,-146,173,-146,122,-146,129,-146,116,-146});
    states[115] = new State(new int[]{211,116});
    states[116] = new State(-155);
    states[117] = new State(new int[]{91,118,46,-148,115,-148,61,-148,103,-148,60,-148,62,-148,216,-148,217,-148,218,-148,215,-148,213,-148,214,-148,222,-148,219,-148,38,-148,43,-148,45,-148,42,-148,47,-148,95,-148,97,-148,98,-148,101,-148,100,-148,106,-148,211,-148,212,-148,113,-148,184,-148,59,-148,112,-148,41,-148,44,-148,93,-148,104,-148,102,-148,120,-148,199,-148,105,-148,107,-148,155,-148,58,-148,221,-148,40,-148,182,-148,183,-148,200,-148,201,-148,208,-148,207,-148,205,-148,206,-148,209,-148,210,-148,202,-148,203,-148,204,-148,114,-148,178,-148,173,-148,122,-148,129,-148,116,-148});
    states[118] = new State(new int[]{95,126,221,-151,45,-151,43,-151,40,-151,211,-151,182,-151,183,-151,200,-151,201,-151,208,-151,207,-151,205,-151,206,-151,209,-151,210,-151,202,-151,203,-151,204,-151,212,-151},new int[]{-104,119});
    states[119] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,120,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[120] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,93,-152,44,-152});
    states[121] = new State(new int[]{93,122,44,123});
    states[122] = new State(-149);
    states[123] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,124,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[124] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,93,-153,44,-153});
    states[125] = new State(-147);
    states[126] = new State(new int[]{93,127});
    states[127] = new State(-150);
    states[128] = new State(-10);
    states[129] = new State(-11);
    states[130] = new State(new int[]{112,131});
    states[131] = new State(-223);
    states[132] = new State(new int[]{99,133});
    states[133] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,95,130},new int[]{-55,134,-46,34,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[134] = new State(-211);
    states[135] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,95,235},new int[]{-49,136,-46,233,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[136] = new State(new int[]{95,232,97,-189,98,-189,101,-189,100,-189,106,-189,211,-189,212,-189,113,-189,184,-189,59,-189},new int[]{-2,137,-105,201});
    states[137] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,211,81,212,125,113,172,184,173,108,-196,105,-196,111,-196,59,-206},new int[]{-107,138,-26,17,-27,166,-51,167,-53,114,-52,117,-75,121,-71,175,-70,92});
    states[138] = new State(new int[]{108,237,105,-242,111,-242},new int[]{-15,139,-14,228});
    states[139] = new State(new int[]{105,142,111,-240},new int[]{-3,140});
    states[140] = new State(new int[]{111,141});
    states[141] = new State(-197);
    states[142] = new State(new int[]{95,227,97,-189,98,-189,101,-189,100,-189,106,-189,211,-189,212,-189,113,-189,184,-189,59,-189},new int[]{-2,143,-105,201});
    states[143] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,211,81,212,125,113,172,184,173,111,-238,59,-206},new int[]{-26,17,-27,166,-51,167,-53,114,-52,117,-75,121,-71,175,-70,92});
    states[144] = new State(new int[]{211,226,212,125},new int[]{-56,145,-51,225,-53,114,-52,117,-75,121});
    states[145] = new State(new int[]{115,128,116,129},new int[]{-81,146});
    states[146] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,95,218},new int[]{-76,147,-46,207,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[147] = new State(-198,new int[]{-108,148});
    states[148] = new State(new int[]{95,204,97,-189,98,-189,101,-189,100,-189,106,-189,211,-189,212,-189,113,-189,184,-189,59,-189},new int[]{-5,149,-2,150,-105,201});
    states[149] = new State(-199);
    states[150] = new State(new int[]{109,151,95,152,97,21,98,28,101,135,100,144,106,154,211,81,212,125,113,172,184,173,59,-206},new int[]{-26,17,-27,166,-51,167,-53,114,-52,117,-75,121,-71,175,-70,92});
    states[151] = new State(-213);
    states[152] = new State(new int[]{109,153});
    states[153] = new State(-214);
    states[154] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,95,199},new int[]{-50,155,-46,197,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[155] = new State(new int[]{199,160,105,193,107,-256},new int[]{-16,156,-17,158,-33,196,-6,192});
    states[156] = new State(new int[]{107,157});
    states[157] = new State(-200);
    states[158] = new State(new int[]{199,160,105,193,107,-255},new int[]{-33,159,-6,192});
    states[159] = new State(-254);
    states[160] = new State(new int[]{95,188,221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-20,161,-29,191,-46,184,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121,-1,187});
    states[161] = new State(new int[]{58,162,44,182,95,179,97,-245,98,-245,101,-245,100,-245,106,-245,211,-245,212,-245,113,-245,184,-245,59,-245},new int[]{-10,181,-112,176});
    states[162] = new State(new int[]{95,179,97,-245,98,-245,101,-245,100,-245,106,-245,211,-245,212,-245,113,-245,184,-245,59,-245},new int[]{-10,163,-112,176});
    states[163] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,211,81,212,125,113,172,184,173,199,-249,105,-249,107,-249,59,-206},new int[]{-26,164,-27,166,-51,167,-53,114,-52,117,-75,121,-71,175,-70,92});
    states[164] = new State(new int[]{59,165});
    states[165] = new State(-247);
    states[166] = new State(-201);
    states[167] = new State(new int[]{115,168,61,170});
    states[168] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,169,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[169] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,59,-263});
    states[170] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,171,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[171] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,59,-264});
    states[172] = new State(-202);
    states[173] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,59,-203},new int[]{-46,174,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[174] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,59,-204});
    states[175] = new State(-205);
    states[176] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,211,81,212,125,113,172,184,173,59,-206},new int[]{-26,177,-27,166,-51,167,-53,114,-52,117,-75,121,-71,175,-70,92});
    states[177] = new State(new int[]{59,178});
    states[178] = new State(-246);
    states[179] = new State(new int[]{59,180});
    states[180] = new State(-248);
    states[181] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,211,81,212,125,113,172,184,173,199,-251,105,-251,107,-251,59,-206},new int[]{-26,164,-27,166,-51,167,-53,114,-52,117,-75,121,-71,175,-70,92});
    states[182] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-29,183,-46,184,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121,-1,187});
    states[183] = new State(-260);
    states[184] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,155,185,58,-257,44,-257,95,-257,97,-257,98,-257,101,-257,100,-257,106,-257,211,-257,212,-257,113,-257,184,-257,59,-257});
    states[185] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,186,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[186] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,58,-12,44,-12,95,-12,97,-12,98,-12,101,-12,100,-12,106,-12,211,-12,212,-12,113,-12,184,-12,59,-12,41,-12,93,-12,221,-12,40,-12,182,-12,183,-12,200,-12,201,-12,208,-12,207,-12,205,-12,206,-12,209,-12,210,-12,202,-12,203,-12,204,-12});
    states[187] = new State(-258);
    states[188] = new State(new int[]{58,189});
    states[189] = new State(new int[]{95,179,97,-245,98,-245,101,-245,100,-245,106,-245,211,-245,212,-245,113,-245,184,-245,59,-245},new int[]{-10,190,-112,176});
    states[190] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,211,81,212,125,113,172,184,173,199,-250,105,-250,107,-250,59,-206},new int[]{-26,164,-27,166,-51,167,-53,114,-52,117,-75,121,-71,175,-70,92});
    states[191] = new State(-259);
    states[192] = new State(-252);
    states[193] = new State(new int[]{95,179,97,-245,98,-245,101,-245,100,-245,106,-245,211,-245,212,-245,113,-245,184,-245,59,-245},new int[]{-10,194,-112,176});
    states[194] = new State(new int[]{95,195,97,21,98,28,101,135,100,144,106,154,211,81,212,125,113,172,184,173,199,-243,105,-243,107,-243,59,-206},new int[]{-26,164,-27,166,-51,167,-53,114,-52,117,-75,121,-71,175,-70,92});
    states[195] = new State(-244);
    states[196] = new State(-253);
    states[197] = new State(new int[]{120,198,61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,199,-227,105,-227,107,-227});
    states[198] = new State(-225);
    states[199] = new State(new int[]{120,200});
    states[200] = new State(-226);
    states[201] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,211,81,212,125,113,172,184,173,59,-206},new int[]{-26,202,-27,166,-51,167,-53,114,-52,117,-75,121,-71,175,-70,92});
    states[202] = new State(new int[]{59,203});
    states[203] = new State(-190);
    states[204] = new State(new int[]{59,205,109,206});
    states[205] = new State(-192);
    states[206] = new State(-215);
    states[207] = new State(new int[]{102,208,61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66});
    states[208] = new State(new int[]{95,216,221,-229,45,-229,43,-229,40,-229,211,-229,182,-229,183,-229,200,-229,201,-229,208,-229,207,-229,205,-229,206,-229,209,-229,210,-229,202,-229,203,-229,204,-229,212,-229},new int[]{-109,209});
    states[209] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,210,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[210] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,114,213,103,-237},new int[]{-57,211});
    states[211] = new State(new int[]{103,212});
    states[212] = new State(-230);
    states[213] = new State(-235,new int[]{-111,214});
    states[214] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,215,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[215] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,103,-236});
    states[216] = new State(new int[]{103,217});
    states[217] = new State(-233);
    states[218] = new State(new int[]{102,219,103,224});
    states[219] = new State(-231,new int[]{-110,220});
    states[220] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,221,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[221] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,114,213,103,-237},new int[]{-57,222});
    states[222] = new State(new int[]{103,223});
    states[223] = new State(-232);
    states[224] = new State(-234);
    states[225] = new State(-228);
    states[226] = new State(-154);
    states[227] = new State(new int[]{59,205,111,-239});
    states[228] = new State(new int[]{108,229,105,-241,111,-241});
    states[229] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,95,235},new int[]{-49,230,-46,233,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[230] = new State(new int[]{95,232,97,-189,98,-189,101,-189,100,-189,106,-189,211,-189,212,-189,113,-189,184,-189,59,-189},new int[]{-2,231,-105,201});
    states[231] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,211,81,212,125,113,172,184,173,108,-262,105,-262,111,-262,59,-206},new int[]{-26,17,-27,166,-51,167,-53,114,-52,117,-75,121,-71,175,-70,92});
    states[232] = new State(new int[]{59,205});
    states[233] = new State(new int[]{104,234,61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,95,-221,97,-221,98,-221,101,-221,100,-221,106,-221,211,-221,212,-221,113,-221,184,-221,59,-221});
    states[234] = new State(-219);
    states[235] = new State(new int[]{104,236});
    states[236] = new State(-220);
    states[237] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,95,235},new int[]{-49,238,-46,233,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[238] = new State(new int[]{95,232,97,-189,98,-189,101,-189,100,-189,106,-189,211,-189,212,-189,113,-189,184,-189,59,-189},new int[]{-2,239,-105,201});
    states[239] = new State(new int[]{97,21,98,28,101,135,100,144,106,154,211,81,212,125,113,172,184,173,108,-261,105,-261,111,-261,59,-206},new int[]{-26,17,-27,166,-51,167,-53,114,-52,117,-75,121,-71,175,-70,92});
    states[240] = new State(new int[]{59,205,112,241});
    states[241] = new State(-212);
    states[242] = new State(new int[]{59,205,110,243});
    states[243] = new State(-209);
    states[244] = new State(new int[]{103,245,61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,95,-218,97,-218,98,-218,101,-218,100,-218,106,-218,211,-218,212,-218,113,-218,184,-218,59,-218});
    states[245] = new State(-216);
    states[246] = new State(new int[]{103,247});
    states[247] = new State(-217);
    states[248] = new State(new int[]{168,251,175,458,172,465,174,472,176,479,177,486,169,493,170,500,171,507,128,514,95,-318,97,-318,98,-318,101,-318,100,-318,106,-318,211,-318,212,-318,113,-318,184,-318,59,-318},new int[]{-69,249,-59,250,-60,457,-61,464,-62,471,-63,478,-64,485,-65,492,-66,499,-67,506,-68,513});
    states[249] = new State(-317);
    states[250] = new State(-306);
    states[251] = new State(new int[]{95,450,180,452,181,454,179,455,211,-336,173,-336},new int[]{-78,252});
    states[252] = new State(-282,new int[]{-119,253});
    states[253] = new State(new int[]{211,437,173,443},new int[]{-12,254,-13,255,-11,448,-18,262});
    states[254] = new State(-283);
    states[255] = new State(new int[]{178,256,95,260,211,437,173,443},new int[]{-11,257,-18,262});
    states[256] = new State(-322);
    states[257] = new State(new int[]{59,259,178,-130,95,-130,211,-130,173,-130},new int[]{-94,258});
    states[258] = new State(-321);
    states[259] = new State(-129);
    states[260] = new State(new int[]{178,261});
    states[261] = new State(-323);
    states[262] = new State(new int[]{58,263,44,434,211,436});
    states[263] = new State(new int[]{131,322,130,323,132,324,133,325,134,326,135,327,136,328,137,329,138,330,139,331,140,332,142,333,143,334,144,335,145,336,141,337,148,338,149,339,152,340,153,341,154,342,151,343,150,344,40,362,121,382,211,395,146,397,147,401,119,406,156,424,164,425,157,426,162,427,163,428,165,429,158,430,159,431,160,432,161,433},new int[]{-43,264,-35,316,-45,345,-84,346,-39,352,-19,353,-37,367,-31,368,-38,387,-41,388,-40,394,-42,396,-36,405,-44,423});
    states[264] = new State(new int[]{166,312,167,313,185,314,186,315,115,-341,59,-341,178,-341,95,-341,211,-341,173,-341},new int[]{-79,265});
    states[265] = new State(new int[]{59,-324,178,-324,95,-324,211,-324,173,-324,115,-325},new int[]{-127,266});
    states[266] = new State(new int[]{115,267});
    states[267] = new State(new int[]{221,68,45,70,43,72,40,270,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,91,294},new int[]{-54,268,-46,269,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121,-21,278,-22,279,-23,297,-24,298});
    states[268] = new State(-326);
    states[269] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,59,-120,178,-120,95,-120,211,-120,173,-120,41,-120,44,-120,93,-120,122,-120,129,-120});
    states[270] = new State(new int[]{95,78,41,273,221,68,45,70,43,72,40,270,211,274,182,100,183,101,200,284,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,91,294},new int[]{-46,271,-58,272,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121,-54,283,-21,278,-22,279,-23,297,-24,298});
    states[271] = new State(new int[]{41,76,95,77,61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,44,-120});
    states[272] = new State(-101);
    states[273] = new State(-109);
    states[274] = new State(new int[]{40,82,91,-154,46,-154,41,-154,95,-154,61,-154,60,-154,62,-154,216,-154,217,-154,218,-154,215,-154,213,-154,214,-154,222,-154,219,-154,38,-154,43,-154,45,-154,42,-154,47,-154,44,-154,93,-154,115,-115},new int[]{-99,275});
    states[275] = new State(new int[]{115,276});
    states[276] = new State(new int[]{221,68,45,70,43,72,40,270,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,91,294},new int[]{-54,277,-46,269,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121,-21,278,-22,279,-23,297,-24,298});
    states[277] = new State(-116);
    states[278] = new State(-121);
    states[279] = new State(new int[]{93,280,44,281,95,310});
    states[280] = new State(-103);
    states[281] = new State(new int[]{221,68,45,70,43,72,40,270,211,274,182,100,183,101,200,284,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,91,294},new int[]{-58,282,-54,283,-46,269,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121,-21,278,-22,279,-23,297,-24,298});
    states[282] = new State(-100);
    states[283] = new State(-110);
    states[284] = new State(new int[]{40,285,41,-135,95,-135,61,-135,60,-135,62,-135,216,-135,217,-135,218,-135,215,-135,213,-135,214,-135,222,-135,219,-135,38,-135,43,-135,45,-135,42,-135,47,-135,44,-135,93,-135});
    states[285] = new State(new int[]{95,-111,221,-113,45,-113,43,-113,40,-113,211,-113,182,-113,183,-113,200,-113,201,-113,208,-113,207,-113,205,-113,206,-113,209,-113,210,-113,202,-113,203,-113,204,-113,212,-113,91,-113},new int[]{-97,286,-98,289});
    states[286] = new State(new int[]{95,287});
    states[287] = new State(new int[]{41,288});
    states[288] = new State(-112);
    states[289] = new State(new int[]{221,68,45,70,43,72,40,270,211,274,182,100,183,101,200,284,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,91,294},new int[]{-25,290,-58,309,-54,283,-46,269,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121,-21,278,-22,279,-23,297,-24,298});
    states[290] = new State(new int[]{41,291,44,292,95,307});
    states[291] = new State(-114);
    states[292] = new State(new int[]{221,68,45,70,43,72,40,270,211,274,182,100,183,101,200,284,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,91,294},new int[]{-58,293,-54,283,-46,269,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121,-21,278,-22,279,-23,297,-24,298});
    states[293] = new State(-118);
    states[294] = new State(new int[]{95,304,93,306,221,-98,45,-98,43,-98,40,-98,211,-98,182,-98,183,-98,200,-98,201,-98,208,-98,207,-98,205,-98,206,-98,209,-98,210,-98,202,-98,203,-98,204,-98,212,-98,91,-98},new int[]{-96,295});
    states[295] = new State(new int[]{221,68,45,70,43,72,40,270,211,274,182,100,183,101,200,284,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,91,294},new int[]{-58,296,-54,283,-46,269,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121,-21,278,-22,279,-23,297,-24,298});
    states[296] = new State(-99);
    states[297] = new State(-122);
    states[298] = new State(new int[]{41,299,44,300,95,302});
    states[299] = new State(-107);
    states[300] = new State(new int[]{221,68,45,70,43,72,40,270,211,274,182,100,183,101,200,284,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,91,294},new int[]{-58,301,-54,283,-46,269,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121,-21,278,-22,279,-23,297,-24,298});
    states[301] = new State(-102);
    states[302] = new State(new int[]{41,303});
    states[303] = new State(-108);
    states[304] = new State(new int[]{93,305});
    states[305] = new State(-105);
    states[306] = new State(-106);
    states[307] = new State(new int[]{221,68,45,70,43,72,40,270,211,274,182,100,183,101,200,284,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,91,294},new int[]{-58,308,-54,283,-46,269,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121,-21,278,-22,279,-23,297,-24,298});
    states[308] = new State(-119);
    states[309] = new State(-117);
    states[310] = new State(new int[]{93,311});
    states[311] = new State(-104);
    states[312] = new State(-337);
    states[313] = new State(-338);
    states[314] = new State(-339);
    states[315] = new State(-340);
    states[316] = new State(new int[]{40,317,166,-56,167,-56,185,-56,186,-56,115,-56,59,-56,178,-56,95,-56,211,-56,173,-56,122,-56,129,-56});
    states[317] = new State(new int[]{211,319},new int[]{-83,318});
    states[318] = new State(-95);
    states[319] = new State(new int[]{115,320});
    states[320] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,321,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[321] = new State(new int[]{61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66,41,-97,44,-97,95,-97});
    states[322] = new State(-19);
    states[323] = new State(-20);
    states[324] = new State(-21);
    states[325] = new State(-22);
    states[326] = new State(-23);
    states[327] = new State(-24);
    states[328] = new State(-25);
    states[329] = new State(-26);
    states[330] = new State(-27);
    states[331] = new State(-28);
    states[332] = new State(-29);
    states[333] = new State(-30);
    states[334] = new State(-31);
    states[335] = new State(-32);
    states[336] = new State(-33);
    states[337] = new State(-34);
    states[338] = new State(-35);
    states[339] = new State(-36);
    states[340] = new State(-37);
    states[341] = new State(-38);
    states[342] = new State(-39);
    states[343] = new State(-40);
    states[344] = new State(-41);
    states[345] = new State(-57);
    states[346] = new State(new int[]{41,347,44,348,95,350});
    states[347] = new State(-93);
    states[348] = new State(new int[]{211,319},new int[]{-83,349});
    states[349] = new State(-96);
    states[350] = new State(new int[]{41,351});
    states[351] = new State(-94);
    states[352] = new State(-58);
    states[353] = new State(new int[]{41,354,44,355,95,360,211,357,204,358},new int[]{-80,359});
    states[354] = new State(-83);
    states[355] = new State(new int[]{211,357,204,358},new int[]{-80,356});
    states[356] = new State(-81);
    states[357] = new State(-78);
    states[358] = new State(-79);
    states[359] = new State(-82);
    states[360] = new State(new int[]{41,361});
    states[361] = new State(-84);
    states[362] = new State(new int[]{95,364,41,366,211,357,204,358},new int[]{-80,363});
    states[363] = new State(-80);
    states[364] = new State(new int[]{41,365});
    states[365] = new State(-85);
    states[366] = new State(-86);
    states[367] = new State(-59);
    states[368] = new State(new int[]{122,369,95,371,211,373},new int[]{-32,370});
    states[369] = new State(-74);
    states[370] = new State(-72);
    states[371] = new State(new int[]{122,372});
    states[372] = new State(-75);
    states[373] = new State(new int[]{58,374});
    states[374] = new State(new int[]{131,322,130,323,132,324,133,325,134,326,135,327,136,328,137,329,138,330,139,331,140,332,142,333,143,334,144,335,145,336,141,337,148,338,149,339,152,340,153,341,154,342,151,343,150,344,40,362,121,382,211,395,146,397,147,401,119,406,156,424,164,425,157,426,162,427,163,428,165,429,158,430,159,431,160,432,161,433},new int[]{-77,375,-43,377,-35,316,-45,345,-84,346,-39,352,-19,353,-37,367,-31,368,-38,387,-41,388,-40,394,-42,396,-36,405,-44,423});
    states[375] = new State(new int[]{59,259,122,-130,95,-130,211,-130},new int[]{-94,376});
    states[376] = new State(-73);
    states[377] = new State(new int[]{166,312,167,313,185,314,186,315,115,-341,59,-341,122,-341,95,-341,211,-341,178,-341,173,-341,129,-341},new int[]{-79,378});
    states[378] = new State(new int[]{115,379,59,-65,122,-65,95,-65,211,-65,178,-65,173,-65,129,-65});
    states[379] = new State(-66,new int[]{-92,380});
    states[380] = new State(new int[]{221,68,45,70,43,72,40,270,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125,91,294},new int[]{-54,381,-46,269,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121,-21,278,-22,279,-23,297,-24,298});
    states[381] = new State(-67);
    states[382] = new State(-70,new int[]{-93,383});
    states[383] = new State(new int[]{123,386,211,-77},new int[]{-82,384});
    states[384] = new State(new int[]{211,373},new int[]{-32,385});
    states[385] = new State(-71);
    states[386] = new State(-76);
    states[387] = new State(-60);
    states[388] = new State(new int[]{40,389});
    states[389] = new State(-91,new int[]{-95,390});
    states[390] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-1,391,-46,393,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[391] = new State(new int[]{41,392});
    states[392] = new State(-92);
    states[393] = new State(new int[]{155,185,61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66});
    states[394] = new State(new int[]{40,-54,166,-61,167,-61,185,-61,186,-61,115,-61,59,-61,178,-61,95,-61,211,-61,173,-61,122,-61,129,-61});
    states[395] = new State(-52);
    states[396] = new State(new int[]{40,-55,166,-62,167,-62,185,-62,186,-62,115,-62,59,-62,178,-62,95,-62,211,-62,173,-62,122,-62,129,-62});
    states[397] = new State(new int[]{91,398,168,-89,175,-89,172,-89,174,-89,176,-89,177,-89,169,-89,170,-89,171,-89,128,-89,95,-89,97,-89,98,-89,101,-89,100,-89,106,-89,211,-89,212,-89,113,-89,184,-89,59,-89,166,-89,167,-89,185,-89,186,-89,115,-89,178,-89,173,-89,40,-89,122,-89,129,-89});
    states[398] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,399,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[399] = new State(new int[]{93,400,61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66});
    states[400] = new State(-87);
    states[401] = new State(new int[]{91,402,168,-90,175,-90,172,-90,174,-90,176,-90,177,-90,169,-90,170,-90,171,-90,128,-90,95,-90,97,-90,98,-90,101,-90,100,-90,106,-90,211,-90,212,-90,113,-90,184,-90,59,-90,166,-90,167,-90,185,-90,186,-90,115,-90,178,-90,173,-90,40,-90,122,-90,129,-90});
    states[402] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-46,403,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[403] = new State(new int[]{93,404,61,36,60,38,62,40,216,42,217,44,218,46,215,48,213,50,214,52,222,54,219,56,38,58,43,60,45,62,42,64,47,66});
    states[404] = new State(-88);
    states[405] = new State(-63);
    states[406] = new State(new int[]{91,407});
    states[407] = new State(new int[]{95,418,221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-30,408,-1,422,-46,393,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[408] = new State(new int[]{93,409,44,415,221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-1,417,-46,393,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[409] = new State(new int[]{120,410});
    states[410] = new State(new int[]{131,322,130,323,132,324,133,325,134,326,135,327,136,328,137,329,138,330,139,331,140,332,142,333,143,334,144,335,145,336,141,337,148,338,149,339,152,340,153,341,154,342,151,343,150,344,211,395,146,397,147,401},new int[]{-41,411,-35,412,-40,413,-42,414});
    states[411] = new State(-68);
    states[412] = new State(-53);
    states[413] = new State(-54);
    states[414] = new State(-55);
    states[415] = new State(new int[]{221,68,45,70,43,72,40,74,211,81,182,100,183,101,200,102,201,103,208,104,207,105,205,106,206,107,209,108,210,109,202,110,203,111,204,112,212,125},new int[]{-1,416,-46,393,-71,80,-70,92,-47,99,-51,113,-53,114,-52,117,-75,121});
    states[416] = new State(-17);
    states[417] = new State(-18);
    states[418] = new State(new int[]{93,419});
    states[419] = new State(new int[]{120,420});
    states[420] = new State(new int[]{131,322,130,323,132,324,133,325,134,326,135,327,136,328,137,329,138,330,139,331,140,332,142,333,143,334,144,335,145,336,141,337,148,338,149,339,152,340,153,341,154,342,151,343,150,344,211,395,146,397,147,401},new int[]{-41,421,-35,412,-40,413,-42,414});
    states[421] = new State(-69);
    states[422] = new State(-16);
    states[423] = new State(-64);
    states[424] = new State(-42);
    states[425] = new State(-43);
    states[426] = new State(-44);
    states[427] = new State(-45);
    states[428] = new State(-46);
    states[429] = new State(-47);
    states[430] = new State(-48);
    states[431] = new State(-49);
    states[432] = new State(-50);
    states[433] = new State(-51);
    states[434] = new State(new int[]{211,435});
    states[435] = new State(-14);
    states[436] = new State(-15);
    states[437] = new State(new int[]{173,438,58,-13,44,-13,211,-13});
    states[438] = new State(new int[]{212,439});
    states[439] = new State(-327,new int[]{-128,440});
    states[440] = new State(new int[]{58,441});
    states[441] = new State(new int[]{131,322,130,323,132,324,133,325,134,326,135,327,136,328,137,329,138,330,139,331,140,332,142,333,143,334,144,335,145,336,141,337,148,338,149,339,152,340,153,341,154,342,151,343,150,344,40,362,121,382,211,395,146,397,147,401,119,406,156,424,164,425,157,426,162,427,163,428,165,429,158,430,159,431,160,432,161,433},new int[]{-77,442,-43,377,-35,316,-45,345,-84,346,-39,352,-19,353,-37,367,-31,368,-38,387,-41,388,-40,394,-42,396,-36,405,-44,423});
    states[442] = new State(-328);
    states[443] = new State(new int[]{212,444});
    states[444] = new State(-329,new int[]{-129,445});
    states[445] = new State(new int[]{58,446});
    states[446] = new State(new int[]{131,322,130,323,132,324,133,325,134,326,135,327,136,328,137,329,138,330,139,331,140,332,142,333,143,334,144,335,145,336,141,337,148,338,149,339,152,340,153,341,154,342,151,343,150,344,40,362,121,382,211,395,146,397,147,401,119,406,156,424,164,425,157,426,162,427,163,428,165,429,158,430,159,431,160,432,161,433},new int[]{-77,447,-43,377,-35,316,-45,345,-84,346,-39,352,-19,353,-37,367,-31,368,-38,387,-41,388,-40,394,-42,396,-36,405,-44,423});
    states[447] = new State(-330);
    states[448] = new State(new int[]{59,259,178,-130,95,-130,211,-130,173,-130},new int[]{-94,449});
    states[449] = new State(-320);
    states[450] = new State(new int[]{178,451});
    states[451] = new State(-284);
    states[452] = new State(new int[]{179,453,211,-331,173,-331});
    states[453] = new State(-335);
    states[454] = new State(-332);
    states[455] = new State(new int[]{180,456,211,-333,173,-333});
    states[456] = new State(-334);
    states[457] = new State(-307);
    states[458] = new State(new int[]{95,462,180,452,181,454,179,455,211,-336,173,-336},new int[]{-78,459});
    states[459] = new State(-294,new int[]{-123,460});
    states[460] = new State(new int[]{211,437,173,443},new int[]{-12,461,-13,255,-11,448,-18,262});
    states[461] = new State(-295);
    states[462] = new State(new int[]{178,463});
    states[463] = new State(-296);
    states[464] = new State(-308);
    states[465] = new State(new int[]{95,469,180,452,181,454,179,455,211,-336,173,-336},new int[]{-78,466});
    states[466] = new State(-297,new int[]{-124,467});
    states[467] = new State(new int[]{211,437,173,443},new int[]{-12,468,-13,255,-11,448,-18,262});
    states[468] = new State(-298);
    states[469] = new State(new int[]{178,470});
    states[470] = new State(-299);
    states[471] = new State(-309);
    states[472] = new State(new int[]{95,476,180,452,181,454,179,455,211,-336,173,-336},new int[]{-78,473});
    states[473] = new State(-288,new int[]{-121,474});
    states[474] = new State(new int[]{211,437,173,443},new int[]{-12,475,-13,255,-11,448,-18,262});
    states[475] = new State(-289);
    states[476] = new State(new int[]{178,477});
    states[477] = new State(-290);
    states[478] = new State(-310);
    states[479] = new State(new int[]{95,483,180,452,181,454,179,455,211,-336,173,-336},new int[]{-78,480});
    states[480] = new State(-300,new int[]{-125,481});
    states[481] = new State(new int[]{211,437,173,443},new int[]{-12,482,-13,255,-11,448,-18,262});
    states[482] = new State(-301);
    states[483] = new State(new int[]{178,484});
    states[484] = new State(-302);
    states[485] = new State(-311);
    states[486] = new State(new int[]{95,490,180,452,181,454,179,455,211,-336,173,-336},new int[]{-78,487});
    states[487] = new State(-303,new int[]{-126,488});
    states[488] = new State(new int[]{211,437,173,443},new int[]{-12,489,-13,255,-11,448,-18,262});
    states[489] = new State(-304);
    states[490] = new State(new int[]{178,491});
    states[491] = new State(-305);
    states[492] = new State(-312);
    states[493] = new State(new int[]{95,497,180,452,181,454,179,455,211,-336,173,-336},new int[]{-78,494});
    states[494] = new State(-279,new int[]{-118,495});
    states[495] = new State(new int[]{211,437,173,443},new int[]{-12,496,-13,255,-11,448,-18,262});
    states[496] = new State(-280);
    states[497] = new State(new int[]{178,498});
    states[498] = new State(-281);
    states[499] = new State(-313);
    states[500] = new State(new int[]{95,504,180,452,181,454,179,455,211,-336,173,-336},new int[]{-78,501});
    states[501] = new State(-285,new int[]{-120,502});
    states[502] = new State(new int[]{211,437,173,443},new int[]{-12,503,-13,255,-11,448,-18,262});
    states[503] = new State(-286);
    states[504] = new State(new int[]{178,505});
    states[505] = new State(-287);
    states[506] = new State(-314);
    states[507] = new State(new int[]{95,511,180,452,181,454,179,455,211,-336,173,-336},new int[]{-78,508});
    states[508] = new State(-291,new int[]{-122,509});
    states[509] = new State(new int[]{211,437,173,443},new int[]{-12,510,-13,255,-11,448,-18,262});
    states[510] = new State(-292);
    states[511] = new State(new int[]{178,512});
    states[512] = new State(-293);
    states[513] = new State(-315);
    states[514] = new State(new int[]{95,525,211,-126},new int[]{-100,515,-101,527});
    states[515] = new State(new int[]{129,516,95,517,211,520},new int[]{-102,519});
    states[516] = new State(-123);
    states[517] = new State(new int[]{129,518});
    states[518] = new State(-124);
    states[519] = new State(-128);
    states[520] = new State(new int[]{58,521});
    states[521] = new State(-131,new int[]{-103,522});
    states[522] = new State(new int[]{131,322,130,323,132,324,133,325,134,326,135,327,136,328,137,329,138,330,139,331,140,332,142,333,143,334,144,335,145,336,141,337,148,338,149,339,152,340,153,341,154,342,151,343,150,344,40,362,121,382,211,395,146,397,147,401,119,406,156,424,164,425,157,426,162,427,163,428,165,429,158,430,159,431,160,432,161,433},new int[]{-77,523,-43,377,-35,316,-45,345,-84,346,-39,352,-19,353,-37,367,-31,368,-38,387,-41,388,-40,394,-42,396,-36,405,-44,423});
    states[523] = new State(new int[]{59,259,129,-130,95,-130,211,-130},new int[]{-94,524});
    states[524] = new State(-132);
    states[525] = new State(new int[]{129,526});
    states[526] = new State(-125);
    states[527] = new State(new int[]{211,520},new int[]{-102,528});
    states[528] = new State(-127);
    states[529] = new State(-316);
    states[530] = new State(-7);
    states[531] = new State(new int[]{211,532});
    states[532] = new State(-274,new int[]{-115,533});
    states[533] = new State(new int[]{168,251,175,458,172,465,174,472,176,479,177,486,169,493,170,500,171,507,128,514,95,-319,97,-319,98,-319,101,-319,100,-319,106,-319,211,-319,212,-319,113,-319,184,-319,59,-319},new int[]{-73,534,-74,248,-69,529,-59,250,-60,457,-61,464,-62,471,-63,478,-64,485,-65,492,-66,499,-67,506,-68,513});
    states[534] = new State(-275,new int[]{-116,535});
    states[535] = new State(new int[]{95,232,97,-189,98,-189,101,-189,100,-189,106,-189,211,-189,212,-189,113,-189,184,-189,59,-189},new int[]{-8,536,-2,537,-105,201});
    states[536] = new State(-276);
    states[537] = new State(new int[]{127,538,95,539,97,21,98,28,101,135,100,144,106,154,211,81,212,125,113,172,184,173,59,-206},new int[]{-26,17,-27,166,-51,167,-53,114,-52,117,-75,121,-71,175,-70,92});
    states[538] = new State(-267);
    states[539] = new State(new int[]{127,540});
    states[540] = new State(-268);
    states[541] = new State(-8);
    states[542] = new State(new int[]{211,543});
    states[543] = new State(-277,new int[]{-117,544});
    states[544] = new State(new int[]{168,251,175,458,172,465,174,472,176,479,177,486,169,493,170,500,171,507,128,514,95,-319,97,-319,98,-319,101,-319,100,-319,106,-319,211,-319,212,-319,113,-319,184,-319,59,-319},new int[]{-73,545,-74,248,-69,529,-59,250,-60,457,-61,464,-62,471,-63,478,-64,485,-65,492,-66,499,-67,506,-68,513});
    states[545] = new State(new int[]{95,232,97,-189,98,-189,101,-189,100,-189,106,-189,211,-189,212,-189,113,-189,184,-189,59,-189},new int[]{-9,546,-2,547,-105,201});
    states[546] = new State(-278);
    states[547] = new State(new int[]{118,548,95,549,97,21,98,28,101,135,100,144,106,154,211,81,212,125,113,172,184,173,59,-206},new int[]{-26,17,-27,166,-51,167,-53,114,-52,117,-75,121,-71,175,-70,92});
    states[548] = new State(-269);
    states[549] = new State(new int[]{118,550});
    states[550] = new State(-270);
    states[551] = new State(-9);
    states[552] = new State(-4);

    for (int sNo = 0; sNo < states.Length; sNo++) states[sNo].number = sNo;

    rules[1] = new Rule(-86, new int[]{-85,96});
    rules[2] = new Rule(-87, new int[]{});
    rules[3] = new Rule(-85, new int[]{-87,-88});
    rules[4] = new Rule(-88, new int[]{-89});
    rules[5] = new Rule(-88, new int[]{-88,-89});
    rules[6] = new Rule(-89, new int[]{-34});
    rules[7] = new Rule(-89, new int[]{-90});
    rules[8] = new Rule(-89, new int[]{-91});
    rules[9] = new Rule(-89, new int[]{-68});
    rules[10] = new Rule(-81, new int[]{115});
    rules[11] = new Rule(-81, new int[]{116});
    rules[12] = new Rule(-1, new int[]{-46,155,-46});
    rules[13] = new Rule(-18, new int[]{211});
    rules[14] = new Rule(-18, new int[]{-18,44,211});
    rules[15] = new Rule(-18, new int[]{-18,211});
    rules[16] = new Rule(-30, new int[]{-1});
    rules[17] = new Rule(-30, new int[]{-30,44,-1});
    rules[18] = new Rule(-30, new int[]{-30,-1});
    rules[19] = new Rule(-35, new int[]{131});
    rules[20] = new Rule(-35, new int[]{130});
    rules[21] = new Rule(-35, new int[]{132});
    rules[22] = new Rule(-35, new int[]{133});
    rules[23] = new Rule(-35, new int[]{134});
    rules[24] = new Rule(-35, new int[]{135});
    rules[25] = new Rule(-35, new int[]{136});
    rules[26] = new Rule(-35, new int[]{137});
    rules[27] = new Rule(-35, new int[]{138});
    rules[28] = new Rule(-35, new int[]{139});
    rules[29] = new Rule(-35, new int[]{140});
    rules[30] = new Rule(-35, new int[]{142});
    rules[31] = new Rule(-35, new int[]{143});
    rules[32] = new Rule(-35, new int[]{144});
    rules[33] = new Rule(-35, new int[]{145});
    rules[34] = new Rule(-35, new int[]{141});
    rules[35] = new Rule(-35, new int[]{148});
    rules[36] = new Rule(-35, new int[]{149});
    rules[37] = new Rule(-35, new int[]{152});
    rules[38] = new Rule(-35, new int[]{153});
    rules[39] = new Rule(-35, new int[]{154});
    rules[40] = new Rule(-35, new int[]{151});
    rules[41] = new Rule(-35, new int[]{150});
    rules[42] = new Rule(-44, new int[]{156});
    rules[43] = new Rule(-44, new int[]{164});
    rules[44] = new Rule(-44, new int[]{157});
    rules[45] = new Rule(-44, new int[]{162});
    rules[46] = new Rule(-44, new int[]{163});
    rules[47] = new Rule(-44, new int[]{165});
    rules[48] = new Rule(-44, new int[]{158});
    rules[49] = new Rule(-44, new int[]{159});
    rules[50] = new Rule(-44, new int[]{160});
    rules[51] = new Rule(-44, new int[]{161});
    rules[52] = new Rule(-40, new int[]{211});
    rules[53] = new Rule(-41, new int[]{-35});
    rules[54] = new Rule(-41, new int[]{-40});
    rules[55] = new Rule(-41, new int[]{-42});
    rules[56] = new Rule(-43, new int[]{-35});
    rules[57] = new Rule(-43, new int[]{-45});
    rules[58] = new Rule(-43, new int[]{-39});
    rules[59] = new Rule(-43, new int[]{-37});
    rules[60] = new Rule(-43, new int[]{-38});
    rules[61] = new Rule(-43, new int[]{-40});
    rules[62] = new Rule(-43, new int[]{-42});
    rules[63] = new Rule(-43, new int[]{-36});
    rules[64] = new Rule(-43, new int[]{-44});
    rules[65] = new Rule(-77, new int[]{-43,-79});
    rules[66] = new Rule(-92, new int[]{});
    rules[67] = new Rule(-77, new int[]{-43,-79,115,-92,-54});
    rules[68] = new Rule(-36, new int[]{119,91,-30,93,120,-41});
    rules[69] = new Rule(-36, new int[]{119,91,95,93,120,-41});
    rules[70] = new Rule(-93, new int[]{});
    rules[71] = new Rule(-31, new int[]{121,-93,-82,-32});
    rules[72] = new Rule(-31, new int[]{-31,-32});
    rules[73] = new Rule(-32, new int[]{211,58,-77,-94});
    rules[74] = new Rule(-37, new int[]{-31,122});
    rules[75] = new Rule(-37, new int[]{-31,95,122});
    rules[76] = new Rule(-82, new int[]{123});
    rules[77] = new Rule(-82, new int[]{});
    rules[78] = new Rule(-80, new int[]{211});
    rules[79] = new Rule(-80, new int[]{204});
    rules[80] = new Rule(-19, new int[]{40,-80});
    rules[81] = new Rule(-19, new int[]{-19,44,-80});
    rules[82] = new Rule(-19, new int[]{-19,-80});
    rules[83] = new Rule(-39, new int[]{-19,41});
    rules[84] = new Rule(-39, new int[]{-19,95,41});
    rules[85] = new Rule(-39, new int[]{40,95,41});
    rules[86] = new Rule(-39, new int[]{40,41});
    rules[87] = new Rule(-42, new int[]{146,91,-46,93});
    rules[88] = new Rule(-42, new int[]{147,91,-46,93});
    rules[89] = new Rule(-42, new int[]{146});
    rules[90] = new Rule(-42, new int[]{147});
    rules[91] = new Rule(-95, new int[]{});
    rules[92] = new Rule(-38, new int[]{-41,40,-95,-1,41});
    rules[93] = new Rule(-45, new int[]{-84,41});
    rules[94] = new Rule(-45, new int[]{-84,95,41});
    rules[95] = new Rule(-84, new int[]{-35,40,-83});
    rules[96] = new Rule(-84, new int[]{-84,44,-83});
    rules[97] = new Rule(-83, new int[]{211,115,-46});
    rules[98] = new Rule(-96, new int[]{});
    rules[99] = new Rule(-22, new int[]{91,-96,-58});
    rules[100] = new Rule(-22, new int[]{-22,44,-58});
    rules[101] = new Rule(-24, new int[]{40,-58});
    rules[102] = new Rule(-24, new int[]{-24,44,-58});
    rules[103] = new Rule(-21, new int[]{-22,93});
    rules[104] = new Rule(-21, new int[]{-22,95,93});
    rules[105] = new Rule(-21, new int[]{91,95,93});
    rules[106] = new Rule(-21, new int[]{91,93});
    rules[107] = new Rule(-23, new int[]{-24,41});
    rules[108] = new Rule(-23, new int[]{-24,95,41});
    rules[109] = new Rule(-23, new int[]{40,41});
    rules[110] = new Rule(-58, new int[]{-54});
    rules[111] = new Rule(-97, new int[]{});
    rules[112] = new Rule(-58, new int[]{200,40,-97,95,41});
    rules[113] = new Rule(-98, new int[]{});
    rules[114] = new Rule(-58, new int[]{200,40,-98,-25,41});
    rules[115] = new Rule(-99, new int[]{});
    rules[116] = new Rule(-58, new int[]{211,-99,115,-54});
    rules[117] = new Rule(-25, new int[]{-58});
    rules[118] = new Rule(-25, new int[]{-25,44,-58});
    rules[119] = new Rule(-25, new int[]{-25,95,-58});
    rules[120] = new Rule(-54, new int[]{-46});
    rules[121] = new Rule(-54, new int[]{-21});
    rules[122] = new Rule(-54, new int[]{-23});
    rules[123] = new Rule(-68, new int[]{128,-100,129});
    rules[124] = new Rule(-68, new int[]{128,-100,95,129});
    rules[125] = new Rule(-68, new int[]{128,95,129});
    rules[126] = new Rule(-101, new int[]{});
    rules[127] = new Rule(-100, new int[]{-101,-102});
    rules[128] = new Rule(-100, new int[]{-100,-102});
    rules[129] = new Rule(-94, new int[]{59});
    rules[130] = new Rule(-94, new int[]{});
    rules[131] = new Rule(-103, new int[]{});
    rules[132] = new Rule(-102, new int[]{211,58,-103,-77,-94});
    rules[133] = new Rule(-47, new int[]{182});
    rules[134] = new Rule(-47, new int[]{183});
    rules[135] = new Rule(-47, new int[]{200});
    rules[136] = new Rule(-47, new int[]{201});
    rules[137] = new Rule(-47, new int[]{208});
    rules[138] = new Rule(-47, new int[]{207});
    rules[139] = new Rule(-47, new int[]{205});
    rules[140] = new Rule(-47, new int[]{206});
    rules[141] = new Rule(-47, new int[]{209});
    rules[142] = new Rule(-47, new int[]{210});
    rules[143] = new Rule(-47, new int[]{202});
    rules[144] = new Rule(-47, new int[]{203});
    rules[145] = new Rule(-47, new int[]{204});
    rules[146] = new Rule(-51, new int[]{-53});
    rules[147] = new Rule(-51, new int[]{212});
    rules[148] = new Rule(-53, new int[]{-52});
    rules[149] = new Rule(-53, new int[]{-75,93});
    rules[150] = new Rule(-53, new int[]{-52,91,95,93});
    rules[151] = new Rule(-104, new int[]{});
    rules[152] = new Rule(-75, new int[]{-52,91,-104,-46});
    rules[153] = new Rule(-75, new int[]{-75,44,-46});
    rules[154] = new Rule(-52, new int[]{211});
    rules[155] = new Rule(-52, new int[]{-53,46,211});
    rules[156] = new Rule(-46, new int[]{221,-46});
    rules[157] = new Rule(-46, new int[]{45,-46});
    rules[158] = new Rule(-46, new int[]{43,-46});
    rules[159] = new Rule(-46, new int[]{-46,61,-46});
    rules[160] = new Rule(-46, new int[]{-46,60,-46});
    rules[161] = new Rule(-46, new int[]{-46,62,-46});
    rules[162] = new Rule(-46, new int[]{-46,216,-46});
    rules[163] = new Rule(-46, new int[]{-46,217,-46});
    rules[164] = new Rule(-46, new int[]{-46,218,-46});
    rules[165] = new Rule(-46, new int[]{-46,215,-46});
    rules[166] = new Rule(-46, new int[]{-46,213,-46});
    rules[167] = new Rule(-46, new int[]{-46,214,-46});
    rules[168] = new Rule(-46, new int[]{-46,222,-46});
    rules[169] = new Rule(-46, new int[]{-46,219,-46});
    rules[170] = new Rule(-46, new int[]{-46,38,-46});
    rules[171] = new Rule(-46, new int[]{-46,43,-46});
    rules[172] = new Rule(-46, new int[]{-46,45,-46});
    rules[173] = new Rule(-46, new int[]{-46,42,-46});
    rules[174] = new Rule(-46, new int[]{-46,47,-46});
    rules[175] = new Rule(-46, new int[]{40,-46,41});
    rules[176] = new Rule(-46, new int[]{40,-46,95});
    rules[177] = new Rule(-46, new int[]{-71});
    rules[178] = new Rule(-46, new int[]{-47});
    rules[179] = new Rule(-46, new int[]{-51});
    rules[180] = new Rule(-46, new int[]{40,95,41});
    rules[181] = new Rule(-72, new int[]{-46});
    rules[182] = new Rule(-72, new int[]{211,-81,-46});
    rules[183] = new Rule(-72, new int[]{221,211,-81,-46});
    rules[184] = new Rule(-70, new int[]{211,40,-72});
    rules[185] = new Rule(-70, new int[]{-70,44,-72});
    rules[186] = new Rule(-71, new int[]{211,40,41});
    rules[187] = new Rule(-71, new int[]{211,40,95,41});
    rules[188] = new Rule(-71, new int[]{-70,41});
    rules[189] = new Rule(-105, new int[]{});
    rules[190] = new Rule(-2, new int[]{-105,-26,59});
    rules[191] = new Rule(-2, new int[]{-2,-26,59});
    rules[192] = new Rule(-2, new int[]{95,59});
    rules[193] = new Rule(-26, new int[]{97,-48,-4});
    rules[194] = new Rule(-106, new int[]{});
    rules[195] = new Rule(-26, new int[]{98,-106,-28});
    rules[196] = new Rule(-107, new int[]{});
    rules[197] = new Rule(-26, new int[]{101,-49,-2,-107,-15,-3,111});
    rules[198] = new Rule(-108, new int[]{});
    rules[199] = new Rule(-26, new int[]{100,-56,-81,-76,-108,-5});
    rules[200] = new Rule(-26, new int[]{106,-50,-16,107});
    rules[201] = new Rule(-26, new int[]{-27});
    rules[202] = new Rule(-26, new int[]{113});
    rules[203] = new Rule(-26, new int[]{184});
    rules[204] = new Rule(-26, new int[]{184,-46});
    rules[205] = new Rule(-26, new int[]{-71});
    rules[206] = new Rule(-26, new int[]{});
    rules[207] = new Rule(-4, new int[]{-2,110});
    rules[208] = new Rule(-4, new int[]{-2,95,110});
    rules[209] = new Rule(-4, new int[]{95,110});
    rules[210] = new Rule(-28, new int[]{-2,99,-55});
    rules[211] = new Rule(-28, new int[]{-2,95,99,-55});
    rules[212] = new Rule(-28, new int[]{95,112});
    rules[213] = new Rule(-5, new int[]{-2,109});
    rules[214] = new Rule(-5, new int[]{-2,95,109});
    rules[215] = new Rule(-5, new int[]{95,109});
    rules[216] = new Rule(-48, new int[]{-46,103});
    rules[217] = new Rule(-48, new int[]{95,103});
    rules[218] = new Rule(-48, new int[]{-46});
    rules[219] = new Rule(-49, new int[]{-46,104});
    rules[220] = new Rule(-49, new int[]{95,104});
    rules[221] = new Rule(-49, new int[]{-46});
    rules[222] = new Rule(-55, new int[]{-46,112});
    rules[223] = new Rule(-55, new int[]{95,112});
    rules[224] = new Rule(-55, new int[]{-46});
    rules[225] = new Rule(-50, new int[]{-46,120});
    rules[226] = new Rule(-50, new int[]{95,120});
    rules[227] = new Rule(-50, new int[]{-46});
    rules[228] = new Rule(-56, new int[]{-51});
    rules[229] = new Rule(-109, new int[]{});
    rules[230] = new Rule(-76, new int[]{-46,102,-109,-46,-57,103});
    rules[231] = new Rule(-110, new int[]{});
    rules[232] = new Rule(-76, new int[]{95,102,-110,-46,-57,103});
    rules[233] = new Rule(-76, new int[]{-46,102,95,103});
    rules[234] = new Rule(-76, new int[]{95,103});
    rules[235] = new Rule(-111, new int[]{});
    rules[236] = new Rule(-57, new int[]{114,-111,-46});
    rules[237] = new Rule(-57, new int[]{});
    rules[238] = new Rule(-3, new int[]{105,-2});
    rules[239] = new Rule(-3, new int[]{105,95});
    rules[240] = new Rule(-3, new int[]{});
    rules[241] = new Rule(-15, new int[]{-14});
    rules[242] = new Rule(-15, new int[]{});
    rules[243] = new Rule(-6, new int[]{105,-10});
    rules[244] = new Rule(-6, new int[]{105,-10,95});
    rules[245] = new Rule(-112, new int[]{});
    rules[246] = new Rule(-10, new int[]{-112,-26,59});
    rules[247] = new Rule(-10, new int[]{-10,-26,59});
    rules[248] = new Rule(-10, new int[]{95,59});
    rules[249] = new Rule(-33, new int[]{199,-20,58,-10});
    rules[250] = new Rule(-33, new int[]{199,95,58,-10});
    rules[251] = new Rule(-33, new int[]{199,-20,-10});
    rules[252] = new Rule(-33, new int[]{-6});
    rules[253] = new Rule(-17, new int[]{-33});
    rules[254] = new Rule(-17, new int[]{-17,-33});
    rules[255] = new Rule(-16, new int[]{-17});
    rules[256] = new Rule(-16, new int[]{});
    rules[257] = new Rule(-29, new int[]{-46});
    rules[258] = new Rule(-29, new int[]{-1});
    rules[259] = new Rule(-20, new int[]{-29});
    rules[260] = new Rule(-20, new int[]{-20,44,-29});
    rules[261] = new Rule(-14, new int[]{108,-49,-2});
    rules[262] = new Rule(-14, new int[]{-14,108,-49,-2});
    rules[263] = new Rule(-27, new int[]{-51,115,-46});
    rules[264] = new Rule(-27, new int[]{-51,61,-46});
    rules[265] = new Rule(-7, new int[]{-2,125});
    rules[266] = new Rule(-7, new int[]{-2,95,125});
    rules[267] = new Rule(-8, new int[]{-2,127});
    rules[268] = new Rule(-8, new int[]{-2,95,127});
    rules[269] = new Rule(-9, new int[]{-2,118});
    rules[270] = new Rule(-9, new int[]{-2,95,118});
    rules[271] = new Rule(-113, new int[]{});
    rules[272] = new Rule(-114, new int[]{});
    rules[273] = new Rule(-34, new int[]{124,211,58,-41,-113,-73,-114,-7});
    rules[274] = new Rule(-115, new int[]{});
    rules[275] = new Rule(-116, new int[]{});
    rules[276] = new Rule(-90, new int[]{126,211,-115,-73,-116,-8});
    rules[277] = new Rule(-117, new int[]{});
    rules[278] = new Rule(-91, new int[]{117,211,-117,-73,-9});
    rules[279] = new Rule(-118, new int[]{});
    rules[280] = new Rule(-65, new int[]{169,-78,-118,-12});
    rules[281] = new Rule(-65, new int[]{169,95,178});
    rules[282] = new Rule(-119, new int[]{});
    rules[283] = new Rule(-59, new int[]{168,-78,-119,-12});
    rules[284] = new Rule(-59, new int[]{168,95,178});
    rules[285] = new Rule(-120, new int[]{});
    rules[286] = new Rule(-66, new int[]{170,-78,-120,-12});
    rules[287] = new Rule(-66, new int[]{170,95,178});
    rules[288] = new Rule(-121, new int[]{});
    rules[289] = new Rule(-62, new int[]{174,-78,-121,-12});
    rules[290] = new Rule(-62, new int[]{174,95,178});
    rules[291] = new Rule(-122, new int[]{});
    rules[292] = new Rule(-67, new int[]{171,-78,-122,-12});
    rules[293] = new Rule(-67, new int[]{171,95,178});
    rules[294] = new Rule(-123, new int[]{});
    rules[295] = new Rule(-60, new int[]{175,-78,-123,-12});
    rules[296] = new Rule(-60, new int[]{175,95,178});
    rules[297] = new Rule(-124, new int[]{});
    rules[298] = new Rule(-61, new int[]{172,-78,-124,-12});
    rules[299] = new Rule(-61, new int[]{172,95,178});
    rules[300] = new Rule(-125, new int[]{});
    rules[301] = new Rule(-63, new int[]{176,-78,-125,-12});
    rules[302] = new Rule(-63, new int[]{176,95,178});
    rules[303] = new Rule(-126, new int[]{});
    rules[304] = new Rule(-64, new int[]{177,-78,-126,-12});
    rules[305] = new Rule(-64, new int[]{177,95,178});
    rules[306] = new Rule(-69, new int[]{-59});
    rules[307] = new Rule(-69, new int[]{-60});
    rules[308] = new Rule(-69, new int[]{-61});
    rules[309] = new Rule(-69, new int[]{-62});
    rules[310] = new Rule(-69, new int[]{-63});
    rules[311] = new Rule(-69, new int[]{-64});
    rules[312] = new Rule(-69, new int[]{-65});
    rules[313] = new Rule(-69, new int[]{-66});
    rules[314] = new Rule(-69, new int[]{-67});
    rules[315] = new Rule(-69, new int[]{-68});
    rules[316] = new Rule(-74, new int[]{-69});
    rules[317] = new Rule(-74, new int[]{-74,-69});
    rules[318] = new Rule(-73, new int[]{-74});
    rules[319] = new Rule(-73, new int[]{});
    rules[320] = new Rule(-13, new int[]{-11,-94});
    rules[321] = new Rule(-13, new int[]{-13,-11,-94});
    rules[322] = new Rule(-12, new int[]{-13,178});
    rules[323] = new Rule(-12, new int[]{-13,95,178});
    rules[324] = new Rule(-11, new int[]{-18,58,-43,-79});
    rules[325] = new Rule(-127, new int[]{});
    rules[326] = new Rule(-11, new int[]{-18,58,-43,-79,-127,115,-54});
    rules[327] = new Rule(-128, new int[]{});
    rules[328] = new Rule(-11, new int[]{211,173,212,-128,58,-77});
    rules[329] = new Rule(-129, new int[]{});
    rules[330] = new Rule(-11, new int[]{173,212,-129,58,-77});
    rules[331] = new Rule(-78, new int[]{180});
    rules[332] = new Rule(-78, new int[]{181});
    rules[333] = new Rule(-78, new int[]{179});
    rules[334] = new Rule(-78, new int[]{179,180});
    rules[335] = new Rule(-78, new int[]{180,179});
    rules[336] = new Rule(-78, new int[]{});
    rules[337] = new Rule(-79, new int[]{166});
    rules[338] = new Rule(-79, new int[]{167});
    rules[339] = new Rule(-79, new int[]{185});
    rules[340] = new Rule(-79, new int[]{186});
    rules[341] = new Rule(-79, new int[]{});
  }

  protected override void Initialize() {
    this.InitSpecialTokens((int)Tokens.error, (int)Tokens.EOF);
    this.InitStates(states);
    this.InitRules(rules);
    this.InitNonTerminals(nonTerms);
  }

  protected override void DoAction(int action)
  {
#pragma warning disable 162, 1522
    switch (action)
    {
      case 2: // Anon@1 -> /* empty */
{this.PushSymbolTable();}
        break;
      case 3: // main -> Anon@1, pou_declarations
{this.PopSymbolTable();}
        break;
      case 6: // pou_declaration -> function_decl
{this.ReInitializeParser();}
        break;
      case 7: // pou_declaration -> function_block_decl
{this.ReInitializeParser();}
        break;
      case 8: // pou_declaration -> program_decl
{this.ReInitializeParser();}
        break;
      case 10: // assign -> ASSIGN
{CurrentSemanticValue.Token = Tokens.ASSIGN;}
        break;
      case 11: // assign -> OUTPUT_ASSIGN
{CurrentSemanticValue.Token = Tokens.OUTPUT_ASSIGN;}
        break;
      case 12: // subrange -> expression, DOTDOT, expression
{CurrentSemanticValue.Subrange = this.MakeSubrange(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3], LocationStack[LocationStack.Depth-1]);}
        break;
      case 13: // identifier_list -> IDENT
{CurrentSemanticValue.IdentifierList = this.MakeIdentifierList(ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
        break;
      case 14: // identifier_list -> identifier_list, ',', IDENT
{CurrentSemanticValue.IdentifierList = this.AddIdentToList(ValueStack[ValueStack.Depth-3].IdentifierList, ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
        break;
      case 15: // identifier_list -> identifier_list, IDENT
{CurrentSemanticValue.IdentifierList = this.AddIdentToList(ValueStack[ValueStack.Depth-2].IdentifierList, ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);this.report.SyntaxError(75, LocationStack[LocationStack.Depth-1]);}
        break;
      case 16: // subrange_list -> subrange
{CurrentSemanticValue.Subranges = this.MakeSubRangeList(ValueStack[ValueStack.Depth-1].Subrange, LocationStack[LocationStack.Depth-1]);}
        break;
      case 17: // subrange_list -> subrange_list, ',', subrange
{CurrentSemanticValue.Subranges = this.AddSubRange(ValueStack[ValueStack.Depth-3].Subranges, ValueStack[ValueStack.Depth-1].Subrange, LocationStack[LocationStack.Depth-1]); }
        break;
      case 18: // subrange_list -> subrange_list, subrange
{CurrentSemanticValue.Subranges = this.AddSubRange(ValueStack[ValueStack.Depth-2].Subranges, ValueStack[ValueStack.Depth-1].Subrange, LocationStack[LocationStack.Depth-1]);this.report.SyntaxError(75, LocationStack[LocationStack.Depth-1]);}
        break;
      case 19: // elementary_type -> SINT
{CurrentSemanticValue.DataType = TypeNode.SInt;}
        break;
      case 20: // elementary_type -> INT
{CurrentSemanticValue.DataType = TypeNode.Int;}
        break;
      case 21: // elementary_type -> DINT
{CurrentSemanticValue.DataType = TypeNode.DInt;}
        break;
      case 22: // elementary_type -> LINT
{CurrentSemanticValue.DataType = TypeNode.LInt;}
        break;
      case 23: // elementary_type -> USINT
{CurrentSemanticValue.DataType = TypeNode.USInt;}
        break;
      case 24: // elementary_type -> UINT
{CurrentSemanticValue.DataType = TypeNode.UInt;}
        break;
      case 25: // elementary_type -> UDINT
{CurrentSemanticValue.DataType = TypeNode.UDInt;}
        break;
      case 26: // elementary_type -> ULINT
{CurrentSemanticValue.DataType = TypeNode.ULInt;}
        break;
      case 27: // elementary_type -> REAL
{CurrentSemanticValue.DataType = TypeNode.Real;}
        break;
      case 28: // elementary_type -> LREAL
{CurrentSemanticValue.DataType = TypeNode.LReal;}
        break;
      case 29: // elementary_type -> DATE
{CurrentSemanticValue.DataType = TypeNode.Date;}
        break;
      case 30: // elementary_type -> TIME_OF_DAY
{CurrentSemanticValue.DataType = TypeNode.TimeOfDay;}
        break;
      case 31: // elementary_type -> TOD
{CurrentSemanticValue.DataType = TypeNode.TimeOfDay;}
        break;
      case 32: // elementary_type -> DATE_AND_TIME
{CurrentSemanticValue.DataType = TypeNode.DateAndTime;}
        break;
      case 33: // elementary_type -> DT
{CurrentSemanticValue.DataType = TypeNode.DateAndTime;}
        break;
      case 34: // elementary_type -> TIME
{CurrentSemanticValue.DataType = TypeNode.Time;}
        break;
      case 35: // elementary_type -> BOOL
{CurrentSemanticValue.DataType = TypeNode.Bool;}
        break;
      case 36: // elementary_type -> BYTE
{CurrentSemanticValue.DataType = TypeNode.Byte;}
        break;
      case 37: // elementary_type -> WORD
{CurrentSemanticValue.DataType = TypeNode.Word;}
        break;
      case 38: // elementary_type -> DWORD
{CurrentSemanticValue.DataType = TypeNode.DWord;}
        break;
      case 39: // elementary_type -> LWORD
{CurrentSemanticValue.DataType = TypeNode.LWord;}
        break;
      case 40: // elementary_type -> WCHAR
{CurrentSemanticValue.DataType = TypeNode.WChar;}
        break;
      case 41: // elementary_type -> CHAR
{CurrentSemanticValue.DataType = TypeNode.Char;}
        break;
      case 42: // generic_type -> ANY
{CurrentSemanticValue.DataType = TypeNode.Any;}
        break;
      case 43: // generic_type -> ANY_NUM
{CurrentSemanticValue.DataType = TypeNode.AnyNum;}
        break;
      case 44: // generic_type -> ANY_INT
{CurrentSemanticValue.DataType = TypeNode.AnyInt;}
        break;
      case 45: // generic_type -> ANY_REAL
{CurrentSemanticValue.DataType = TypeNode.AnyReal;}
        break;
      case 46: // generic_type -> ANY_BIT
{CurrentSemanticValue.DataType = TypeNode.AnyBit;}
        break;
      case 47: // generic_type -> ANY_DATE
{CurrentSemanticValue.DataType = TypeNode.AnyDate;}
        break;
      case 48: // generic_type -> ANY_DERIVED
{CurrentSemanticValue.DataType = TypeNode.AnyDerived;}
        break;
      case 49: // generic_type -> ANY_ELEMENTARY
{CurrentSemanticValue.DataType = TypeNode.AnyElementary;}
        break;
      case 50: // generic_type -> ANY_MAGNITUDE
{CurrentSemanticValue.DataType = TypeNode.AnyMagnitude;}
        break;
      case 51: // generic_type -> ANY_STRING
{CurrentSemanticValue.DataType = TypeNode.AnyString;}
        break;
      case 52: // derived_type -> IDENT
{CurrentSemanticValue.DataType = this.GetDerivedType(ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
        break;
      case 64: // data_type -> generic_type
{CurrentSemanticValue.DataType = TypeNode.Error; this.report.SemanticError(51, LocationStack[LocationStack.Depth-1]);}
        break;
      case 65: // data_type_spec -> data_type, opt_decl_qualifier
{CurrentSemanticValue.TypeSpec = this.MakeDataTypeSpec(ValueStack[ValueStack.Depth-2].DataType, ValueStack[ValueStack.Depth-1].EdgeQualifier, LocationStack[LocationStack.Depth-1]);}
        break;
      case 66: // Anon@2 -> /* empty */
{this.Push(ValueStack[ValueStack.Depth-3].DataType);}
        break;
      case 67: // data_type_spec -> data_type, opt_decl_qualifier, ASSIGN, Anon@2, initial_value
{CurrentSemanticValue.TypeSpec = this.MakeDataTypeSpec(ValueStack[ValueStack.Depth-5].DataType, ValueStack[ValueStack.Depth-4].EdgeQualifier, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-4]);}
        break;
      case 68: // array_type -> ARRAY, '[', subrange_list, ']', OF, non_generic_type
{CurrentSemanticValue.DataType = this.MakeArrayType(ValueStack[ValueStack.Depth-4].Subranges, ValueStack[ValueStack.Depth-1].DataType, LocationStack[LocationStack.Depth-4], LocationStack[LocationStack.Depth-1]);}
        break;
      case 69: // array_type -> ARRAY, '[', error, ']', OF, non_generic_type
{CurrentSemanticValue.DataType = TypeNode.Error; this.yyerrok();}
        break;
      case 70: // Anon@3 -> /* empty */
{this.CheckNestingDepth(LocationStack[LocationStack.Depth-1]);}
        break;
      case 71: // struct_member_decls -> STRUCT, Anon@3, opt_overlap_spec, struct_member_decl
{CurrentSemanticValue.StructDecl = this.MakeStructMemberList(ValueStack[ValueStack.Depth-1].MemberDecl);}
        break;
      case 72: // struct_member_decls -> struct_member_decls, struct_member_decl
{CurrentSemanticValue.StructDecl = this.AddStructMemberDecl(ValueStack[ValueStack.Depth-2].StructDecl, ValueStack[ValueStack.Depth-1].MemberDecl, LocationStack[LocationStack.Depth-1]);}
        break;
      case 73: // struct_member_decl -> IDENT, ':', data_type_spec, semicolon
{CurrentSemanticValue.MemberDecl = this.MakeStructMemberDecl(ValueStack[ValueStack.Depth-4].Ident, ValueStack[ValueStack.Depth-2].TypeSpec, LocationStack[LocationStack.Depth-4]);}
        break;
      case 74: // structure_type -> struct_member_decls, END_STRUCT
{CurrentSemanticValue.DataType = this.MakeStructDataType(ValueStack[ValueStack.Depth-2].StructDecl);}
        break;
      case 75: // structure_type -> struct_member_decls, error, END_STRUCT
{CurrentSemanticValue.DataType = this.MakeStructDataType(ValueStack[ValueStack.Depth-3].StructDecl); this.yyerrok();}
        break;
      case 76: // opt_overlap_spec -> OVERLAP
{CurrentSemanticValue.Boolean = true;}
        break;
      case 77: // opt_overlap_spec -> /* empty */
{CurrentSemanticValue.Boolean = false;}
        break;
      case 78: // enum_identifier -> IDENT
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].Ident;}
        break;
      case 79: // enum_identifier -> TYPED_ENUM
{CurrentSemanticValue.Ident = ValueStack[ValueStack.Depth-1].TypedEnum.Value; this.report.SyntaxError(169, ValueStack[ValueStack.Depth-1].TypedEnum.ToString(), LocationStack[LocationStack.Depth-1]);}
        break;
      case 80: // enum_ident_seq -> '(', enum_identifier
{CurrentSemanticValue.IdentifierList = this.MakeEnumIdentList(ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
        break;
      case 81: // enum_ident_seq -> enum_ident_seq, ',', enum_identifier
{CurrentSemanticValue.IdentifierList = this.AddToEnumIdentList(ValueStack[ValueStack.Depth-3].IdentifierList, ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
        break;
      case 82: // enum_ident_seq -> enum_ident_seq, enum_identifier
{CurrentSemanticValue.IdentifierList = this.AddToEnumIdentList(ValueStack[ValueStack.Depth-2].IdentifierList, ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]); this.report.SyntaxError(75, LocationStack[LocationStack.Depth-1]);}
        break;
      case 83: // enumerated_type -> enum_ident_seq, ')'
{CurrentSemanticValue.DataType = this.MakeEnumeratedType(ValueStack[ValueStack.Depth-2].IdentifierList);}
        break;
      case 84: // enumerated_type -> enum_ident_seq, error, ')'
{CurrentSemanticValue.DataType = this.MakeEnumeratedType(ValueStack[ValueStack.Depth-3].IdentifierList); this.yyerrok();}
        break;
      case 85: // enumerated_type -> '(', error, ')'
{CurrentSemanticValue.DataType = TypeNode.Error;this.yyerrok();}
        break;
      case 86: // enumerated_type -> '(', ')'
{CurrentSemanticValue.DataType = TypeNode.Error; this.report.SyntaxError(166, LocationStack[LocationStack.Depth-2]);}
        break;
      case 87: // string_type -> STRING, '[', expression, ']'
{CurrentSemanticValue.DataType = this.MakeStringType(ValueStack[ValueStack.Depth-2].Expression, LocationStack[LocationStack.Depth-4]);}
        break;
      case 88: // string_type -> WSTRING, '[', expression, ']'
{CurrentSemanticValue.DataType = this.MakeWStringType(ValueStack[ValueStack.Depth-2].Expression, LocationStack[LocationStack.Depth-4]);}
        break;
      case 89: // string_type -> STRING
{CurrentSemanticValue.DataType = TypeNode.String;}
        break;
      case 90: // string_type -> WSTRING
{CurrentSemanticValue.DataType = TypeNode.WString;}
        break;
      case 91: // Anon@4 -> /* empty */
{this.SubrangeTypeStart(ValueStack[ValueStack.Depth-2].DataType);}
        break;
      case 92: // subrange_type -> non_generic_type, '(', Anon@4, subrange, ')'
{CurrentSemanticValue.DataType = this.MakeSubrangeType(ValueStack[ValueStack.Depth-5].DataType, ValueStack[ValueStack.Depth-2].Subrange, LocationStack[LocationStack.Depth-2]);}
        break;
      case 95: // namedvalue_list -> elementary_type, '(', named_value
{CurrentSemanticValue.NamedValueList = this.MakeNamedValueList(ValueStack[ValueStack.Depth-3].DataType, ValueStack[ValueStack.Depth-1].NamedValue);}
        break;
      case 96: // namedvalue_list -> namedvalue_list, ',', named_value
{CurrentSemanticValue.NamedValueList = this.AddNamedValue(ValueStack[ValueStack.Depth-3].NamedValueList, ValueStack[ValueStack.Depth-1].NamedValue);}
        break;
      case 97: // named_value -> IDENT, ASSIGN, expression
{CurrentSemanticValue.NamedValue = this.MakeNamedValue(ValueStack[ValueStack.Depth-3].Ident, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3], LocationStack[LocationStack.Depth-1]);}
        break;
      case 98: // Anon@5 -> /* empty */
{this.PushArrayElemType(LocationStack[LocationStack.Depth-1]);}
        break;
      case 99: // array_init_seq -> '[', Anon@5, initializer
{CurrentSemanticValue.InitList = this.MakeArrayInitializer(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);    }
        break;
      case 100: // array_init_seq -> array_init_seq, ',', initializer
{CurrentSemanticValue.InitList = this.AddArrayInitializer(ValueStack[ValueStack.Depth-3].InitList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]); }
        break;
      case 101: // struct_init_seq -> '(', initializer
{CurrentSemanticValue.InitList = this.MakeStructInitializer(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 102: // struct_init_seq -> struct_init_seq, ',', initializer
{CurrentSemanticValue.InitList = this.AddStructMemberInitializer(ValueStack[ValueStack.Depth-3].InitList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 103: // array_init_list -> array_init_seq, ']'
{CurrentSemanticValue.InitList = this.WrapUpArrayInitList(ValueStack[ValueStack.Depth-2].InitList, LocationStack[LocationStack.Depth-1]);}
        break;
      case 104: // array_init_list -> array_init_seq, error, ']'
{CurrentSemanticValue.InitList = this.WrapUpArrayInitList(ValueStack[ValueStack.Depth-3].InitList, LocationStack[LocationStack.Depth-1]); this.yyerrok();}
        break;
      case 105: // array_init_list -> '[', error, ']'
{CurrentSemanticValue.InitList = null; this.yyerrok();}
        break;
      case 106: // array_init_list -> '[', ']'
{CurrentSemanticValue.InitList = null; this.report.Warning(19, LocationStack[LocationStack.Depth-2]);}
        break;
      case 107: // struct_init_list -> struct_init_seq, ')'
{CurrentSemanticValue.InitList = this.WrapUpStructInitList(ValueStack[ValueStack.Depth-2].InitList, LocationStack[LocationStack.Depth-1]);}
        break;
      case 108: // struct_init_list -> struct_init_seq, error, ')'
{CurrentSemanticValue.InitList = this.WrapUpStructInitList(ValueStack[ValueStack.Depth-3].InitList, LocationStack[LocationStack.Depth-1]); this.yyerrok();}
        break;
      case 109: // struct_init_list -> '(', ')'
{CurrentSemanticValue.InitList = null; this.report.Warning(19, LocationStack[LocationStack.Depth-2]);}
        break;
      case 110: // initializer -> initial_value
{CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].Expression;}
        break;
      case 111: // Anon@6 -> /* empty */
{this.CheckIfArrayType(LocationStack[LocationStack.Depth-2]);}
        break;
      case 112: // initializer -> INT_LIT, '(', Anon@6, error, ')'
{CurrentSemanticValue.Expression = this.ExpandInitializerSequence(ValueStack[ValueStack.Depth-5].LInt, null, LocationStack[LocationStack.Depth-5]);this.yyerrok();}
        break;
      case 113: // Anon@7 -> /* empty */
{this.CheckIfArrayType(LocationStack[LocationStack.Depth-2]);}
        break;
      case 114: // initializer -> INT_LIT, '(', Anon@7, initializer_seq, ')'
{CurrentSemanticValue.Expression = this.ExpandInitializerSequence(ValueStack[ValueStack.Depth-5].LInt, ValueStack[ValueStack.Depth-2].InitList, LocationStack[LocationStack.Depth-5]);}
        break;
      case 115: // Anon@8 -> /* empty */
{this.PushFieldType(ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
        break;
      case 116: // initializer -> IDENT, Anon@8, ASSIGN, initial_value
{CurrentSemanticValue.Expression = this.MakeStructMemberInit(ValueStack[ValueStack.Depth-4].Ident, ValueStack[ValueStack.Depth-1].Expression);}
        break;
      case 117: // initializer_seq -> initializer
{CurrentSemanticValue.InitList = this.MakeInitializerSequence(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);                    }
        break;
      case 118: // initializer_seq -> initializer_seq, ',', initializer
{CurrentSemanticValue.InitList = this.AddInitializerToSequence(ValueStack[ValueStack.Depth-3].InitList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);               }
        break;
      case 119: // initializer_seq -> initializer_seq, error, initializer
{CurrentSemanticValue.InitList = this.AddInitializerToSequence(ValueStack[ValueStack.Depth-3].InitList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);this.yyerrok();}
        break;
      case 120: // initial_value -> expression
{CurrentSemanticValue.Expression = this.TypeCheckInitialValue(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 121: // initial_value -> array_init_list
{CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].InitList;}
        break;
      case 122: // initial_value -> struct_init_list
{CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].InitList;}
        break;
      case 123: // data_type_decl -> TYPE, type_decl_list, END_TYPE
{this.isTypeDecl = false;}
        break;
      case 124: // data_type_decl -> TYPE, type_decl_list, error, END_TYPE
{this.isTypeDecl = false; this.yyerrok();}
        break;
      case 125: // data_type_decl -> TYPE, error, END_TYPE
{this.isTypeDecl = false; this.yyerrok();}
        break;
      case 126: // Anon@9 -> /* empty */
{this.isTypeDecl = true;}
        break;
      case 130: // semicolon -> /* empty */
{this.report.SyntaxError(63, this.Scanner.yylloc);}
        break;
      case 131: // Anon@10 -> /* empty */
{this.derivedTypeName = ValueStack[ValueStack.Depth-2].Ident;}
        break;
      case 132: // type_decl -> IDENT, ':', Anon@10, data_type_spec, semicolon
{this.InstallDerivedType(ValueStack[ValueStack.Depth-5].Ident, ValueStack[ValueStack.Depth-2].TypeSpec, LocationStack[LocationStack.Depth-5]);}
        break;
      case 133: // constant -> TRUE
{CurrentSemanticValue.Expression = this.MakeConstant(true, ValueStack[ValueStack.Depth-1].Ident);}
        break;
      case 134: // constant -> FALSE
{CurrentSemanticValue.Expression = this.MakeConstant(false, ValueStack[ValueStack.Depth-1].Ident);}
        break;
      case 135: // constant -> INT_LIT
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].LInt);}
        break;
      case 136: // constant -> REAL_LIT
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].LReal);}
        break;
      case 137: // constant -> TOD_LIT
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].TimeOfDay);}
        break;
      case 138: // constant -> TIME_LIT
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].Time);}
        break;
      case 139: // constant -> DATE_LIT
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].Date);}
        break;
      case 140: // constant -> DT_LIT
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].DateTime);}
        break;
      case 141: // constant -> STRING_LIT
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].String, LocationStack[LocationStack.Depth-1]);}
        break;
      case 142: // constant -> WSTRING_LIT
{CurrentSemanticValue.Expression = this.MakeWString(ValueStack[ValueStack.Depth-1].String, LocationStack[LocationStack.Depth-1]); }
        break;
      case 143: // constant -> TYPED_INT
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].TypedInt, LocationStack[LocationStack.Depth-1]);}
        break;
      case 144: // constant -> TYPED_REAL
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].TypedReal, LocationStack[LocationStack.Depth-1]);}
        break;
      case 145: // constant -> TYPED_ENUM
{CurrentSemanticValue.Expression = this.MakeConstant(ValueStack[ValueStack.Depth-1].TypedEnum, LocationStack[LocationStack.Depth-1]);}
        break;
      case 146: // variable -> symbolic_variable
{CurrentSemanticValue.Expression = this.MakeSymbolicVariable(ValueStack[ValueStack.Depth-1].Expression);}
        break;
      case 147: // variable -> DIRECT_VAR
{CurrentSemanticValue.Expression = this.MakeDirectVariable(ValueStack[ValueStack.Depth-1].DirectVar, LocationStack[LocationStack.Depth-1]);}
        break;
      case 148: // symbolic_variable -> simple_variable
{CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].Expression;}
        break;
      case 149: // symbolic_variable -> indexed_variable, ']'
{CurrentSemanticValue.Expression = this.MakeIndexedVariable(ValueStack[ValueStack.Depth-2].IndexedVariable);}
        break;
      case 150: // symbolic_variable -> simple_variable, '[', error, ']'
{CurrentSemanticValue.Expression = Expression.Error; this.yyerrok();}
        break;
      case 151: // Anon@11 -> /* empty */
{this.isIndexExpr = true;}
        break;
      case 152: // indexed_variable -> simple_variable, '[', Anon@11, expression
{CurrentSemanticValue.IndexedVariable = this.MakeIndexedVariable(ValueStack[ValueStack.Depth-4].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-4], LocationStack[LocationStack.Depth-1]);}
        break;
      case 153: // indexed_variable -> indexed_variable, ',', expression
{CurrentSemanticValue.IndexedVariable = this.MakeIndexedVariable(ValueStack[ValueStack.Depth-3].IndexedVariable, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3], LocationStack[LocationStack.Depth-1]);}
        break;
      case 154: // simple_variable -> IDENT
{CurrentSemanticValue.Expression = this.MakeSimpleVariable(ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);    }
        break;
      case 155: // simple_variable -> symbolic_variable, '.', IDENT
{CurrentSemanticValue.Expression = this.MakeSimpleVariable(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Ident, LocationStack[LocationStack.Depth-1]);}
        break;
      case 156: // expression -> NOT, expression
{CurrentSemanticValue.Expression = this.MakeNotOperator(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 157: // expression -> '-', expression
{CurrentSemanticValue.Expression = this.MakeUnaryMinusOperator(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 158: // expression -> '+', expression
{CurrentSemanticValue.Expression = this.MakeUnaryPlusOperator(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 159: // expression -> expression, '=', expression
{CurrentSemanticValue.Expression = this.MakeEqlOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 160: // expression -> expression, '<', expression
{CurrentSemanticValue.Expression = this.MakeLesOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 161: // expression -> expression, '>', expression
{CurrentSemanticValue.Expression = this.MakeGtrOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 162: // expression -> expression, NEQ, expression
{CurrentSemanticValue.Expression = this.MakeNeqOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 163: // expression -> expression, GEQ, expression
{CurrentSemanticValue.Expression = this.MakeGeqOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 164: // expression -> expression, LEQ, expression
{CurrentSemanticValue.Expression = this.MakeLeqOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 165: // expression -> expression, AND, expression
{CurrentSemanticValue.Expression = this.MakeAndOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 166: // expression -> expression, IOR, expression
{CurrentSemanticValue.Expression = this.MakeIOrOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 167: // expression -> expression, XOR, expression
{CurrentSemanticValue.Expression = this.MakeXOrOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 168: // expression -> expression, POW, expression
{CurrentSemanticValue.Expression = this.MakePowOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 169: // expression -> expression, MOD, expression
{CurrentSemanticValue.Expression = this.MakeModOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 170: // expression -> expression, '&', expression
{CurrentSemanticValue.Expression = this.MakeAndOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 171: // expression -> expression, '+', expression
{CurrentSemanticValue.Expression = this.MakeAddOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 172: // expression -> expression, '-', expression
{CurrentSemanticValue.Expression = this.MakeSubOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 173: // expression -> expression, '*', expression
{CurrentSemanticValue.Expression = this.MakeMulOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 174: // expression -> expression, '/', expression
{CurrentSemanticValue.Expression = this.MakeDivOperator(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 175: // expression -> '(', expression, ')'
{CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-2].Expression;}
        break;
      case 176: // expression -> '(', expression, error
{CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-2].Expression; this.report.SemanticError(43, LocationStack[LocationStack.Depth-1]);}
        break;
      case 177: // expression -> prog_org_unit_call
{CurrentSemanticValue.Expression = this.MakeFunctionCall(ValueStack[ValueStack.Depth-1].POU);       }
        break;
      case 178: // expression -> constant
{CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].Expression;                              }
        break;
      case 179: // expression -> variable
{CurrentSemanticValue.Expression = ValueStack[ValueStack.Depth-1].Expression; this.CheckIfForLoopVar(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 180: // expression -> '(', error, ')'
{CurrentSemanticValue.Expression = Expression.Error; this.yyerrok();}
        break;
      case 181: // pou_parameter -> expression
{CurrentSemanticValue.POUParameter = this.MakeParameter(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 182: // pou_parameter -> IDENT, assign, expression
{CurrentSemanticValue.POUParameter = this.MakeParameter(ValueStack[ValueStack.Depth-3].Ident, ValueStack[ValueStack.Depth-2].Token, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3]);}
        break;
      case 183: // pou_parameter -> NOT, IDENT, assign, expression
{CurrentSemanticValue.POUParameter = this.MakeParameter(ValueStack[ValueStack.Depth-3].Ident, ValueStack[ValueStack.Depth-2].Token, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3], true);}
        break;
      case 184: // pou_call_sequence -> IDENT, '(', pou_parameter
{CurrentSemanticValue.POU = this.MakePOUCall(ValueStack[ValueStack.Depth-3].Ident, ValueStack[ValueStack.Depth-1].POUParameter, LocationStack[LocationStack.Depth-3]);}
        break;
      case 185: // pou_call_sequence -> pou_call_sequence, ',', pou_parameter
{CurrentSemanticValue.POU = this.AddPOUParameter(ValueStack[ValueStack.Depth-3].POU, ValueStack[ValueStack.Depth-1].POUParameter);}
        break;
      case 186: // prog_org_unit_call -> IDENT, '(', ')'
{CurrentSemanticValue.POU = this.MakePOUCall(ValueStack[ValueStack.Depth-3].Ident, LocationStack[LocationStack.Depth-3]);}
        break;
      case 187: // prog_org_unit_call -> IDENT, '(', error, ')'
{CurrentSemanticValue.POU = this.MakePOUCall(ValueStack[ValueStack.Depth-4].Ident, LocationStack[LocationStack.Depth-4]); this.yyerrok();}
        break;
      case 188: // prog_org_unit_call -> pou_call_sequence, ')'
{CurrentSemanticValue.POU = this.MakePOUCall(ValueStack[ValueStack.Depth-2].POU, LocationStack[LocationStack.Depth-2]);}
        break;
      case 189: // Anon@12 -> /* empty */
{this.PushTop();}
        break;
      case 190: // statement_list -> Anon@12, statement, ';'
{CurrentSemanticValue.StatList = this.MakeStatementList(ValueStack[ValueStack.Depth-2].Stat);}
        break;
      case 191: // statement_list -> statement_list, statement, ';'
{CurrentSemanticValue.StatList = this.AddToStatementList(ValueStack[ValueStack.Depth-3].StatList, ValueStack[ValueStack.Depth-2].Stat, LocationStack[LocationStack.Depth-2]);}
        break;
      case 192: // statement_list -> error, ';'
{CurrentSemanticValue.StatList = StatementList.Empty; this.yyerrok();}
        break;
      case 193: // statement -> WHILE, condition_DO, while_statement_body
{CurrentSemanticValue.Stat = this.MakeWhileStatement(ValueStack[ValueStack.Depth-2].Expression, ValueStack[ValueStack.Depth-1].StatList, LocationStack[LocationStack.Depth-3]);}
        break;
      case 194: // Anon@13 -> /* empty */
{this.loopNestingDepth++;}
        break;
      case 195: // statement -> REPEAT, Anon@13, repeat_statement_body
{CurrentSemanticValue.Stat = ValueStack[ValueStack.Depth-1].Stat;}
        break;
      case 196: // Anon@14 -> /* empty */
{this.PopTop();}
        break;
      case 197: // statement -> IF, condition_THEN, statement_list, Anon@14, opt_elsif_stat, 
                //              opt_else_stat, END_IF
{CurrentSemanticValue.Stat = this.MakeIfStatement(ValueStack[ValueStack.Depth-6].Expression, ValueStack[ValueStack.Depth-5].StatList, ValueStack[ValueStack.Depth-3].GenericList, ValueStack[ValueStack.Depth-2].StatList);}
        break;
      case 198: // Anon@15 -> /* empty */
{this.PushForLoopData(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].ForList);}
        break;
      case 199: // statement -> FOR, control_variable, assign, for_list_DO, Anon@15, 
                //              for_statement_body
{CurrentSemanticValue.Stat = this.MakeForLoopStatement(ValueStack[ValueStack.Depth-5].Expression, ValueStack[ValueStack.Depth-3].ForList, ValueStack[ValueStack.Depth-1].StatList);}
        break;
      case 200: // statement -> CASE, expression_OF, case_element_list, END_CASE
{CurrentSemanticValue.Stat = this.MakeCaseStatement(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-2].CaseElementList, LocationStack[LocationStack.Depth-1]);}
        break;
      case 201: // statement -> assignment_stat
{CurrentSemanticValue.Stat = ValueStack[ValueStack.Depth-1].Stat;}
        break;
      case 202: // statement -> EXIT
{CurrentSemanticValue.Stat = this.MakeExitStatement(LocationStack[LocationStack.Depth-1]);}
        break;
      case 203: // statement -> RETURN
{CurrentSemanticValue.Stat = this.MakeReturnStatement(LocationStack[LocationStack.Depth-1]);}
        break;
      case 204: // statement -> RETURN, expression
{CurrentSemanticValue.Stat = this.MakeReturnStatement2(LocationStack[LocationStack.Depth-1]);}
        break;
      case 205: // statement -> prog_org_unit_call
{CurrentSemanticValue.Stat = this.MakeFunctionBlockCallStatement(ValueStack[ValueStack.Depth-1].POU);}
        break;
      case 206: // statement -> /* empty */
{CurrentSemanticValue.Stat = Statement.Empty;}
        break;
      case 207: // while_statement_body -> statement_list, END_WHILE
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-2].StatList;}
        break;
      case 208: // while_statement_body -> statement_list, error, END_WHILE
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-3].StatList;this.yyerrok();}
        break;
      case 209: // while_statement_body -> error, END_WHILE
{CurrentSemanticValue.StatList = StatementList.Empty;this.yyerrok();}
        break;
      case 210: // repeat_statement_body -> statement_list, UNTIL, until_condition
{CurrentSemanticValue.Stat = this.MakeRepeatStatement(ValueStack[ValueStack.Depth-3].StatList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3]);}
        break;
      case 211: // repeat_statement_body -> statement_list, error, UNTIL, until_condition
{CurrentSemanticValue.Stat = this.MakeRepeatStatement(ValueStack[ValueStack.Depth-4].StatList, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-4]);this.yyerrok();}
        break;
      case 212: // repeat_statement_body -> error, END_REPEAT
{CurrentSemanticValue.Stat = this.MakeRepeatStatement(); this.yyerrok();}
        break;
      case 213: // for_statement_body -> statement_list, END_FOR
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-2].StatList;}
        break;
      case 214: // for_statement_body -> statement_list, error, END_FOR
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-3].StatList; this.yyerrok();}
        break;
      case 215: // for_statement_body -> error, END_FOR
{CurrentSemanticValue.StatList = StatementList.Empty; this.yyerrok();}
        break;
      case 216: // condition_DO -> expression, DO
{CurrentSemanticValue.Expression = this.CheckIfBoolCondition("WHILE-DO", ValueStack[ValueStack.Depth-2].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 217: // condition_DO -> error, DO
{CurrentSemanticValue.Expression = Expression.Error; this.yyerrok();}
        break;
      case 218: // condition_DO -> expression
{CurrentSemanticValue.Expression = this.CheckIfBoolCondition("WHILE-DO", ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]); this.report.SyntaxError(80, LocationStack[LocationStack.Depth-1]);}
        break;
      case 219: // condition_THEN -> expression, THEN
{CurrentSemanticValue.Expression = this.CheckIfBoolCondition("IF-THEN-ELSE", ValueStack[ValueStack.Depth-2].Expression,  LocationStack[LocationStack.Depth-2]);}
        break;
      case 220: // condition_THEN -> error, THEN
{CurrentSemanticValue.Expression = Expression.Error; this.yyerrok();}
        break;
      case 221: // condition_THEN -> expression
{CurrentSemanticValue.Expression = this.CheckIfBoolCondition("IF-THEN-ELSE", ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);this.report.SyntaxError(81, LocationStack[LocationStack.Depth-1]);}
        break;
      case 222: // until_condition -> expression, END_REPEAT
{CurrentSemanticValue.Expression = this.CheckIfBoolCondition("REPEAT-UNTIL", ValueStack[ValueStack.Depth-2].Expression, LocationStack[LocationStack.Depth-2]);}
        break;
      case 223: // until_condition -> error, END_REPEAT
{CurrentSemanticValue.Expression = Expression.Error; this.yyerrok();}
        break;
      case 224: // until_condition -> expression
{CurrentSemanticValue.Expression = this.CheckIfBoolCondition("REPEAT-UNTIL", ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);this.report.SyntaxError(82, LocationStack[LocationStack.Depth-1]);}
        break;
      case 225: // expression_OF -> expression, OF
{CurrentSemanticValue.Expression = this.CheckCtrlExpression(LocationStack[LocationStack.Depth-2], ValueStack[ValueStack.Depth-2].Expression);}
        break;
      case 226: // expression_OF -> error, OF
{CurrentSemanticValue.Expression = this.CheckCtrlExpression(LocationStack[LocationStack.Depth-2]);this.yyerrok();}
        break;
      case 227: // expression_OF -> expression
{CurrentSemanticValue.Expression = this.CheckCtrlExpression(LocationStack[LocationStack.Depth-1], ValueStack[ValueStack.Depth-1].Expression);this.report.SyntaxError(83, LocationStack[LocationStack.Depth-1]);}
        break;
      case 228: // control_variable -> variable
{CurrentSemanticValue.Expression = this.SaveControlVariable(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);this.forLoopVarKind = 0x2;}
        break;
      case 229: // Anon@16 -> /* empty */
{this.forLoopVarKind = 0x4;}
        break;
      case 230: // for_list_DO -> expression, TO, Anon@16, expression, optional_by_stat, DO
{CurrentSemanticValue.ForList = this.MakeForLoopData(ValueStack[ValueStack.Depth-6].Expression, ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-2].Expression, LocationStack[LocationStack.Depth-6], LocationStack[LocationStack.Depth-3], LocationStack[LocationStack.Depth-2]);}
        break;
      case 231: // Anon@17 -> /* empty */
{this.forLoopVarKind = 0x4;}
        break;
      case 232: // for_list_DO -> error, TO, Anon@17, expression, optional_by_stat, DO
{CurrentSemanticValue.ForList = this.MakeForLoopData(null, ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-2].Expression, null, LocationStack[LocationStack.Depth-3], LocationStack[LocationStack.Depth-2]);this.yyerrok();}
        break;
      case 233: // for_list_DO -> expression, TO, error, DO
{CurrentSemanticValue.ForList = this.MakeForLoopData(ValueStack[ValueStack.Depth-4].Expression, null, null, LocationStack[LocationStack.Depth-4]);this.yyerrok();}
        break;
      case 234: // for_list_DO -> error, DO
{CurrentSemanticValue.ForList = this.MakeForLoopData(null, null, null);this.yyerrok();}
        break;
      case 235: // Anon@18 -> /* empty */
{this.forLoopVarKind = 0x8;}
        break;
      case 236: // optional_by_stat -> BY, Anon@18, expression
{CurrentSemanticValue.Expression = this.CheckForLoopIncr(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 237: // optional_by_stat -> /* empty */
{CurrentSemanticValue.Expression = MakeIntConstant((long)1);}
        break;
      case 238: // opt_else_stat -> ELSE, statement_list
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-1].StatList; this.PopTop();  }
        break;
      case 239: // opt_else_stat -> ELSE, error
{CurrentSemanticValue.StatList = null; this.PopTop();}
        break;
      case 240: // opt_else_stat -> /* empty */
{CurrentSemanticValue.StatList = null;}
        break;
      case 241: // opt_elsif_stat -> elsif_stat
{CurrentSemanticValue.GenericList = ValueStack[ValueStack.Depth-1].GenericList;}
        break;
      case 242: // opt_elsif_stat -> /* empty */
{CurrentSemanticValue.GenericList = null;}
        break;
      case 243: // default_statement -> ELSE, case_stat_list
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-1].StatList;}
        break;
      case 244: // default_statement -> ELSE, case_stat_list, error
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-2].StatList; this.yyerrok();}
        break;
      case 245: // Anon@19 -> /* empty */
{this.PushTop();}
        break;
      case 246: // case_stat_list -> Anon@19, statement, ';'
{CurrentSemanticValue.StatList = this.MakeCaseStatList(ValueStack[ValueStack.Depth-2].Stat);         }
        break;
      case 247: // case_stat_list -> case_stat_list, statement, ';'
{CurrentSemanticValue.StatList = this.AddToCaseStatList(ValueStack[ValueStack.Depth-3].StatList, ValueStack[ValueStack.Depth-2].Stat, LocationStack[LocationStack.Depth-2]);}
        break;
      case 249: // case_element -> WHEN, case_label_list, ':', case_stat_list
{CurrentSemanticValue.Object = this.MakeCaseElement(ValueStack[ValueStack.Depth-3].CaseLabelList, ValueStack[ValueStack.Depth-1].StatList);}
        break;
      case 250: // case_element -> WHEN, error, ':', case_stat_list
{CurrentSemanticValue.Object = this.MakeCaseElement(null, ValueStack[ValueStack.Depth-1].StatList);this.yyerrok();}
        break;
      case 251: // case_element -> WHEN, case_label_list, case_stat_list
{CurrentSemanticValue.Object = this.MakeCaseElement(null, ValueStack[ValueStack.Depth-1].StatList); this.report.SyntaxError(91, LocationStack[LocationStack.Depth-1]);}
        break;
      case 252: // case_element -> default_statement
{CurrentSemanticValue.Object = this.MakeDefaultCaseElement(ValueStack[ValueStack.Depth-1].StatList);}
        break;
      case 253: // case_elem_list -> case_element
{CurrentSemanticValue.CaseElementList = this.MakeCaseElementList(ValueStack[ValueStack.Depth-1].Object);}
        break;
      case 254: // case_elem_list -> case_elem_list, case_element
{CurrentSemanticValue.CaseElementList = this.AddCaseElementToList(ValueStack[ValueStack.Depth-2].CaseElementList, ValueStack[ValueStack.Depth-1].Object, LocationStack[LocationStack.Depth-1]);}
        break;
      case 255: // case_element_list -> case_elem_list
{CurrentSemanticValue.CaseElementList = ValueStack[ValueStack.Depth-1].CaseElementList;}
        break;
      case 256: // case_element_list -> /* empty */
{CurrentSemanticValue.CaseElementList = new List<CaseElement>();}
        break;
      case 257: // case_label -> expression
{CurrentSemanticValue.CaseLabel = this.CheckCaseLabel(ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-1]);}
        break;
      case 258: // case_label -> subrange
{CurrentSemanticValue.CaseLabel = this.CheckCaseLabel(ValueStack[ValueStack.Depth-1].Subrange, LocationStack[LocationStack.Depth-1]);}
        break;
      case 259: // case_label_list -> case_label
{CurrentSemanticValue.CaseLabelList = this.MakeCaseLabelList(ValueStack[ValueStack.Depth-1].CaseLabel, LocationStack[LocationStack.Depth-1]);     }
        break;
      case 260: // case_label_list -> case_label_list, ',', case_label
{CurrentSemanticValue.CaseLabelList = this.AddCaseLabelToList(ValueStack[ValueStack.Depth-3].CaseLabelList, ValueStack[ValueStack.Depth-1].CaseLabel, LocationStack[LocationStack.Depth-1]);}
        break;
      case 261: // elsif_stat -> ELSIF, condition_THEN, statement_list
{CurrentSemanticValue.GenericList = this.MakeElseIfStatement(ValueStack[ValueStack.Depth-2].Expression, ValueStack[ValueStack.Depth-1].StatList);}
        break;
      case 262: // elsif_stat -> elsif_stat, ELSIF, condition_THEN, statement_list
{CurrentSemanticValue.GenericList = this.AddElseIfStatementToList(ValueStack[ValueStack.Depth-4].GenericList, ValueStack[ValueStack.Depth-2].Expression, ValueStack[ValueStack.Depth-1].StatList);}
        break;
      case 263: // assignment_stat -> variable, ASSIGN, expression
{CurrentSemanticValue.Stat = this.MakeAssignmentStatement(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3]);}
        break;
      case 264: // assignment_stat -> variable, '=', expression
{CurrentSemanticValue.Stat = this.MakeAssignmentStatement(ValueStack[ValueStack.Depth-3].Expression, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3]);}
        break;
      case 265: // function_body -> statement_list, END_FUNCTION
{CurrentSemanticValue.StatList = this.CheckFunctionValueDefinition(ValueStack[ValueStack.Depth-2].StatList, LocationStack[LocationStack.Depth-1]);}
        break;
      case 266: // function_body -> statement_list, error, END_FUNCTION
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-3].StatList;this.yyerrok();}
        break;
      case 267: // function_block_body -> statement_list, END_FUNCTION_BLOCK
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-2].StatList;}
        break;
      case 268: // function_block_body -> statement_list, error, END_FUNCTION_BLOCK
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-3].StatList; this.yyerrok();}
        break;
      case 269: // program_body -> statement_list, END_PROGRAM
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-2].StatList;}
        break;
      case 270: // program_body -> statement_list, error, END_PROGRAM
{CurrentSemanticValue.StatList = ValueStack[ValueStack.Depth-3].StatList; this.yyerrok();}
        break;
      case 271: // Anon@20 -> /* empty */
{this.PushSymbolTable(0);}
        break;
      case 272: // Anon@21 -> /* empty */
{this.InstallFunctionProtoType(ValueStack[ValueStack.Depth-5].Ident, ValueStack[ValueStack.Depth-3].DataType, ValueStack[ValueStack.Depth-1].POUVariableDecls, LocationStack[LocationStack.Depth-6]);}
        break;
      case 273: // function_decl -> FUNCTION, IDENT, ':', non_generic_type, Anon@20, 
                //                  pou_variable_decls, Anon@21, function_body
{this.SaveFunctionDefinition(ValueStack[ValueStack.Depth-3].POUVariableDecls, ValueStack[ValueStack.Depth-1].StatList);}
        break;
      case 274: // Anon@22 -> /* empty */
{this.PushSymbolTable(1);}
        break;
      case 275: // Anon@23 -> /* empty */
{this.InstallFunctionBlockProtoType(ValueStack[ValueStack.Depth-3].Ident, ValueStack[ValueStack.Depth-1].POUVariableDecls, LocationStack[LocationStack.Depth-4]);}
        break;
      case 276: // function_block_decl -> FUNCTION_BLOCK, IDENT, Anon@22, pou_variable_decls, 
                //                        Anon@23, function_block_body
{this.SaveFunctionBlockDeclaration(ValueStack[ValueStack.Depth-3].POUVariableDecls, ValueStack[ValueStack.Depth-1].StatList);}
        break;
      case 277: // Anon@24 -> /* empty */
{this.PushSymbolTable(2);}
        break;
      case 279: // Anon@25 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR_INPUT, ValueStack[ValueStack.Depth-1].VarQualifier, LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 280: // input_var_decl -> VAR_INPUT, opt_var_qualifier, Anon@25, var_declaration
{CurrentSemanticValue.Declaration = this.MakeFormalParameterDecl(STVarType.VAR_INPUT, ValueStack[ValueStack.Depth-3].VarQualifier, ValueStack[ValueStack.Depth-1].POUVarDecl);}
        break;
      case 281: // input_var_decl -> VAR_INPUT, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 282: // Anon@26 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR, ValueStack[ValueStack.Depth-1].VarQualifier, LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 283: // var_decl -> VAR, opt_var_qualifier, Anon@26, var_declaration
{CurrentSemanticValue.Declaration = this.MakeLocalVariableDecl(STVarType.VAR, ValueStack[ValueStack.Depth-3].VarQualifier, ValueStack[ValueStack.Depth-1].POUVarDecl);}
        break;
      case 284: // var_decl -> VAR, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 285: // Anon@27 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR_OUTPUT, ValueStack[ValueStack.Depth-1].VarQualifier, LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 286: // output_var_decl -> VAR_OUTPUT, opt_var_qualifier, Anon@27, var_declaration
{CurrentSemanticValue.Declaration = this.MakeFormalParameterDecl(STVarType.VAR_OUTPUT, ValueStack[ValueStack.Depth-3].VarQualifier, ValueStack[ValueStack.Depth-1].POUVarDecl);}
        break;
      case 287: // output_var_decl -> VAR_OUTPUT, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 288: // Anon@28 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR_OUTPUT, ValueStack[ValueStack.Depth-1].VarQualifier, LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 290: // global_var_decl -> VAR_GLOBAL, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 291: // Anon@29 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR_INOUT, ValueStack[ValueStack.Depth-1].VarQualifier,  LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 292: // inout_var_decl -> VAR_IN_OUT, opt_var_qualifier, Anon@29, var_declaration
{CurrentSemanticValue.Declaration = this.MakeFormalParameterDecl(STVarType.VAR_INOUT, ValueStack[ValueStack.Depth-3].VarQualifier, ValueStack[ValueStack.Depth-1].POUVarDecl);}
        break;
      case 293: // inout_var_decl -> VAR_IN_OUT, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 294: // Anon@30 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR_TEMP, ValueStack[ValueStack.Depth-1].VarQualifier,  LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 295: // temp_var_decl -> VAR_TEMP, opt_var_qualifier, Anon@30, var_declaration
{CurrentSemanticValue.Declaration = this.MakeLocalVariableDecl(STVarType.VAR_TEMP, ValueStack[ValueStack.Depth-3].VarQualifier, ValueStack[ValueStack.Depth-1].POUVarDecl);}
        break;
      case 296: // temp_var_decl -> VAR_TEMP, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 297: // Anon@31 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR_EXTERNAL, ValueStack[ValueStack.Depth-1].VarQualifier,  LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 299: // extern_var_decl -> VAR_EXTERNAL, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 300: // Anon@32 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR_ACCESS, ValueStack[ValueStack.Depth-1].VarQualifier,  LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 302: // access_var_decl -> VAR_ACCESS, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 303: // Anon@33 -> /* empty */
{this.CheckVarTypeQualUsage(STVarType.VAR_CONFIG, ValueStack[ValueStack.Depth-1].VarQualifier,  LocationStack[LocationStack.Depth-2], LocationStack[LocationStack.Depth-1]);}
        break;
      case 305: // config_var_decl -> VAR_CONFIG, error, END_VAR
{CurrentSemanticValue.Declaration = null; this.yyerrok();}
        break;
      case 306: // pou_variable_decl -> var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 307: // pou_variable_decl -> temp_var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 308: // pou_variable_decl -> extern_var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 309: // pou_variable_decl -> global_var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 310: // pou_variable_decl -> access_var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 311: // pou_variable_decl -> config_var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 312: // pou_variable_decl -> input_var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 313: // pou_variable_decl -> output_var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 314: // pou_variable_decl -> inout_var_decl
{CurrentSemanticValue.Declaration = ValueStack[ValueStack.Depth-1].Declaration;}
        break;
      case 315: // pou_variable_decl -> data_type_decl
{CurrentSemanticValue.Declaration = null;}
        break;
      case 316: // pou_var_decl_list -> pou_variable_decl
{CurrentSemanticValue.POUVariableDecls = this.MakePOUVarDeclList(ValueStack[ValueStack.Depth-1].Declaration);}
        break;
      case 317: // pou_var_decl_list -> pou_var_decl_list, pou_variable_decl
{CurrentSemanticValue.POUVariableDecls = this.AddPOUVarDeclToList(ValueStack[ValueStack.Depth-2].POUVariableDecls, ValueStack[ValueStack.Depth-1].Declaration);}
        break;
      case 318: // pou_variable_decls -> pou_var_decl_list
{CurrentSemanticValue.POUVariableDecls = ValueStack[ValueStack.Depth-1].POUVariableDecls;}
        break;
      case 319: // pou_variable_decls -> /* empty */
{CurrentSemanticValue.POUVariableDecls = this.MakeEmptyPOUVarDecl();}
        break;
      case 320: // var_decl_list -> var_init_decl, semicolon
{CurrentSemanticValue.POUVarDecl = this.MakeVariableDeclList(ValueStack[ValueStack.Depth-2].VarInitDecl);}
        break;
      case 321: // var_decl_list -> var_decl_list, var_init_decl, semicolon
{CurrentSemanticValue.POUVarDecl = this.AddToVariableDeclList(ValueStack[ValueStack.Depth-3].POUVarDecl, ValueStack[ValueStack.Depth-2].VarInitDecl);}
        break;
      case 322: // var_declaration -> var_decl_list, END_VAR
{CurrentSemanticValue.POUVarDecl = ValueStack[ValueStack.Depth-2].POUVarDecl;}
        break;
      case 323: // var_declaration -> var_decl_list, error, END_VAR
{CurrentSemanticValue.POUVarDecl = ValueStack[ValueStack.Depth-3].POUVarDecl;this.yyerrok();}
        break;
      case 324: // var_init_decl -> identifier_list, ':', data_type, opt_decl_qualifier
{CurrentSemanticValue.VarInitDecl = this.InstallLocalVars(ValueStack[ValueStack.Depth-4].IdentifierList, ValueStack[ValueStack.Depth-2].DataType, ValueStack[ValueStack.Depth-1].EdgeQualifier, LocationStack[LocationStack.Depth-1]);}
        break;
      case 325: // Anon@34 -> /* empty */
{this.Push(ValueStack[ValueStack.Depth-2].DataType);}
        break;
      case 326: // var_init_decl -> identifier_list, ':', data_type, opt_decl_qualifier, Anon@34, 
                //                  ASSIGN, initial_value
{CurrentSemanticValue.VarInitDecl = this.InstallLocalVars(ValueStack[ValueStack.Depth-7].IdentifierList, ValueStack[ValueStack.Depth-5].DataType, ValueStack[ValueStack.Depth-4].EdgeQualifier, ValueStack[ValueStack.Depth-1].Expression, LocationStack[LocationStack.Depth-3]);}
        break;
      case 327: // Anon@35 -> /* empty */
{}
        break;
      case 328: // var_init_decl -> IDENT, AT, DIRECT_VAR, Anon@35, ':', data_type_spec
{CurrentSemanticValue.VarInitDecl = this.InstallSymbolicVariable(ValueStack[ValueStack.Depth-6].Ident, ValueStack[ValueStack.Depth-1].TypeSpec, ValueStack[ValueStack.Depth-4].DirectVar, LocationStack[LocationStack.Depth-6]);}
        break;
      case 329: // Anon@36 -> /* empty */
{}
        break;
      case 330: // var_init_decl -> AT, DIRECT_VAR, Anon@36, ':', data_type_spec
{CurrentSemanticValue.VarInitDecl = this.InstallDirectVariable(ValueStack[ValueStack.Depth-4].DirectVar, ValueStack[ValueStack.Depth-1].TypeSpec, LocationStack[LocationStack.Depth-4]);}
        break;
      case 331: // opt_var_qualifier -> RETAIN
{CurrentSemanticValue.VarQualifier = STVarQualifier.RETAIN;}
        break;
      case 332: // opt_var_qualifier -> NON_RETAIN
{CurrentSemanticValue.VarQualifier = STVarQualifier.NON_RETAIN;}
        break;
      case 333: // opt_var_qualifier -> CONSTANT
{CurrentSemanticValue.VarQualifier = STVarQualifier.CONSTANT;}
        break;
      case 334: // opt_var_qualifier -> CONSTANT, RETAIN
{CurrentSemanticValue.VarQualifier = STVarQualifier.CONSTANT; this.report.SemanticError(173, LocationStack[LocationStack.Depth-2]);}
        break;
      case 335: // opt_var_qualifier -> RETAIN, CONSTANT
{CurrentSemanticValue.VarQualifier = STVarQualifier.CONSTANT; this.report.SemanticError(173, LocationStack[LocationStack.Depth-2]);}
        break;
      case 336: // opt_var_qualifier -> /* empty */
{CurrentSemanticValue.VarQualifier = STVarQualifier.NONE;}
        break;
      case 337: // opt_decl_qualifier -> R_EDGE
{CurrentSemanticValue.EdgeQualifier = STDeclQualifier.R_EDGE;}
        break;
      case 338: // opt_decl_qualifier -> F_EDGE
{CurrentSemanticValue.EdgeQualifier = STDeclQualifier.F_EDGE;}
        break;
      case 339: // opt_decl_qualifier -> READ_ONLY
{CurrentSemanticValue.EdgeQualifier = STDeclQualifier.READ_ONLY;}
        break;
      case 340: // opt_decl_qualifier -> WRITE_ONLY
{CurrentSemanticValue.EdgeQualifier = STDeclQualifier.WRITE_ONLY;}
        break;
      case 341: // opt_decl_qualifier -> /* empty */
{CurrentSemanticValue.EdgeQualifier = STDeclQualifier.NONE;}
        break;
    }
#pragma warning restore 162, 1522
  }

  protected override string TerminalToString(int terminal)
  {
    if (aliases != null && aliases.ContainsKey(terminal))
        return aliases[terminal];
    else if (((Tokens)terminal).ToString() != terminal.ToString(CultureInfo.InvariantCulture))
        return ((Tokens)terminal).ToString();
    else
        return CharToString((char)terminal);
  }

	public STLangParser(STLangScanner scanner, ErrorHandler errorHandler) : base(scanner) 
	{ 
		this.report = errorHandler;
		Expression.Report = errorHandler;
		TypeNode.Report = errorHandler;
		STLangSymbol.Report = errorHandler;
		errorHandler.Scanner = scanner;
		this.structNestingDepth = 0;
		this.forLoopVarKind = 0;
		this.loopNestingDepth = 0;
		this.functionValueDef = new List<bool>(){false};
		this.forLoopVarTable = new List<Hashtable>();
		this.forLoopDataList = new List<ForLoopData>();
		this.attributeStack = new SemanticStack(errorHandler);
		constantTable = new Dictionary<string, Expression>();
		this.rwMemoryManager = new RWMemoryLayoutManager();
		this.symbolTable = new STLangSymbolTable(errorHandler);
		this.caseLabelStack = null;
		this.isFunctionDecl = false;
		this.isProgramDecl  = false;
		this.isFunctionBlockDecl = false;
		this.variablePosition = 0;
		this.isTypeDecl = false;
		this.isIndexExpr = false;
		this.isSubrangeDecl = false;
		this.subrangeDataType = TypeNode.Error;
	}

	public int Errors
    {
        get { return this.report.Errors; }
    }

    public int Warnings
    {
        get { return this.report.Warnings; }
    }

    public IEnumerable<string> Messages
    {
        get { return this.report.ErrorMessages; }
    }

	private STVarType variableType;

	private STVarQualifier variableQualifier;

	private int structNestingDepth;

	private int forLoopVarKind;

	private int loopNestingDepth;

	private static Dictionary<string, Expression> constantTable;

	private readonly List<Hashtable> forLoopVarTable;

	private readonly List<bool> functionValueDef;

	private readonly ErrorHandler report;

	private readonly STLangSymbolTable symbolTable;

	private readonly SemanticStack attributeStack;

	private RWMemoryLayoutManager rwMemoryManager;

	private List<List<CaseLabel>> caseLabelStack;

	private List<ForLoopData> forLoopDataList;

	private List<CaseLabel> caseLabelList;

	private int variablePosition;

	private bool isProgramDecl;

	private bool isFunctionDecl;

	private bool isFunctionBlockDecl;

	private bool isTypeDecl;

	private bool isIndexExpr;

	private string derivedTypeName;

	private TypeNode subrangeDataType;

	private bool isSubrangeDecl;

	private void ReInitializeParser()
	{
		this.structNestingDepth = 0;
		this.forLoopVarKind = 0;
		this.loopNestingDepth = 0;
		this.forLoopVarTable.Clear();
		this.attributeStack.Clear();
		this.functionValueDef.Clear();
		this.functionValueDef.Add(false);
		constantTable = new Dictionary<string, Expression>();
		this.symbolTable.ReInitialize();
		this.isFunctionDecl = false;
		this.isProgramDecl  = false;
		this.isFunctionBlockDecl = false;
		this.variablePosition = 0;
		this.isTypeDecl = false;
		this.isIndexExpr = false;
		this.isSubrangeDecl = false;
		this.subrangeDataType = TypeNode.Error;
		this.rwMemoryManager = new RWMemoryLayoutManager();
	}

	private DataTypeSpec MakeDataTypeSpec(TypeNode dataType, STDeclQualifier declQualifier, LexLocation location)
	{
		if (declQualifier != STDeclQualifier.NONE)
		{
			if (dataType != TypeNode.Error && dataType != TypeNode.Bool)
			{
				this.report.SemanticError(120, location);
				declQualifier = STDeclQualifier.NONE;
			}
			if (this.structNestingDepth > 0)
			{
				this.report.SemanticError(121, location);
				declQualifier = STDeclQualifier.NONE;
			}
		}
		return new DataTypeSpec(dataType, declQualifier, dataType.DefaultValue);
	}

	private DataTypeSpec MakeDataTypeSpec(TypeNode dataType, STDeclQualifier declQualifier, Expression initialValue, LexLocation location)
	{
		if (declQualifier != STDeclQualifier.NONE)
		{
			if (dataType != TypeNode.Bool)
			{
				this.report.SemanticError(120, location);
				declQualifier = STDeclQualifier.NONE;
			}
			if (this.structNestingDepth > 0)
			{
				this.report.SemanticError(121, location);
				declQualifier = STDeclQualifier.NONE;
			}
		}
		this.Pop();
		return new DataTypeSpec(dataType, declQualifier, initialValue);
	}

	private List<string> MakeIdentifierList(string ident, LexLocation location)
	{
		List<string> identList = new List<string>();
		if (this.symbolTable.IsValidUserDefinedSymbol(ident, location))
			identList.Add(ident);
		return identList;
	}

	private NamedValueList MakeNamedValueList(TypeNode dataType, NamedValue namedValue)
	{
		Expression value;
		if (namedValue == null) 
			value = Expression.Error;
		else {
			value = namedValue.Value;

			if (value != null)
			{
				if (value.DataType != dataType)
				{
				}
			}
		}
		return new NamedValueList(namedValue, dataType);
	}

	private NamedValueList AddNamedValue(NamedValueList namedValueDecl, NamedValue namedValue)
	{
		if (namedValueDecl == null)
			return new NamedValueList(namedValue, TypeNode.Error);
		else {
			namedValueDecl.Add(namedValue);
			return namedValueDecl;
		}
	}

	private NamedValue MakeNamedValue(string name, Expression value, LexLocation idLoc, LexLocation valueLoc)
	{
		return new NamedValue(name, value, idLoc, valueLoc);
	}

	private List<string> AddIdentToList(List<string> identList, string ident, LexLocation location)
	{
		if (identList == null)
			return this.MakeIdentifierList(ident, location);
		else if (! identList.IsUnique(ident))
			this.report.SemanticError(2, ident, location);
		else if (this.symbolTable.IsValidUserDefinedSymbol(ident, location))
			identList.Add(ident);
		return identList;
	}

	// void RegisterForLoopVariable(InstanceSymbol symbol, ForLoopVariableType loopVarType)
	//
	// Keeps track of variables used as control variables, start-, stop-values and increments in for-loops.
	// This information is used to check that these variables aren't changed inside the loop.
	//
	private void RegisterForLoopVariable(InstanceSymbol symbol, ForLoopVariableType loopVarType, LexLocation location)
	{
		if (loopVarType == ForLoopVariableType.CONTROL_VARIABLE)
		{
			// Make sure that the variable isn't already used as a control 
			// variable, start-value or stop-value in any outer for-loop.

			foreach (Hashtable loopVarTable in this.forLoopVarTable)
			{
				if (loopVarTable.Contains(symbol))
				{
					ForLoopVariableType forLoopVarType;
					forLoopVarType = (ForLoopVariableType)loopVarTable[symbol];
					if ((forLoopVarType & ForLoopVariableType.CONTROL_VARIABLE) != 0)
						this.report.SemanticError(125, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.START_VARIABLE) != 0)
						this.report.SemanticError(126, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.STOP_VARIABLE) != 0)
						this.report.SemanticError(127, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.INCR_VARIABLE) != 0)
						this.report.Warning(15, symbol.Name, location);
				}
			}
			Hashtable currentLoopVarTable = new Hashtable();
			currentLoopVarTable[symbol] = ForLoopVariableType.CONTROL_VARIABLE;
			this.forLoopVarTable.Add(currentLoopVarTable);
		}
		else {
			Hashtable loopVarTable = this.forLoopVarTable.Last();
			if (loopVarTable == null)
				throw new STLangCompilerError("For-loop variable table is empty.");
			else if (! loopVarTable.Contains(symbol))
				loopVarTable[symbol] = loopVarType;
			else {
				ForLoopVariableType forLoopVarType;

				forLoopVarType = (ForLoopVariableType)loopVarTable[symbol];
				if ((forLoopVarType & ForLoopVariableType.CONTROL_VARIABLE) == 0)
				{
					forLoopVarType |= loopVarType;
					loopVarTable[symbol] = forLoopVarType;
				}
				else if (loopVarType == ForLoopVariableType.START_VARIABLE)
					this.report.SemanticError(126, symbol.Name, location);
				else if (loopVarType == ForLoopVariableType.STOP_VARIABLE)
					this.report.SemanticError(127, symbol.Name, location);
				else if (loopVarType == ForLoopVariableType.INCR_VARIABLE)
					this.report.Warning(15, symbol.Name, location);
			}
		}
	}


	private void PopForLoopVariables()
	{
		if (this.forLoopVarTable.Count > 0)
		{
			Hashtable currentLoopVars = this.forLoopVarTable.Last();
			this.forLoopVarTable.Remove(currentLoopVars);
			ForLoopData forLoopData = this.forLoopDataList.Last();
			this.forLoopDataList.Remove(forLoopData);
			forLoopData.ControlVariable.Symbol.IsForLoopCtrlVar = false;
		}
	}

	private void Push(Expression expression)
	{
		if (expression == null)
			this.attributeStack.Push(TypeNode.Error);
		else
			this.attributeStack.Push(expression.DataType);
	}

	private void PushTop()
	{
		if (this.functionValueDef.Count == 0)
			throw new STLangCompilerError("Function value stack is empty.");
		else {
			bool topValue = this.functionValueDef.Last();
			this.functionValueDef.Add(topValue);
		}
	}

	private void PushCaseLabelList()
	{
		if (this.caseLabelStack == null)
		{
			this.caseLabelStack = new List<List<CaseLabel>>();
			this.caseLabelList = new List<CaseLabel>();
			this.caseLabelStack.Add(this.caseLabelList);
		}
		else {
			this.caseLabelStack.Add(this.caseLabelList);
			this.caseLabelList = new List<CaseLabel>();
		}
	}

	private void PopCaseLabelList()
	{
		if (this.caseLabelStack.Count == 0)
			throw new STLangCompilerError("PopCaseLabelList(): Case label stack is empty.");
		else {
			int lastIndex = this.caseLabelStack.Count - 1;
			this.caseLabelStack.RemoveAt(lastIndex);
			if (this.caseLabelStack.Count > 0)
                this.caseLabelList = this.caseLabelStack.Last();
            else {
				this.caseLabelStack = null;
				this.caseLabelList = null;
			} 
		}
	}

	private void CopyValue(bool funcValueDefined)
	{
		if (this.functionValueDef.Count == 0)
			throw new STLangCompilerError("CopyValue(): Function value stack is empty.");
		else {
			bool currentValue = this.functionValueDef.Last();
			if (funcValueDefined && ! currentValue)
			{
				int topIndex = this.functionValueDef.Count - 1;
				this.functionValueDef[topIndex] = true;
			}
		}
	}

	private void PopTop()
	{
		if (this.functionValueDef.Count == 0)
			throw new STLangCompilerError("Function value stack is empty.");
		else if (this.functionValueDef.Count > 1)
		{
			int topIndex = this.functionValueDef.Count - 1;
			this.functionValueDef.RemoveAt(topIndex);
		}
	}

	private void CheckFunctionValueIsDefined(LexLocation location)
	{
		if (this.functionValueDef.Count == 0)
			throw new STLangCompilerError("Function value stack is empty.");
		else {
			bool functionValueIsDefined = this.functionValueDef.Last();
			if (! functionValueIsDefined)
				this.report.SemanticError(13, location);
		}
	}

	private StatementList CheckFunctionValueDefinition(StatementList statementList, LexLocation loc)
	{
		this.CheckFunctionValueIsDefined(loc);
		if (statementList == null)
			statementList = StatementList.Empty;
		return statementList;
	}

	private void SaveFunctionDefinition(POUVarDeclarations varDecls, StatementList functionBody)
	{
		this.symbolTable.Pop();
		if (! functionBody.POUReturns)
			functionBody.Add(new ReturnStatement());  // Make sure the function returns
		this.rwMemoryManager.SetSegmentAlignment(sizeof(double));
		varDecls.SetDeclarationSize(this.rwMemoryManager);
		this.symbolTable.SaveFunctionDefinition(functionBody, constantTable, this.rwMemoryManager);
	}

	private void SaveFunctionBlockDeclaration(POUVarDeclarations fbVarDecls, StatementList functionBlockBody)
	{
		this.symbolTable.Pop();
		if (! functionBlockBody.POUReturns)
			functionBlockBody.Add(new ReturnStatement()); // Make sure the function block returns
		this.rwMemoryManager.SetSegmentAlignment(sizeof(double));
		fbVarDecls.SetDeclarationSize(this.rwMemoryManager);
		this.symbolTable.SaveFunctionBlockBody(functionBlockBody, constantTable, this.rwMemoryManager);
	}

	private void CheckIfArrayType(LexLocation location)
	{
		this.attributeStack.CheckIfArrayType(location);
	}

	private void PushArrayElemType(LexLocation location)
	{
		this.attributeStack.PushArrayElementType(location);
	}

	private void Push(TypeNode dataType)
	{
		this.attributeStack.Push(dataType);
	}

	private void Pop()
	{
		this.attributeStack.Pop();
	}

	private TypeNode LargestDataType(Expression expr1, Expression expr2)
	{
		return expr1.DataType.Size > expr2.DataType.Size ? expr1.DataType : expr2.DataType;
	}

	private StructMemberInit MakeStructMemberInit(string name, Expression initValue)
	{
		TypeNode fieldDataType = this.attributeStack.Top;
		this.Pop();
		if (initValue == null)
			return new StructMemberInit(name, fieldDataType.DefaultValue);
		else
			return new StructMemberInit(name, initValue);
	}

	private InitializerList MakeInitializerSequence(Expression initializer, LexLocation loc)
	{
		TypeNode dataType = this.attributeStack.Top;
		InitializerSequence initSequence = new InitializerSequence(dataType);
		initSequence.Add(initializer, loc);
		return initSequence;
	}

	private InitializerList AddInitializerToSequence(InitializerList initSequence, Expression initializer, LexLocation loc)
	{
		if (initSequence != null)
			initSequence.Add(initializer, loc);
		return initSequence;
	}

	private TypeNode MakeInitializerDataType(uint elementCount, TypeNode elementType)
	{
		string typeID;
		TypeNode arrayType;
		
		typeID = string.Format("[0..{0}]{1}", elementCount - 1, elementType.TypeID);
		if (TypeNode.LookUpType(typeID, out arrayType))
			return arrayType;
		else {
			int upper = (int)elementCount - 1;
			long byteCount = elementCount * elementType.Size;
			Expression size =  MakeIntConstant(byteCount);
			string typeName = string.Format("ARRAY [0..{0}] OF {1}", upper, elementType.Name);
			return new ArrayType(typeName, 0, upper, (uint)byteCount, size, elementType, elementType, typeID);
		}
	}

	private InitializerList MakeArrayOfStructInitializer(TypeNode array, FieldSymbol firstField, uint elementCount)
	{
		TypeNode dataType;
		TypeNode fieldDataType;
        InitializerList arrayInit;
		FieldSymbol field = firstField;
		Expression size   = MakeIntConstant(array.Size);
		ArrayOfStructInitializer arrayOfStructInitializer;

		arrayOfStructInitializer = new ArrayOfStructInitializer(array, size);
		while (field != null)
		{
			fieldDataType = field.DataType;
			if (fieldDataType.IsElementaryType || fieldDataType.IsAnyStringType)
			{
				dataType = this.MakeInitializerDataType(elementCount, fieldDataType);
				size = MakeIntConstant((long)dataType.Size);
				arrayInit = new ArrayInitializer(dataType, size);
			}
			else if (fieldDataType.IsStructType)
			{
				StructType struct2 = (StructType)fieldDataType.BaseType;
				FieldSymbol firstField2 = struct2.FirstField;
				dataType = this.MakeInitializerDataType(elementCount, fieldDataType);
				arrayInit = this.MakeArrayOfStructInitializer(dataType, firstField2, elementCount);
			}
			else if (fieldDataType.IsArrayType)
			{
				ArrayType array2 = (ArrayType)fieldDataType.BaseType;
				TypeNode elementType = array2.BasicElementType;
				uint elemCount2 = (array2.Size/elementType.Size)*elementCount;
				dataType = this.MakeInitializerDataType(elemCount2, elementType);
				if (elementType.IsElementaryType || elementType.IsAnyStringType)
				{
					size = MakeIntConstant((long)dataType.Size);
					arrayInit = new ArrayInitializer(dataType, size);
				}
                else if (elementType.IsStructType)
                {
                    StructType struct2 = (StructType)elementType.BaseType;
					FieldSymbol firstField2 = struct2.FirstField;
                    arrayInit = this.MakeArrayOfStructInitializer(dataType, firstField2, elemCount2);
                }
				else if (elementType.IsFunctionBlockType)
                {
					//
					// IEC 61131-3 does not allow arrays of function blocks (yet).
					//
                    size = MakeIntConstant((long)elementType.Size);
					arrayInit = new ArrayInitializer(fieldDataType, size); 
                }
				else if (elementType == TypeNode.Error)
				{
					size = MakeIntConstant((long)elementType.Size);
					arrayInit = new ArrayInitializer(elementType, size);
				}
                else
                {
                    string msg = "MakeArrayOfStructInitializer(): Unknown ";
                    msg += "type of array element " + elementType.Name;
                    throw new STLangCompilerError(msg);
                }
			}
			else if (fieldDataType.IsFunctionBlockType)
			{
				//
				// IEC 61131-3 does not allow arrays of function blocks (yet).
				//
				size = MakeIntConstant((long)fieldDataType.Size);
				arrayInit = new ArrayInitializer(fieldDataType, size); 
			}
			else if (fieldDataType == TypeNode.Error)
			{
				size = MakeIntConstant((long)fieldDataType.Size);
				arrayInit = new ArrayInitializer(fieldDataType, size);
			}
			else {
				string msg;
				msg = "MakeArrayOfStructInitializer(): Unknown type " + fieldDataType.Name;
				throw new STLangCompilerError(msg);
			}
			arrayOfStructInitializer.AddInitializer(field.Name, arrayInit);
			field = field.Next;
		}
		return arrayOfStructInitializer;
	}

	private InitializerList MakeArrayInitializer(Expression initializer, LexLocation location)
	{
		InitializerList arrayInitList;
		TypeNode dataType = this.attributeStack.Top2;
		if (initializer == null || ! dataType.IsArrayType)
		{
			Expression size = MakeIntConstant((long)1000);
			arrayInitList = new ArrayInitializer(TypeNode.Error, size);
			arrayInitList.Add(initializer, location);
			return arrayInitList;
		}
		else {
			ArrayType array = (ArrayType)dataType;
			TypeNode elementType = array.BasicElementType;
		
			if (elementType.IsElementaryType || elementType.IsAnyStringType)
			{
				Expression size = MakeIntConstant((long)dataType.Size);
				arrayInitList = new ArrayInitializer(dataType, size);
				arrayInitList.Add(initializer, location);
				return arrayInitList;
			}
			else if (elementType.IsFunctionBlockType)
			{
				//
				// IEC 61131-3 does not allow arrays of function blocks (yet).
				//
				Expression size = MakeIntConstant((long)dataType.Size);
				arrayInitList = new ArrayInitializer(dataType, size);
				return arrayInitList; 
			}
			else if (elementType.IsStructType)
			{
				uint elemCount = array.Size/elementType.Size;
				StructType structure = (StructType)elementType.BaseType;
				FieldSymbol firstField = structure.FirstField;
				arrayInitList = this.MakeArrayOfStructInitializer(array, firstField, elemCount);
				arrayInitList.Add(initializer, location);
				return arrayInitList;
			}
		}
		throw new STLangCompilerError(Resources.MAKEARRAYINITLIST2);
	}

	private InitializerList AddArrayInitializer(InitializerList arrayInitList, Expression initializer, LexLocation loc)
	{
		if (arrayInitList == null)
		{
			TypeNode dataType = this.attributeStack.Top2;
			initializer = dataType.DefaultValue;
		}
		arrayInitList.Add(initializer, loc);
		return arrayInitList;
	}

	private InitializerList WrapUpArrayInitList(InitializerList arrayInitList, LexLocation location)
	{
		this.attributeStack.Pop();
		if (arrayInitList == null)
			return arrayInitList;
		else if (arrayInitList.DataType == TypeNode.Error)
			return arrayInitList;
		else {
			arrayInitList.CheckInitListSize(location);
			if (! arrayInitList.IsConstant)
				return arrayInitList;
			else {
				string key = arrayInitList.GetKey();
				if (! constantTable.ContainsKey(key))
				{
					constantTable[key] = arrayInitList;
					return arrayInitList;
				}
				else {
					Expression initializer;
					initializer = (Expression)constantTable[key];
					if (initializer is ArrayInitializer)
					{
						ArrayInitializer arrayInitList2;
						arrayInitList2 = (ArrayInitializer)initializer;
						if (arrayInitList2.DataType == arrayInitList.DataType)
							return arrayInitList2;
					}
					else if (initializer is ArrayOfStructInitializer)
					{
						ArrayOfStructInitializer arrayInitList2;
						arrayInitList2 = (ArrayOfStructInitializer)initializer;
						if (arrayInitList2.DataType == arrayInitList.DataType)
							return arrayInitList2;
					}
					throw new STLangCompilerError(Resources.WRAPUPARRAYINILIST);
				} 
			}
		}
	}

	private InitializerList WrapUpStructInitList(InitializerList structInitList, LexLocation location)
	{
		if (structInitList == null)
			return structInitList;
		else if (structInitList.DataType == TypeNode.Error)
			return structInitList;
		else {
			structInitList.CheckInitListSize(location);
			if (! structInitList.IsConstant)
				return structInitList;
			else {
				string key = structInitList.GetKey();
				if (! constantTable.ContainsKey(key))
				{
					constantTable[key] = structInitList;
					return structInitList;
				}
				else {
					Expression initializer;
					initializer = (Expression)constantTable[key];
					if (initializer is StructInitializer)
					{
						StructInitializer structInitList2;
						structInitList2 = (StructInitializer)initializer;
						if (structInitList2.DataType == structInitList.DataType)
							return structInitList2;
					}
					throw new STLangCompilerError(Resources.WRAPUPARRAYINILIST);
				}
			}
		}
	}

	private InitializerList MakeStructInitializer(Expression initializer, LexLocation location)
	{
		TypeNode dataType = this.attributeStack.Top;
		Expression size = MakeIntConstant((long)dataType.Size);
		if (dataType.IsStructType)
		{
			StructInitializer structInitList = new StructInitializer(dataType, size);
			structInitList.Add(initializer, location);
			return structInitList;
		}
		else if (dataType.IsFunctionBlockType)
		{
			FunctionBlockInitializer functionBlockInitList;
			functionBlockInitList = new FunctionBlockInitializer(dataType, size);
			functionBlockInitList.Add(initializer, location);
			return functionBlockInitList;
		}
		else 
		{
			if (dataType != TypeNode.Error)
				this.report.SemanticError(65, dataType.Name, location);
			return new StructInitializer(TypeNode.Error, size);
		}
	}

	private InitializerList AddStructMemberInitializer(InitializerList structInitList, Expression initializer, LexLocation loc)
	{
		if (structInitList != null)
			structInitList.Add(initializer, loc);
		return structInitList;
	}

	private StructDeclaration MakeStructMemberList(StructMemberDeclaration member)
	{	
		StructDeclaration structure = new StructDeclaration();
		if (member != null)
		{
			if (! structure.Add(member))
				this.report.SemanticError(62, member.Name, member.Location);
		}
		return structure;
	}
	
	private StructDeclaration AddStructMemberDecl(StructDeclaration structure, StructMemberDeclaration member, LexLocation loc)
	{
		if (structure != null && member != null)
		{
			if (! structure.Add(member))
				this.report.SemanticError(62, member.Name, member.Location);
		}
		return structure;
	}

	private StructMemberDeclaration MakeStructMemberDecl(string name, DataTypeSpec member, LexLocation loc)
	{
		return new StructMemberDeclaration(name, member.DataType, member.InitialValue, loc);
	}

	private int BitCount(ulong value)
	{
		int count = 0;
		while (value > 0)
		{
			count++;
			value >>= 1;
		}
		return count;
	}

	private ulong IntPower(ulong value, int power)
	{
		if (power == 0)
			return 1;
		else if ((power & 1) == 0)
			return this.IntPower(value*value, power >> 1);
		else if ((value & 1) == 0)
			return this.IntPower(value >> 1, power) << power;
		else
			return value * IntPower(value, power - 1);
	}

	private long IntPower(long value, int power)
	{
		if (power == 0)
			return 1;
		else if ((power & 1) == 0)
			return this.IntPower(value*value, power >> 1);
		else if ((value & 1) == 0)
			return this.IntPower(value >> 1, power) << power;
		else
			return value * IntPower(value, power - 1);
	}

	private bool IsPowerOf2(ulong value, out int power)
	{
		power = 0;
		if (value <= 1)
			return false;
		else {
			while ((value & 1) == 0)
			{
				power++;
				value >>= 1;
			}
			return value == 1;
		}
	}

	private Expression CheckForLoopIncr(Expression expr, LexLocation location)
	{
		if (expr == null)
			return Expression.Error;
		else if (expr is FunctionName)
		{
			this.report.SemanticError(148, expr.ToString(), location);
			return Expression.Error;
		}
		else if (expr.DataType == TypeNode.Error)
			return expr;
		else if (expr.DataType.IsSignedIntType)
			return expr;
		else {
			this.report.SemanticError(135, expr.ToString(), location);
			return Expression.Error;
		}
	}

	private Expression MakeIntConstant(TokenInt token)
	{
		ulong value = token.Value;
		string lexeme = token.ToString();
		if ((value & 0x8000000000000000) != 0)
			return new ULIntConstant(value, lexeme);
		else if (TypeNode.SInt.IsInRange((long)value))
			return new SIntConstant((sbyte)value, lexeme);
		else if (TypeNode.Int.IsInRange((long)value))
			return new IntConstant((short)value, lexeme);
		else if (TypeNode.DInt.IsInRange((long)value))
			return new DIntConstant((int)value, lexeme);
		else
			return new LIntConstant((long)value, lexeme);
	}

	private Expression MakeIntConstant(ulong value)
	{
		string strValue = value.ToString();
		if (constantTable.ContainsKey(strValue))
			return (Expression)constantTable[strValue];
		else {
			Expression intConst;
			if (TypeNode.USInt.IsInRange(value))
				intConst = new USIntConstant((byte)value, strValue);
			else if (TypeNode.UInt.IsInRange(value))
				intConst = new UIntConstant((ushort)value, strValue);
			else if (TypeNode.UDInt.IsInRange(value))
				intConst = new UDIntConstant((uint)value, strValue);
			else 
				intConst = new ULIntConstant((ulong)value, strValue);
			constantTable[strValue] = intConst;
			return intConst;
		}
	}

	public static Expression MakeIntConstant(long value)
	{
		string strValue = value.ToString();
		if (constantTable.ContainsKey(strValue))
			return (Expression)constantTable[strValue];
		else {
			Expression intConst;
			if (TypeNode.SInt.IsInRange(value))
				intConst = new SIntConstant((sbyte)value, strValue);
			else if (TypeNode.Int.IsInRange(value))
				intConst = new IntConstant((short)value, strValue);
			else if (TypeNode.DInt.IsInRange(value))
				intConst = new DIntConstant((int)value, strValue);
			else
				intConst = new LIntConstant((long)value, strValue);
			constantTable[strValue] = intConst;
			return intConst;
		}
	}

	private Expression MakeConstant(ulong value, TypeNode bitStringType)
	{
		if (bitStringType == TypeNode.Bool)
			return this.MakeConstant(value != 0);
		else {
			string typeName = bitStringType.Name;
			string strValue = typeName + "#" + value.ToString();
			if (constantTable.ContainsKey(strValue))
				return (Expression)constantTable[strValue];
			else {
				Expression bitStringConst;
				if (TypeNode.Byte.IsInRange(value))
					bitStringConst = new ByteConstant((byte)value, strValue);
				else if (TypeNode.Word.IsInRange(value))
					bitStringConst = new WordConstant((ushort)value, strValue);
				else if (TypeNode.DInt.IsInRange(value))
					bitStringConst = new DWordConstant((uint)value, strValue);
				else
					bitStringConst = new LWordConstant((ulong)value, strValue);
				constantTable[strValue] = bitStringConst;
				return bitStringConst;
			}
		}
	}

	private Expression MakeConstant(bool value)
	{
		string stringValue = value.ToString();
		string keyValue = stringValue.ToUpper();
		if (constantTable.ContainsKey(keyValue))
			return (Expression)constantTable[keyValue];
		else
		{
			Expression expr = new BoolConstant(value, stringValue);
			constantTable[keyValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(bool value, string boolStr)
	{
		string keyValue = boolStr.ToUpper();
		if (constantTable.ContainsKey(keyValue))
			return (Expression)constantTable[keyValue];
		else
		{
			Expression expr = new BoolConstant(value, boolStr);
			constantTable[keyValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(string stringValue, LexLocation location)
	{
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			long length = stringValue.Length;
			Expression size = MakeIntConstant(length);
			TypeNode stringType = this.MakeStringType(size, location);
			Expression expr = new StringConstant(stringValue, stringType);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeWString(string stringValue, LexLocation location)
	{
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			long length = stringValue.Length;
			Expression size = MakeIntConstant(length);
			TypeNode stringType = this.MakeWStringType(size, location);
			Expression expr = new StringConstant(stringValue, stringType);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenTypedInt token, LexLocation location)
	{
		string lexeme = token.ToString();
		string keyValue = lexeme.RemoveChar('_').ToUpper();
		ulong value = token.Value;
		if (constantTable.ContainsKey(keyValue))
			return (Expression)constantTable[keyValue];
		else {
			Expression constant = null;
			switch (token.IntType)
			{
			case Tokens.INT:
				constant = new IntConstant((short)value, lexeme);
				break;
			case Tokens.SINT:
				constant = new SIntConstant((sbyte)value, lexeme);
				break;
			case Tokens.DINT:
				constant = new DIntConstant((int)value, lexeme);
				break;
			case Tokens.LINT:
				constant = new LIntConstant((long)value, lexeme);
				break;
			case Tokens.USINT:
				constant = new USIntConstant((byte)value, lexeme);
				break;
			case Tokens.UINT:
				constant = new UIntConstant((ushort)value, lexeme);
				break;
			case Tokens.UDINT:
				constant = new UDIntConstant((uint)value, lexeme);
				break;
			case Tokens.ULINT:
				constant = new ULIntConstant(value, lexeme);
				break;
			case Tokens.BOOL:
				constant = new BoolConstant(value != 0, lexeme);
				break;
			case Tokens.BYTE:
				constant = new ByteConstant((byte)value, lexeme);
				break;
			case Tokens.WORD:
				constant = new WordConstant((ushort)value, lexeme);
				break;
			case Tokens.DWORD:
				constant = new DWordConstant((uint)value, lexeme);
				break;
			case Tokens.LWORD:
				constant = new LWordConstant(value, lexeme);
				break;
			case Tokens.REAL:
				constant = new RealConstant((float)value);
				break;
			case Tokens.LREAL:
				constant = new LRealConstant((double)value);
				break;
			case Tokens.IDENT:
				{
					STLangSymbol symbol;
					string typeName = token.TypeName;
					if (! this.symbolTable.Lookup(typeName, out symbol, location))
					{
						this.report.SemanticError(1, typeName, location);
						return Expression.Error;
					}
					else if (! (symbol is TypeNameSymbol))
					{
						this.report.SemanticError(24, typeName, location);
						return Expression.Error;
					}
					else if (! symbol.DataType.IsElementaryType)
					{
						this.report.SemanticError(114, value, symbol.DataType.Name, location);
						return Expression.Error;
					}
					else {
						TypeNode dataType = symbol.DataType;
						keyValue = dataType.Name + "#" + value;
						keyValue = keyValue.RemoveChar('_').ToUpper();
						if (constantTable.ContainsKey(keyValue))
							return (Expression)constantTable[keyValue];
						else if (dataType == TypeNode.SInt)
							constant = new SIntConstant((sbyte)value, lexeme);
						else if (dataType == TypeNode.Int)
							constant = new IntConstant((short)value, lexeme);
						else if (dataType == TypeNode.DInt)
							constant = new DIntConstant((int)value, lexeme);
						else if (dataType == TypeNode.LInt)
							constant = new LIntConstant((long)value, lexeme);
						else if (dataType == TypeNode.USInt)
							constant = new USIntConstant((byte)value, lexeme);
						else if (dataType == TypeNode.UInt)
							constant = new UIntConstant((ushort)value, lexeme);
						else if (dataType == TypeNode.UDInt)
							constant = new UDIntConstant((uint)value, lexeme);
						else if (dataType == TypeNode.ULInt)
							constant = new ULIntConstant((ulong)value, lexeme);
						else if (dataType == TypeNode.Bool)
							constant = new BoolConstant(value != 0, lexeme);
						else if (dataType == TypeNode.Byte)
							constant = new ByteConstant((byte)value, lexeme);
						else if (dataType == TypeNode.Word)
							constant = new WordConstant((ushort)value, lexeme);
						else if (dataType == TypeNode.DWord)
							constant = new DWordConstant((uint)value, lexeme);
						else if (dataType == TypeNode.LWord)
							constant = new LWordConstant((ulong)value, lexeme);
						else if (dataType == TypeNode.Real)
							constant = new RealConstant((float)value);
						else if (dataType == TypeNode.LReal)
							constant = new LRealConstant((double)value);
						else {
							this.report.SemanticError(114, value, dataType.Name, location);
							return Expression.Error;
						}

					}
				}
				break;
			case Tokens.DATE:
			case Tokens.DATE_AND_TIME:
			case Tokens.DT:
			case Tokens.TIME:
			case Tokens.TIME_OF_DAY:
			case Tokens.TOD:
			case Tokens.STRING:
			case Tokens.WSTRING:
			default:
				this.report.SemanticError(114, value, token.IntType.ToString(), location);
				return Expression.Error;
			}
			if (constant != null)
			{
				TypeNode dataType = constant.DataType;
				constantTable[keyValue] = constant;
				return constant;
			}
		}
		return Expression.Error;
	}

	private Expression MakeConstant(TokenTypedReal token, LexLocation location)
	{
		string lexeme = token.ToString();
		double value = token.Value;
		string keyValue = lexeme.RemoveChar('_').ToUpper();
		if (constantTable.ContainsKey(keyValue))
			return (Expression)constantTable[keyValue];
		else {
			Expression constant = null;
			switch (token.RealType)
			{
			case Tokens.REAL:
				constant = new RealConstant((float)value, lexeme);
				break;
			case Tokens.LREAL:
				constant = new LRealConstant(value);
				break;
			case Tokens.INT:
				constant = new IntConstant((short)value, lexeme);
				break;
			case Tokens.SINT:
				constant = new SIntConstant((sbyte)value, lexeme);
				break;
			case Tokens.DINT:
				constant = new DIntConstant((int)value, lexeme);
				break;
			case Tokens.LINT:
				constant = new LIntConstant((long)value, lexeme);
				break;
			case Tokens.USINT:
				constant = new USIntConstant((byte)value, lexeme);
				break;
			case Tokens.UINT:
				constant = new UIntConstant((ushort)value, lexeme);
				break;
			case Tokens.UDINT:
				constant = new UDIntConstant((uint)value, lexeme);
				break;
			case Tokens.ULINT:
				constant = new ULIntConstant((ulong)value, lexeme);
				break;
			case Tokens.BOOL:
				constant = new BoolConstant(value != 0, lexeme);
				break;
			case Tokens.BYTE:
				constant = new ByteConstant((byte)value, lexeme);
				break;
			case Tokens.WORD:
				constant = new WordConstant((ushort)value, lexeme);
				break;
			case Tokens.DWORD:
				constant = new DWordConstant((uint)value, lexeme);
				break;
			case Tokens.LWORD:
				constant = new LWordConstant((ulong)value, lexeme);
				break;
			case Tokens.IDENT:
			{
				STLangSymbol symbol;
				string typeName = token.TypeName;
				if (! this.symbolTable.Lookup(typeName, out symbol, location))
				{
					this.report.SemanticError(1, typeName, location);
					return MakeConstant(value);
				}
				else if (! (symbol is TypeNameSymbol))
				{
					this.report.SemanticError(24, typeName, location);
					return MakeConstant(value);
				}
				else {
					TypeNode dataType = symbol.DataType;
					lexeme = dataType.Name + "#" + value;
					keyValue = lexeme.RemoveChar('_').ToUpper();
					if (constantTable.ContainsKey(keyValue))
						return (Expression)constantTable[keyValue];
					else if (dataType == TypeNode.SInt)
						constant = new SIntConstant((sbyte)value, lexeme);
					else if (dataType == TypeNode.Int)
						constant = new IntConstant((short)value, lexeme);
					else if (dataType == TypeNode.DInt)
						constant = new DIntConstant((int)value, lexeme);
					else if (dataType == TypeNode.LInt)
						constant = new LIntConstant((long)value, lexeme);
					else if (dataType == TypeNode.USInt)
						constant = new USIntConstant((byte)value, lexeme);
					else if (dataType == TypeNode.UInt)
						constant = new UIntConstant((ushort)value, lexeme);
					else if (dataType == TypeNode.UDInt)
						constant = new UDIntConstant((uint)value, lexeme);
					else if (dataType == TypeNode.ULInt)
						constant = new ULIntConstant((ulong)value, lexeme);
					else if (dataType == TypeNode.Bool)
						constant = new BoolConstant(value != 0.0, lexeme);
					else if (dataType == TypeNode.Byte)
						constant = new ByteConstant((byte)value, lexeme);
					else if (dataType == TypeNode.Word)
						constant = new WordConstant((ushort)value, lexeme);
					else if (dataType == TypeNode.DWord)
						constant = new DWordConstant((uint)value, lexeme);
					else if (dataType == TypeNode.LWord)
						constant = new LWordConstant((ulong)value, lexeme);
					else if (dataType == TypeNode.Real)
						constant = new RealConstant((float)value, lexeme);
					else if (dataType == TypeNode.LReal)
						constant = new LRealConstant(value, lexeme);
					else {
						this.report.SemanticError(114, value, dataType.Name, location);
						return Expression.Error;
					}
				}
			}
			break;
			default:
				this.report.SyntaxError(111, token.TypeName, location);
				return Expression.Error;
			}
			if (constant != null)
			{
				TypeNode dataType = constant.DataType;
				constantTable[keyValue] = constant;
				return constant;
			}
		}
		return Expression.Error;
	}

	private Expression MakeConstant(TokenTypedEnum enumConst, LexLocation location)
	{
		if (enumConst.TypeToken != Tokens.IDENT || enumConst.ValueToken != Tokens.IDENT)
			return Expression.Error;
		else {
			STLangSymbol symbol;
			string qualifiedName = enumConst.ToString();
			string keyValue = qualifiedName.ToUpper();
			if (constantTable.ContainsKey(keyValue))
				return (Expression)constantTable[keyValue];
			else if (this.symbolTable.Lookup(qualifiedName, out symbol, location))
			{
				Expression constant = symbol.MakeSyntaxTreeNode(location);
				constantTable[keyValue] = constant;
				return constant;
			}
			else {
				STLangSymbol enumSymbol;
				string enumTypeName = enumConst.TypeName;
				string enumValue = enumConst.Value;
				this.report.SemanticError(0, qualifiedName, location);
				if (! this.symbolTable.Lookup(enumTypeName, out symbol, location))
					this.report.SemanticError(0, enumTypeName, location);
				else if (! (symbol is TypeNameSymbol))
					this.report.SemanticError(24, enumTypeName, location);
				else if (! symbol.DataType.IsEnumeratedType)
					this.report.SemanticError(-7, enumTypeName, location);
				if (! this.symbolTable.Lookup(enumValue, out enumSymbol, location))
					this.report.SemanticError(0, enumValue, location);
				else if (! (enumSymbol is EnumSymbol))
					this.report.SemanticError(-8, enumValue, location);
				return Expression.Error;
			}
		}
	}

	private SubRange MakeEnumSubRange(Expression lower, Expression upper, LexLocation location)
	{
		int lowerBound = Convert.ToInt32(lower.Evaluate());
		int upperBound = Convert.ToInt32(upper.Evaluate());
		if (lowerBound > upperBound)
		{
			string interval = lower + ".." + upper;
			this.report.SemanticError(16, interval, location);
			int tmp = lowerBound;
			lowerBound = upperBound;
			upperBound = tmp;
		}
		return new EnumSubrange((ushort)lowerBound, (ushort)upperBound, lower.DataType);
	}

	private SubRange MakeIntSubRange(Expression lower, Expression upper, LexLocation location)
	{
		long lowerBound = Convert.ToInt64(lower.Evaluate());
		long upperBound = Convert.ToInt64(upper.Evaluate());
		if (lowerBound > upperBound)
		{
			string interval = lower.ToString() + ".." + upper.ToString();
			this.report.SemanticError(16, interval, location);
			long tmp = lowerBound;
			lowerBound = upperBound;
			upperBound = tmp;
		}
		TypeNode dataType = this.LargestDataType(lower, upper);
		return new IntSubrange(lower, upper, dataType);
	}

	private SubRange MakeUIntSubRange(Expression lower, Expression upper, LexLocation location)
	{
		ulong lowerBound = Convert.ToUInt64(lower.Evaluate());
		ulong upperBound = Convert.ToUInt64(upper.Evaluate());
		if (lowerBound > upperBound)
		{
			string interval = lower.ToString() + ".." + upper.ToString();
			this.report.SemanticError(16, interval, location);
			ulong tmp = lowerBound;
			lowerBound = upperBound;
			upperBound = tmp;
		}
		TypeNode dataType = this.LargestDataType(lower, upper);
		return new UIntSubrange(lower, upper, dataType);
	}

	private SubRange MakeBitStringSubRange(Expression lower, Expression upper, LexLocation location)
	{
		ulong lowerBound = Convert.ToUInt64(lower.Evaluate());
		ulong upperBound = Convert.ToUInt64(upper.Evaluate());
		if (lowerBound > upperBound)
		{
			string interval = lower.ToString() + ".." + upper.ToString();
			this.report.SemanticError(16, interval, location);
			ulong tmp = lowerBound;
			lowerBound = upperBound;
			upperBound = tmp;
		}
		TypeNode dataType = this.LargestDataType(lower, upper);
		return new BitStringSubrange(lower, upper, dataType);
	}

private SubRange MakeSubrange(Expression lower, Expression upper, LexLocation loc1, LexLocation loc2)
{
		if (lower == null || upper == null)
			return SubRange.Error;
		else {
			TypeNode lowerDataType = lower.DataType;
			TypeNode upperDataType = upper.DataType;
		
			if (lowerDataType == TypeNode.Error || upperDataType == TypeNode.Error)
				return SubRange.Error;
			else if (! lower.IsConstant)
			{
				this.report.SemanticError(95, lower.ToString(), loc1);
				if (! upper.IsConstant)
					this.report.SemanticError(95, upper.ToString(), loc2);
				if (! lowerDataType.IsOrdinalType)
					this.report.SemanticError(-1, lower.ToString(), loc1);
				if (! upperDataType.IsOrdinalType)
					this.report.SemanticError(-1, upper.ToString(), loc2);
				return SubRange.Error;
			}
			else if (! upper.IsConstant)
			{
				this.report.SemanticError(95, upper.ToString(), loc2);
				if (! lowerDataType.IsOrdinalType)
					this.report.SemanticError(-1, lower.ToString(), loc1);
				if (! upperDataType.IsOrdinalType)
					this.report.SemanticError(-1, upper.ToString(), loc2);
				return SubRange.Error;
			}
			else if (! lowerDataType.IsOrdinalType)
			{
				this.report.SemanticError(-1, lower.ToString(), loc1);
				if (! upperDataType.IsOrdinalType)
					this.report.SemanticError(-1, upper.ToString(), loc2);
				return SubRange.Error;
			}
			else if (! upperDataType.IsOrdinalType)
			{
				this.report.SemanticError(-1, upper.ToString(), loc2);
				return SubRange.Error;
			}
			else if (lowerDataType.IsSignedIntType)
			{
				if (upperDataType.IsSignedIntType)
					return this.MakeIntSubRange(lower, upper, loc1);
			}
			else if (lowerDataType.IsUnsignedIntType)
			{
				if (upperDataType.IsUnsignedIntType)
					return this.MakeUIntSubRange(lower, upper, loc1);
			}
			else if (lowerDataType.IsBitStringType)
			{
				if (upperDataType.IsBitStringType)
					return this.MakeBitStringSubRange(lower, upper, loc1);
			}
			else if (lowerDataType.BaseType != upperDataType.BaseType)
			{
				string subRange = lower + ".." + upper;
				this.report.SemanticError(94, subRange, loc1);
				return SubRange.Error;
			}
			else if (lowerDataType.IsEnumeratedType)
				return this.MakeEnumSubRange(lower, upper, loc1);
		}
		string interval = lower + ".." + upper;
		this.report.SemanticError(94, interval, loc1);
		return SubRange.Error;
	}

	private void SubrangeTypeStart(TypeNode subrangeType)
	{
		this.isSubrangeDecl = true;
		this.subrangeDataType = subrangeType;
	}

	private TypeNode MakeSubrangeType(TypeNode baseType, SubRange subrange, LexLocation loc)
	{
		TypeNode subRangeType;
		this.isSubrangeDecl = false;            
		this.subrangeDataType = TypeNode.Error;
		string typeID = baseType.TypeID + "(" + subrange + ")";
		if (TypeNode.LookUpType(typeID, out subRangeType))
			return subRangeType;
		else {
			string typeName = baseType.Name + "(" + subrange + ")";
			return baseType.MakeSubrange(typeName, subrange, loc);
		}
	}	

	private List<SubRange> MakeSubRangeList(SubRange subrange, LexLocation location)
	{
		if (subrange.DataType.IsSignedIntType)
			return new List<SubRange>{subrange};
		else {
			this.report.SemanticError(15, subrange.ToString(), location);
			return new List<SubRange>{new IntSubrange(0, 100, TypeNode.Int)};
		}
	}

	private List<SubRange> AddSubRange(List<SubRange> subRangeList, SubRange subrange, LexLocation location)
	{
		if (subRangeList.Count == STLangParameters.MAX_ARRAY_SUBSCRIPTS)
			this.report.SemanticError(50, location);
		if (subrange.DataType.IsIntegerType)
			subRangeList.Add(subrange);
		else {
			if (subrange.DataType != TypeNode.Error)
				this.report.SemanticError(15, subrange.ToString(), location);
			subRangeList.Add(new IntSubrange(0, 100, TypeNode.Int));
		}
		return subRangeList;
	}

	private List<string> MakeEnumIdentList(string enumIdent, LexLocation location)
	{
		List<string> enumIdentList = new List<string>();
		if (enumIdent.Length > 0)
		{
			if (this.isTypeDecl)
			{
				if (this.symbolTable.IsValidTypedEnumSymbol(enumIdent, location))
					enumIdentList.Add(enumIdent);
			}
			else if (this.symbolTable.IsValidUserDefinedSymbol(enumIdent, location))
				enumIdentList.Add(enumIdent);
		}
		return enumIdentList;
	}

	private List<string> AddToEnumIdentList(List<string> enumIdentList, string enumIdent, LexLocation location)
	{
		if (enumIdent.Length == 0)
			return enumIdentList;
		else if (enumIdentList == null)
			return this.MakeEnumIdentList(enumIdent, location);
		else if (!enumIdentList.IsUnique(enumIdent))
			this.report.SemanticError(1, enumIdent, location);
		else if (this.isTypeDecl)
		{
			if (this.symbolTable.IsValidTypedEnumSymbol(enumIdent, location))
				enumIdentList.Add(enumIdent);
		}
		else if (this.symbolTable.IsValidUserDefinedSymbol(enumIdent, location))
			enumIdentList.Add(enumIdent);
		return enumIdentList;
	}

	private EnumeratedType MakeEnumeratedType(List<string> identList)
	{
		EnumeratedType enumType = new EnumeratedType(identList);
		if (this.isTypeDecl)
			this.symbolTable.InstallEnumeratedConstants(enumType, this.derivedTypeName);
		else
			this.symbolTable.InstallEnumeratedConstants(enumType);
		//
		// Install selection functions SEL and MUX for this enumerated type in the symboltable.
		//
		STLangSymbolTable.InstallStandardFunction("SEL", enumType, StandardLibraryFunction.SELECT, TypeNode.Bool, enumType, enumType);
		STLangSymbolTable.InstallExtensibleFunction("MUX", enumType, StandardLibraryFunction.MUX, TypeNode.AnyInt, enumType, enumType);
		return enumType;
	}

	private List<object> MakeArrayInitList(object initElem)
	{
		List<object> initList = new List<object>();
		if (initElem != null)
		{
			if (initElem is List<object>)
				initList.AddRange((List<object>)initElem);
			else
				initList.Add(initElem);
		}
		return initList;
	}

	private void AddArrayInitElem(List<object> initList, object initElem)
	{
		if (initElem != null)
		{
			if (initElem is List<object>)
				initList.AddRange((List<object>)initElem);
			else
				initList.Add(initElem);
		}
	}

	private List<object> MakeStructInitList(object initElem)
	{
		List<object> initList = new List<object>();
		if (initElem != null)
		{
			if (initElem is List<object>)
				initList.AddRange((List<object>)initElem);
			else
				initList.Add(initElem);
		}
		return initList;
	}

	private void AddStructInitElem(List<object> initList, object initElem)
	{
		if (initElem != null)
		{
			if (initElem is List<object>)
				initList.AddRange((List<object>)initElem);
			else
				initList.Add(initElem);
		}
	}

	private string MakeTypeName(List<SubRange> subRanges, TypeNode elemDataType)
	{
		string intervalList = "";

		foreach (SubRange subrange in subRanges)
		{
			if (intervalList.Length > 0)
				intervalList += ",";
			intervalList += subrange;
		}
		return "ARRAY [" + intervalList + "] OF " + elemDataType.Name;
	}

	private List<SubRange> GetSubRanges(ArrayType array)
	{
		int lower,upper;
		TypeNode elementType = array;
		List<SubRange> subRanges = new List<SubRange>();
		
		while (elementType.IsArrayType)
	    {
			array = (ArrayType)elementType;
			lower = array.LowerBound;
			upper = array.UpperBound;
			elementType = array.ElementType;
			subRanges.Add(new IntSubrange(lower, upper, TypeNode.DInt));
		}
		while (elementType.IsArrayType);
		return subRanges;
	}

	private TypeNode MakeArrayType(List<SubRange> subRanges, TypeNode elemDataType, LexLocation loc1, LexLocation loc2) 
	{
		if (elemDataType.IsFunctionBlockType)
		{
			//
			// Error. IEC 61131-3 does not allow arrays of function blocks.
			//
			this.report.SemanticError(164, loc2);
			return TypeNode.Error;
		}
		else {
			string typeID = "";
			TypeNode arrayDataType;
			foreach (SubRange subrange in subRanges)
			{
				typeID +=  "[" + subrange + "]";
			} 
			typeID += elemDataType.TypeID;
			if (TypeNode.LookUpType(typeID, out arrayDataType))
				return arrayDataType;
			else {
				Expression defaultValue = elemDataType.DefaultValue;
				return this.MakeArrayType(subRanges, elemDataType, defaultValue, loc1);
			}
		}
	}

	private TypeNode MakeArrayType(List<SubRange> subranges, TypeNode basicElementType, Expression initializer, LexLocation loc) 
	{
		if (subranges.Count == 0)
			return basicElementType;
		else {
			SubRange subrange = subranges[0];
			if (! (subrange is IntSubrange))
				return TypeNode.Error;
			else {
				TypeNode arrayDataType;
				TypeNode elementType    = this.MakeArrayType(subranges.Succ(), basicElementType, initializer, loc);
				string typeID           = "[" + subrange + "]" + elementType.TypeID;
			    IntSubrange intSubrange = (IntSubrange)subrange;
				long lower              = intSubrange.LowerBound;
				long upper              = intSubrange.UpperBound;
				string typeName         = this.MakeTypeName(subranges, basicElementType);
				long elementCount       = (upper - lower + 1)*(elementType.Size / basicElementType.Size);
				long byteCount          = elementCount * basicElementType.Size;
				if (byteCount > STLangParameters.MAX_ARRAY_SIZE)
					this.report.SemanticError(113, loc);
				if (TypeNode.LookUpType(typeID, out arrayDataType))
					return arrayDataType;
				else if (basicElementType.IsElementaryType || basicElementType.IsAnyStringType)
				{
					Expression size = MakeIntConstant(byteCount);
					return new ArrayType(typeName, (int)lower, (int)upper, (uint)byteCount, size, elementType, basicElementType, initializer, typeID);
				}
				else if (basicElementType.IsArrayType)
				{
					List<SubRange> subranges2 = new List<SubRange>();
					ArrayType array = (ArrayType)basicElementType.BaseType;
					subranges2.AddRange(subranges);
					subranges2.AddRange(this.GetSubRanges(array));
					return this.MakeArrayType(subranges2, array.BasicElementType, initializer, loc);
				}
				else if (basicElementType.IsStructType)
				{
					string key;
					ArrayType array;
					StructType structure = (StructType)basicElementType.BaseType;
					FieldSymbol field = structure.FirstField;
					Dictionary<string, InitializerList> flattenedInitLists;
					flattenedInitLists = new Dictionary<string, InitializerList>();
					while (field != null)
					{
						key = field.Name.ToUpper();
						array = (ArrayType)this.MakeFlattenedArrayType(elementCount, field.DataType, field.InitialValue);
						flattenedInitLists.Add(key, (InitializerList)array.DefaultValue);
						field = field.Next;
					}
					Expression size = MakeIntConstant(byteCount);
					return new ArrayType(typeName, (int)lower, (int)upper, (uint)byteCount, size, elementType, basicElementType, flattenedInitLists, typeID);
				}
				string msg = "Illegal array element type: " + basicElementType.Name;
				throw new STLangCompilerError(msg);
			}
		}
	}

	private TypeNode MakeFlattenedArrayType(long elementCount, TypeNode elementType, Expression initializer)
	{
		if (elementType.IsElementaryType || elementType.IsAnyStringType)
		{
			string typeID;
			TypeNode arrayDataType;
			int upper = (int)elementCount - 1;

			typeID = "[0.." + upper + "]" + elementType.TypeID;
			if (TypeNode.LookUpType(typeID, out arrayDataType))
				return arrayDataType;
			else {
				long byteCount = elementCount * elementType.Size;
				Expression size = MakeIntConstant(byteCount);
				string typeName = "ARRAY [0.." + upper + "] OF " + elementType.Name;
				return new ArrayType(typeName, 0, upper, (uint)byteCount, size, elementType, elementType, initializer, typeID);
			}
		}
		else if (elementType.IsArrayType)
		{
			ArrayType array2 = (ArrayType)elementType.BaseType;
			TypeNode elementType2 = array2.BasicElementType;
			long elementCount2 = elementCount*(array2.Size/elementType2.Size);
			return this.MakeFlattenedArrayType(elementCount2, elementType2, initializer);
		}
		else if (elementType.IsStructType)
		{
			TypeNode arrayDataType;
			int upper = (int)elementCount - 1;
			string typeID = "[0.." + upper + "]" + elementType.TypeID;
			
			if (TypeNode.LookUpType(typeID, out arrayDataType))
				return arrayDataType;
			else {
				string key;
				ArrayType array;
				StructType structure = (StructType)elementType.BaseType;
				FieldSymbol field = structure.FirstField;
				Dictionary<string, InitializerList> flattenedInitLists;
				flattenedInitLists = new Dictionary<string, InitializerList>();
				while (field != null)
				{
					key = field.Name.ToUpper();
					array = (ArrayType)this.MakeFlattenedArrayType(elementCount, field.DataType, field.InitialValue);
					flattenedInitLists.Add(key, (InitializerList)array.DefaultValue);
					field = field.Next;
				}
				long byteCount = elementCount * elementType.Size;
				Expression size = MakeIntConstant(byteCount);
				string typeName = "ARRAY [0.." + upper + "] OF " + elementType.Name;
				return new ArrayType(typeName, 0, upper, (uint)byteCount, size, elementType, elementType, flattenedInitLists, typeID);
			}
		}
		else
		{
			Expression size = MakeIntConstant(0);
			string typeID = "[0..1]" + elementType.TypeID;
			string typeName = "ARRAY [0..1] OF " + elementType.Name;
			return new ArrayType(typeName, 0, 1, 0, size, elementType, elementType, initializer, typeID);
		}
	}

	private string MakeTypeName(StructDeclaration structure)
	{
		string typeName = string.Empty;
		if (structure.MemberCount < 4)
		{
			foreach (StructMemberDeclaration member in structure.Members)
			{
				if (typeName.Length == 0)
					typeName = "STRUCT (" + member.Name + " : " + member.DataType.Name;
				else 
					typeName += "; " + member.Name + " : " + member.DataType.Name;
			}
		}
		else {
			StructMemberDeclaration member = structure.Members.ElementAt(0);
			typeName = "STRUCT (" + member.Name + " : " + member.DataType.Name;
            member = structure.Members.ElementAt(1);
			typeName += "; " + member.Name + " : " + member.DataType.Name;
            member = structure.Members.ElementAt(structure.MemberCount - 1);
			typeName += "; ... ; " + member.Name + " : " + member.DataType.Name;
		}
		typeName += ")";
		return typeName;
	}

	private TypeNode MakeStructDataType(StructDeclaration structure)
	{
		this.structNestingDepth--;
		if (structure == null || structure.MemberCount == 0)
			return TypeNode.Error;
		else {
			TypeNode structType;
			string typeID = string.Empty;
			
			foreach (StructMemberDeclaration member in structure.Members)
			{
				if (typeID.Length > 0)
					typeID += ",";
				typeID += member.Name.ToUpper() + ":" + member.DataType.TypeID;
			}
			typeID = "(" + typeID + ")";
			if (TypeNode.LookUpType(typeID, out structType))
				return structType;
			else {
				string key;
				uint byteCount = 0;
				FieldSymbol field = null;
				FieldSymbol prevField = null;
				FieldSymbol firstField = null;
				bool isContiguouslyStored = true;
				Dictionary<string, FieldSymbol> members;
				
				members = new Dictionary<string, FieldSymbol>();
				foreach (StructMemberDeclaration member in structure.Members)
				{
					prevField = field;
					field = new FieldSymbol(member.Name, member.DataType, member.InitValue);
					key = member.Name.ToUpper();
					members.Add(key, field);
					if (prevField == null)
                        firstField = field;
					else {
                        prevField.Next = field;
						if (prevField.DataType != field.DataType)
							isContiguouslyStored = false;
					}
					byteCount += member.DataType.Size;
				}
				string typeName = this.MakeTypeName(structure);
				Expression size = MakeIntConstant((long)byteCount);
				return new StructType(members, firstField, byteCount, size, isContiguouslyStored, typeName, typeID);
			}
		}
	}

	private InitializerList ExpandInitializerSequence(TokenInt tokenInt, InitializerList initSequence, LexLocation loc)
	{
		int repetitionFactor = (int)tokenInt.Value;
		if (repetitionFactor == 0)
		{
			this.report.SemanticError(89, loc);
			return initSequence; 
		}
		else if (initSequence != null)
			return initSequence.Expand(repetitionFactor, this.report);
		else {
			TypeNode dataType = this.attributeStack.Top;
			Expression defaultValue = dataType.DefaultValue;
			initSequence = new InitializerSequence(dataType);
			for (int i = repetitionFactor; i > 0; i--)
			{
				initSequence.Add(defaultValue, loc);
			}
			return initSequence;
		}
	}

	private TypeNode GetDerivedType(string typeName, LexLocation location)
	{
		STLangSymbol symbol;

		if (! this.symbolTable.Lookup(typeName, out symbol, location))
		{
			// Error: Undefined identifier

			this.report.SemanticError(151, typeName, location);
			return TypeNode.Error;
		}
		else if (! (symbol.IsDerivedType || symbol.IsFunctionBlock))
		{
			// Error: identifier is not a type name or function block.

			this.report.SemanticError(24, typeName, symbol.TypeName, location);
			return TypeNode.Error;
		}
		else if (symbol.IsFunctionBlock)
		{
			// Check that structure members are not function blocks.

			if (this.structNestingDepth > 0)
				this.report.SemanticError(165, location);
			if (this.isFunctionDecl)
			{
				// Check that the function block can be used in functions. 
				// Function blocks such as timers, counters or edge detectors
				// are illegal because they contain data that are declared 
				// retentive or R_EDGE/F_EDGE.

				StandardFunctionBlockSymbol functionBlockSymbol;
				functionBlockSymbol = (StandardFunctionBlockSymbol)symbol;
				if (functionBlockSymbol.HasRetentiveData) 
					this.report.SemanticError(162, typeName, location);
				if (functionBlockSymbol.HasRFEdgeDetection)
					this.report.SemanticError(163, typeName, location);
			}
		}
		return symbol.DataType;
	}

	private TypeNode MakeStringType(Expression size, LexLocation location)
	{
		if (size == null)
			return TypeNode.String;
		else if (! size.IsConstant && location != null)
		{
			this.report.SemanticError(22, location);
			if (! size.DataType.IsSignedIntType)
				this.report.SemanticError(-5, location);
			return TypeNode.String;
		}
		else if (! size.DataType.IsIntegerType)
		{
			this.report.SemanticError(-5, location);
			return TypeNode.String;
		}
		else {
			int length = Convert.ToInt32(size.Evaluate());
			if (length < 1)
			{
				this.report.SemanticError(22, location);
				return TypeNode.String;
			}
			else if (length > STLangParameters.MAX_STRING_LENGTH)
			{
				this.report.SemanticError(-6, length, location);
				return TypeNode.String;
			}
			else {
				TypeNode stringType;
				string baseTypeID = TypeNode.String.TypeID;
				string typeID = baseTypeID + "[" + length + "]";
				if (TypeNode.LookUpType(typeID, out stringType))
					return stringType;
				else {
					string typeName = "STRING[" + length + "]";
					return new StringType(typeName, length + 1, typeID);
				}
			}
		}
	}

	private TypeNode MakeWStringType(Expression size, LexLocation location)
	{
		if (size == null)
			return TypeNode.WString;
		else if (! size.IsConstant && location != null)
		{
			this.report.SemanticError(22, location);
			if (! size.DataType.IsIntegerType)
				this.report.SemanticError(-5, location);
			return TypeNode.WString;
		}
		else if (! size.DataType.IsIntegerType)
		{
			this.report.SemanticError(-5, location);
			return TypeNode.WString;
		}
		else {
			int length = Convert.ToInt32(size.Evaluate());
			if (length < 1)
			{
				this.report.SemanticError(22, location);
				return TypeNode.WString;
			}
			else if (length > STLangParameters.MAX_WSTRING_LENGTH)
			{
				this.report.SemanticError(-6, length, location);
				return TypeNode.WString;
			}
			else {
				TypeNode stringType;
				string baseTypeID = TypeNode.String.TypeID;
				string typeID = baseTypeID + "[" + length + "]";
				if (TypeNode.LookUpType(typeID, out stringType))
					return stringType;
				else {
					string typeName = "WSTRING[" + length + "]";
					return new WStringType(typeName, length + 1, typeID);
				}
			}
		}
	}

	private Expression MakeTODConstant(TimeSpan timeOfDay)
	{
		if (timeOfDay < TimeSpan.Zero)
			timeOfDay += new TimeSpan(0, 23, 59, 59, 999);
		if (timeOfDay.Days != 0)
			timeOfDay -= new TimeSpan(timeOfDay.Days, 0, 0, 0);
		string stringValue = timeOfDay.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new TimeOfDayConstant(timeOfDay);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenTOD token)
	{
		string stringValue = token.Value.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new TimeOfDayConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TimeSpan time)
	{
		string stringValue = time.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new TimeConstant(time);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenTime token)
	{
		string stringValue = token.Value.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new TimeConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	public static Expression MakeConstant(double value)
	{
		string stringValue = "LREAL#" + value.GetBinaryString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new LRealConstant(value);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	public static Expression MakeConstant(float value)
	{
		string stringValue = "REAL#" + value.GetBinaryString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new RealConstant(value);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenDouble token)
	{
		string stringValue = "LREAL#" + token.Value.GetBinaryString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new LRealConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenInt token)
	{
		string stringValue = token.Value.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = this.MakeIntConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenDate token)
	{
		string stringValue = token.Value.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new DateConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(DateTime dateTime)
	{
		string stringValue = dateTime.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new DateTimeConstant(dateTime);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private Expression MakeConstant(TokenDateTime token)
	{
		string stringValue = token.Value.ToString();
		if (constantTable.ContainsKey(stringValue))
			return (Expression)constantTable[stringValue];
		else
		{
			Expression expr = new DateTimeConstant(token);
			constantTable[stringValue] = expr;
			return expr;
		}
	}

	private void PushFieldType(string field, LexLocation location)
	{
		this.attributeStack.PushFieldType(field, location);
	}

	private void CheckNestingDepth(LexLocation location)
	{
		this.structNestingDepth++;
		if (this.structNestingDepth == STLangParameters.MAX_STRUCT_NESTING_DEPTH + 1)
			this.report.SemanticError(115, location);
	}

	private SubrangeLabel CheckSubRangeTypes(TypeNode selectorDataType, SubRange subRange, LexLocation loc)
	{
		SubRange selectorSubrange = selectorDataType.GetSubrange();
		if (selectorSubrange.Contains(subRange))
			return new SubrangeLabel(subRange);
		else if (selectorSubrange.IsDisjoint(subRange))
		{
			this.report.SemanticError(-3, subRange.ToString(), selectorDataType.Name, loc);
			return new SubrangeLabel(subRange);
		}
		else {
			this.report.Warning(14, subRange.ToString(), loc);
			return new SubrangeLabel(subRange);
		}
	}

	private NumericLabel CheckSubRangeTypes(TypeNode selectorDataType, Expression caseLabel, LexLocation loc)
	{
		SubRange selectorSubrange = selectorDataType.GetSubrange();
		if (selectorSubrange.Contains(caseLabel))
			return new NumericLabel(caseLabel);
		else {
			this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, loc);
			return null;
		}
	}

	private Expression CheckCtrlExpression(LexLocation location, Expression expression = null)
	{
		if (expression == null)
		{
			this.Push(Expression.Error);
			expression = Expression.Error;
		}
		else if (expression is FunctionName)
		{
			this.Push(Expression.Error);
			expression = Expression.Error;
			this.report.SemanticError(148, expression.ToString(), location);
		}
		else {
			TypeNode ctrlExpressionType = expression.DataType;
			if (ctrlExpressionType == TypeNode.Error)
				this.Push(Expression.Error);
			else if (ctrlExpressionType.IsOrdinalType)
				this.Push(expression);
			else {
				this.report.SemanticError(147, location);
				this.Push(Expression.Error);
			}
		}
		this.PushCaseLabelList();
		this.CheckForEndOfCaseStatList();
		return expression;
	}

	private NumericLabel CheckCaseLabel(Expression caseLabel, LexLocation location)
	{
		if (caseLabel == null)
			return null;
		else if (caseLabel is FunctionName)
		{
			this.report.SemanticError(32, caseLabel.ToString(), location);
			return null;
		}
		else if (caseLabel.DataType == TypeNode.Error)
			return null;
		else if (! caseLabel.IsConstant)
		{
			this.report.SemanticError(32, caseLabel.ToString(), location);
			if (! caseLabel.DataType.IsOrdinalType)
				this.report.SemanticError(31, caseLabel.ToString(), location);
			return null;
		}
		else {
			TypeNode labelDataType = caseLabel.DataType;
			TypeNode selectorDataType = this.attributeStack.Top;	

			if (labelDataType == TypeNode.Error)
				return null;
			else if (! labelDataType.IsOrdinalType)
			{
				this.report.SemanticError(31, caseLabel.ToString(), location);
				return null;
			}
			else if (selectorDataType == TypeNode.Error)
				return new NumericLabel(caseLabel);
			else if (selectorDataType == labelDataType)
			{
				if (selectorDataType.IsSubrangeType)
				{
					if (selectorDataType.IsSignedIntType)
					{
						long numericValue = Convert.ToInt64(caseLabel.Evaluate());
						if (! selectorDataType.IsInRange(numericValue))
						{
							string strValue = caseLabel.ToString();
							string typeName = selectorDataType.Name;
							this.report.SemanticError(171, strValue, typeName, location);
						}
					}
					else {
						ulong numericValue = Convert.ToUInt64(caseLabel.Evaluate());
						if (! selectorDataType.IsInRange(numericValue))
						{
							string strValue = caseLabel.ToString();
							string typeName = selectorDataType.Name;
							this.report.SemanticError(171, strValue, typeName, location);
						}
					}
				}
				return new NumericLabel(caseLabel);
			}
			else if (selectorDataType.IsSignedIntType && labelDataType.IsSignedIntType)
			{
				if (selectorDataType.Size < labelDataType.Size)
					this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
				else {
					// Convert case label type to selector type

					long value = Convert.ToInt64(caseLabel.Evaluate());
					if (selectorDataType == TypeNode.Int)
						caseLabel = new IntConstant((short)value);
					else if (selectorDataType == TypeNode.DInt)
						caseLabel = new DIntConstant((int)value);
					else
						caseLabel = new LIntConstant(value);
				}
				return new NumericLabel(caseLabel);
			}
			else if (selectorDataType.IsUnsignedIntType && labelDataType.IsUnsignedIntType)
			{
				if (selectorDataType.Size < labelDataType.Size)
					this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
				else {
					// Convert case label type to selector type

					ulong value = Convert.ToUInt64(caseLabel.Evaluate());
					if (selectorDataType == TypeNode.UInt)
						caseLabel = new UIntConstant((ushort)value);
					else if (selectorDataType == TypeNode.DInt)
						caseLabel = new UDIntConstant((uint)value);
					else
						caseLabel = new ULIntConstant(value);
				}
				return new NumericLabel(caseLabel);
			}
			else if (selectorDataType.IsUnsignedIntType && labelDataType.IsSignedIntType)
			{
				if (selectorDataType.Size < labelDataType.Size)
					this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
				else {
					// Convert case label type to selector type

					long value = Convert.ToInt64(caseLabel.Evaluate());
					if (value < 0)
						this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
					else if (selectorDataType == TypeNode.UInt)
						caseLabel = new UIntConstant((ushort)value);
					else if (selectorDataType == TypeNode.DInt)
						caseLabel = new UDIntConstant((uint)value);
					else
						caseLabel = new ULIntConstant((ulong)value);
				}
				return new NumericLabel(caseLabel);
			}
			else if (selectorDataType.IsBitStringType && labelDataType.IsBitStringType)
			{
				if (selectorDataType.Size < labelDataType.Size)
					this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
				else {
					// Convert case label type to selector type

					ulong value = Convert.ToUInt64(caseLabel.Evaluate());
					if (selectorDataType == TypeNode.Word)
						caseLabel = new WordConstant((ushort)value);
					else if (selectorDataType == TypeNode.DWord)
						caseLabel = new DWordConstant((uint)value);
					else
						caseLabel = new LWordConstant(value);
				}
				return new NumericLabel(caseLabel);
			}
			else if (selectorDataType.IsBitStringType && labelDataType.IsIntegerType)
			{
				if (selectorDataType.Size < labelDataType.Size)
					this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
				else {
					// Convert case label type to selector type

					long value = Convert.ToInt64(caseLabel.Evaluate());
					if (value < 0)
						this.report.SemanticError(108, caseLabel.ToString(), selectorDataType.Name, location);
					else if (selectorDataType == TypeNode.Word)
						caseLabel = new UIntConstant((ushort)value);
					else if (selectorDataType == TypeNode.DWord)
						caseLabel = new DWordConstant((uint)value);
					else
						caseLabel = new LWordConstant((ulong)value);
				}
				return new NumericLabel(caseLabel);
			}
			this.report.SemanticError(86, caseLabel.ToString(), labelDataType.Name, selectorDataType.Name, location);
			return null;
		}
	}

	private TypeNode GetBaseType(TypeNode baseType)
	{
		if (baseType is DerivedType)
			return GetBaseType(((DerivedType)baseType).BaseType);
		else if (baseType is EnumeratedType)
			return ((EnumeratedType)baseType).BaseType;
		else
			return baseType;
	}

	private SubrangeLabel CheckCaseLabel(SubRange subRange, LexLocation location)
	{
		if (subRange == null)
			return null;
		else {
			TypeNode selectorDataType = this.attributeStack.Top;
			TypeNode labelDataType = subRange.DataType;
			if (labelDataType == TypeNode.Error)
				return null;
			else if (! labelDataType.IsOrdinalType)
			{
				this.report.SemanticError(31, subRange.ToString(), location);
				return null;
			}
			else if (selectorDataType == TypeNode.Error)
				return new SubrangeLabel(subRange);
			else if (! selectorDataType.IsOrdinalType)
				return new SubrangeLabel(subRange);
			else if (selectorDataType == labelDataType)
			{
                SubRange selectorSubRange = selectorDataType.GetSubrange();
                if (selectorSubRange.IsDisjoint(subRange))
                {
					string subRangeStr = subRange.ToString();
                    string selDataTypeName = selectorDataType.Name;
                    this.report.SemanticError(172, subRangeStr, selDataTypeName, location);
                }
				else if (! selectorSubRange.Contains(subRange))
                {
                    string subRangeStr = subRange.ToString();
                    string selDataTypeName = selectorDataType.Name;
                    this.report.Warning(14, subRangeStr, selDataTypeName, location);
                }
                return new SubrangeLabel(subRange);
            }
			else if (selectorDataType.IsSignedIntType && (subRange is IntSubrange))
			{
				if (selectorDataType.Size == labelDataType.Size)
					return CheckSubRangeTypes(selectorDataType, subRange, location);
				else if (selectorDataType.Size < labelDataType.Size)
				{
					this.report.SemanticError(108, subRange.ToString(), selectorDataType.Name, location);
					return null;
				}
				else {
					// Convert subrange type to selector type
					IntSubrange intSubrange = (IntSubrange)subRange;
					long lowerBound = intSubrange.LowerBound;
					long upperBound = intSubrange.UpperBound;
					intSubrange     = new IntSubrange(lowerBound, upperBound, selectorDataType);
					return new SubrangeLabel(intSubrange);
				}
			}
			else if (selectorDataType.IsUnsignedIntType && (subRange is UIntSubrange))
			{
				if (selectorDataType.Size == labelDataType.Size)
					return CheckSubRangeTypes(selectorDataType, subRange, location);
				else if (selectorDataType.Size < labelDataType.Size)
				{
					this.report.SemanticError(108, subRange.ToString(), selectorDataType.Name, location);
					return null;
				}
				else {
				    // Convert subrange type to selector type
					UIntSubrange uintSubrange = (UIntSubrange)subRange;
					ulong lowerBound = uintSubrange.LowerBound;
					ulong upperBound = uintSubrange.UpperBound;
					uintSubrange     = new UIntSubrange(lowerBound, upperBound, selectorDataType);
					return new SubrangeLabel(uintSubrange);
				}
			}
			else if (selectorDataType.IsUnsignedIntType && labelDataType.IsSignedIntType)
			{
				if (selectorDataType.Size < labelDataType.Size)
				{
					this.report.SemanticError(108, subRange.ToString(), selectorDataType.Name, location);
					return null;
				}
				else {
				    IntSubrange intSubrange = (IntSubrange)subRange;
					long lowerBound = intSubrange.LowerBound;
					long upperBound = intSubrange.UpperBound;
					UIntSubrange uintSubrange = new UIntSubrange((ulong)lowerBound, (ulong)upperBound, selectorDataType); 
					if (selectorDataType.Size > labelDataType.Size)
						return new SubrangeLabel(uintSubrange);
					else
						return CheckSubRangeTypes(selectorDataType, uintSubrange, location);
				}
			}
			else if (selectorDataType.IsBitStringType && labelDataType.IsBitStringType)
			{
				if (selectorDataType.Size == labelDataType.Size)
					return CheckSubRangeTypes(selectorDataType, subRange, location);
				else if (selectorDataType.Size < labelDataType.Size)
				{
					this.report.SemanticError(108, subRange.ToString(), selectorDataType.Name, location);
					return null;
				}
				else {
					// Convert subrange type to selector type
					BitStringSubrange bitStringSubrange = (BitStringSubrange)subRange;
					ulong lowerBound  = bitStringSubrange.LowerBound;
					ulong upperBound  = bitStringSubrange.UpperBound;
					bitStringSubrange = new BitStringSubrange(lowerBound, upperBound, selectorDataType);
					return new SubrangeLabel(bitStringSubrange);
				}
			}
			else if (selectorDataType.IsBitStringType && (subRange is UIntSubrange))
			{
				if (selectorDataType.Size < labelDataType.Size)
				{
					this.report.SemanticError(108, subRange.ToString(), selectorDataType.Name, location);
					return null;
				}
				else {
					UIntSubrange uintSubrange = (UIntSubrange)subRange;
					ulong lowerBound = uintSubrange.LowerBound;
					ulong upperBound = uintSubrange.UpperBound;
					uintSubrange     = new UIntSubrange(lowerBound, upperBound, selectorDataType); 
					if (selectorDataType.Size > labelDataType.Size)
						return new SubrangeLabel(uintSubrange);
					else
						return CheckSubRangeTypes(selectorDataType, uintSubrange, location);
				}
			}
			else if (selectorDataType.IsEnumeratedType && labelDataType.IsEnumeratedType)
			{
				EnumeratedType enumSelectorType = (EnumeratedType)this.GetBaseType(selectorDataType);
				EnumeratedType enumLabelType = (EnumeratedType)this.GetBaseType(labelDataType);

				if (enumSelectorType.BaseType != enumLabelType.BaseType)
				{
					this.report.SemanticError(86, subRange.ToString(), selectorDataType.Name, labelDataType.Name, location);
					return null;
				}
				else {
					SubRange selectorSubrange = selectorDataType.GetSubrange();
					if (selectorSubrange.Contains(subRange))
						return new SubrangeLabel(subRange);
					else if (selectorSubrange.IsDisjoint(subRange))
					{
						this.report.SemanticError(-3, subRange.ToString(), selectorDataType.Name, location);
						return new SubrangeLabel(subRange);
					}
					else {
						this.report.Warning(14, subRange.ToString(), location);
						return new SubrangeLabel(subRange);
					}
				}
			}
			else {
				this.report.SemanticError(86, selectorDataType.Name, subRange.ToString(), location);
				return null;
			}
		}
	}

	private void InstallDerivedType(string typeName, DataTypeSpec typeSpec, LexLocation location)
	{
		if (this.symbolTable.IsValidUserDefinedSymbol(typeName, location))
		{
			TypeNode baseType = typeSpec.DataType;
			Expression initialValue = typeSpec.InitialValue;
			this.symbolTable.InstallDerivedType(typeName, baseType, initialValue);
		}
		this.derivedTypeName = "";
	}

	private Expression MakeRealAddOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			float leftValue = Convert.ToSingle(left.Evaluate());
			if (leftValue == 0.0f)
				return right;
			else if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				float sum = leftValue + rightValue;
					
				if (float.IsPositiveInfinity(sum) || float.IsNegativeInfinity(sum))
				{
					sum = float.NaN;
					string text = left.ToString() + " + " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(sum);
			}
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return left;
			else if (rightValue < 0.0f)
			{
				right = MakeConstant(-rightValue);
				return new RealSubOperator(left, right);
			}
		}
		else if (right is RealUnaryMinusOperator)
		{
			right = ((UnaryOperator)right).Operand;
			Expression expr = new RealSubOperator(left, right);
		}
		return new RealAddOperator(left, right);
	}

	private Expression MakeLRealAddOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (Math.Abs(leftValue) == 0.0d)
				return right;
			else if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				double sum = leftValue + rightValue;
					
				if (double.IsPositiveInfinity(sum) || double.IsNegativeInfinity(sum))
				{
					sum = double.NaN;
					string text = left.ToString() + " + " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(sum);
			}
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (Math.Abs(rightValue) == 0.0d)
				return left;
			else if (rightValue < 0.0d)
			{
				right = MakeConstant(-rightValue);
				return new RealSubOperator(left, right);
			}
		}
		else if (right is LRealUnaryMinusOperator)
		{
			UnaryOperator unaryMinus = (UnaryOperator)right;
			return new LRealSubOperator(left, unaryMinus.Operand);
		}
		return new LRealAddOperator(left, right);
	}

	private Expression MakeIntAddOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (leftValue == 0)
				return right;
			else if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				if (rightValue == 0)
					return left;
				else {
					long sum = leftValue + rightValue;
					return MakeIntConstant(sum);
				}
			}
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return left;
		}
		else if (right is IntUnaryMinusOperator)
		{
			UnaryOperator unaryMinus = (UnaryOperator)right;
			return this.MakeIntSubOp(left, unaryMinus.Operand);
		}
		if (left.DataType == right.DataType)
			return new IntAddOperator(left, right, left.DataType);
		else if (left.DataType == TypeNode.LInt)
			return new IntAddOperator(left, this.MakeInt2LInt(right), TypeNode.LInt);
		else if (right.DataType == TypeNode.LInt)
			return new IntAddOperator(this.MakeInt2LInt(left), right, TypeNode.LInt);
		else {
			TypeNode resDataType = this.LargestDataType(left, right);
			return new IntAddOperator(left, right, resDataType);
		}	
	}

	private Expression MakeUIntAddop(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (leftValue == 0)
				return right;
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				if (rightValue == 0)
					return left;
				else {
					ulong sum = leftValue + rightValue;
					return this.MakeIntConstant(sum);
				}
			}
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return left;
		}
		TypeNode resultDataType = this.LargestDataType(left, right);
		return new UIntAddOperator(left, right, resultDataType);		
	}

	private Expression MakeIntUIntAddop(Expression left, Expression right, LexLocation location)
	{
		TypeNode resultDataType;
		if (left.DataType.Size > right.DataType.Size)
			resultDataType = left.DataType;
		else if (right.DataType == TypeNode.USInt)
			resultDataType = TypeNode.Int;
		else if (right.DataType == TypeNode.UInt)
			resultDataType = TypeNode.DInt;
		else if (right.DataType == TypeNode.UDInt)
			resultDataType = TypeNode.LInt;
		else {
			this.report.SemanticError(14, "+", left.DataType.Name, right.DataType.Name, location);
			return Expression.Error;
		}
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (leftValue == 0)
				return right;
			else if (right.IsConstant)
			{
				uint rightValue = Convert.ToUInt32(right.Evaluate());
				long sum = leftValue + rightValue;
				return MakeIntConstant(sum);
			}
		}
		else if (right.IsConstant)
		{
			uint rightValue = Convert.ToUInt32(right.Evaluate());
			if (rightValue == 0)
				return left;
		}
		return new IntAddOperator(left, right, resultDataType);
	}

	private Expression MakeLeftShiftOp(Expression expression, int power)
	{
		if (expression == null)
			return Expression.Error;
		else if (! expression.IsConstant)
			return new LeftShiftOperator(expression, power);
		else if (expression.DataType.IsSignedIntType)
		{
			long intValue = Convert.ToInt64(expression.Evaluate());
			return MakeIntConstant(intValue << power);
		}
		else {
			ulong intValue = Convert.ToUInt64(expression.Evaluate());
			return this.MakeIntConstant(intValue << power);
		}
	}

	private Expression MakeReal2LReal(Expression expression)
	{
		if (expression == null)
			return Expression.Error;
		else if (expression.DataType != TypeNode.Real)
			throw new STLangCompilerError("MakeReal2LReal() expects Real argument: " + expression);
		else if (! expression.IsConstant)
			return new Real2LRealOperator(expression);
		else
		{
			double value = Convert.ToDouble(expression.Evaluate());
			return MakeConstant(value);
		}
	}

	private Expression MakeLReal2Real(Expression expression)
	{
		if (expression == null)
			return Expression.Error;
		else if (expression.DataType != TypeNode.LReal)
			throw new STLangCompilerError("MakeLReal2Real() expects LReal argument: " + expression);
		else if (! expression.IsConstant)
			return new LReal2RealOperator(expression);
		else
		{
			float value = Convert.ToSingle(expression.Evaluate());
			return MakeConstant(value);
		}
	} 

	private Expression MakeInt2Real(Expression expression)
	{
		if (expression == null)
			return Expression.Error;
		else if (! expression.DataType.IsIntegerType)
			throw new STLangCompilerError("MakeInt2Real() expects integer argument: " + expression);
		else if (expression.IsConstant)
		{
			float value = Convert.ToSingle(expression.Evaluate());
			return MakeConstant(value);
		}
		else if (expression.DataType.Size == TypeNode.LInt.Size)
			return new LInt2RealOperator(expression);
		else
			return new Int2RealOperator(expression);
	}

	private Expression MakeInt2LReal(Expression expression)
	{
		if (expression == null)
			return Expression.Error;
		else if (! expression.DataType.IsIntegerType)
			throw new STLangCompilerError("MakeInt2LReal() expects integer argument: " + expression);
		else if (expression.IsConstant)
		{
			double value = Convert.ToDouble(expression.Evaluate());
			return MakeConstant(value);
		}
		else if (expression.DataType.Size == TypeNode.LInt.Size)
			return new LInt2LRealOperator(expression);
		else
			return new Int2LRealOperator(expression);
	}

	private Expression MakeInt2LInt(Expression expression)
	{
		if (expression == null)
			return Expression.Error;
		else if (! expression.DataType.IsIntegerType)
			throw new STLangCompilerError("MakeInt2LInt() expects integer argument: " + expression);
		else if (expression.IsConstant)
		{
			long value = Convert.ToInt64(expression.Evaluate());
			return new LIntConstant(value);
		}
		else if (expression.DataType.Size <= TypeNode.DInt.Size)
			return new Int2LIntOperator(expression);
		else
			return expression;
	}

	private Expression MakeTTAddOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			if (leftValue == TimeSpan.Zero)
				return right;
			else if (right.IsConstant)
			{
				TimeSpan rightValue = (TimeSpan)right.Evaluate();
				if (rightValue == TimeSpan.Zero)
					return left;
				else {
					TimeSpan sum; 
					try {
						sum = leftValue.Add(rightValue);
					}
					catch (System.OverflowException)
					{
						sum = TimeSpan.Zero;
						string text = left.ToString() + " + " + right.ToString();
						this.report.SemanticError(117, text, location);
					}
					return this.MakeConstant(sum);
				}
			}
		}
		else if (right.IsConstant)
		{
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			if (rightValue == TimeSpan.Zero)
				return left;
		}
		return new TTAddOperator(left, right);
	}

	private Expression MakeDTTimeAddOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			DateTime leftValue = Convert.ToDateTime(left.Evaluate());
			if (right.IsConstant)
			{
				TimeSpan rightValue = (TimeSpan)right.Evaluate();
				if (rightValue == TimeSpan.Zero)
					return left;
				else {
					DateTime sum; 
					try {
						sum = leftValue.Add(rightValue);
					}
					catch (System.ArgumentOutOfRangeException )
					{
						sum = DateTime.MinValue;
						string text = left.ToString() + " + " + right.ToString();
						this.report.SemanticError(117, text, location);
					}
					return this.MakeConstant(sum);
				}
			}
		}
		else if (right.IsConstant)
		{
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			if (rightValue == TimeSpan.Zero)
				return left;
		}
		return new DTTAddOperator(left, right);
	}

	private Expression MakeTTODAddOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			if (leftValue == TimeSpan.Zero)
				return right;
			else if (right.IsConstant)
			{
				TimeSpan timeOfDay; 
				TimeSpan rightValue = (TimeSpan)right.Evaluate();
				if (leftValue.Days != 0)
					leftValue -= new TimeSpan(leftValue.Days, 0, 0, 0);
				try {
					TimeSpan sum = leftValue.Add(rightValue);
					if (sum < TimeSpan.Zero)
						sum = sum.Add(new TimeSpan(0, 23, 59, 59, 999));
					int hours = sum.Hours;
					int minutes = sum.Minutes;
					int seconds = sum.Seconds;
					if (sum.Milliseconds == 0)
						timeOfDay = new TimeSpan(hours, minutes, seconds);
					else
						timeOfDay = new TimeSpan(hours, minutes, seconds, sum.Milliseconds);
				}
				catch (System.OverflowException)
				{
					timeOfDay = TimeSpan.Zero;
					string text = left.ToString() + " + " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeTODConstant(timeOfDay);
			}
		}
		else if (right.IsConstant)
		{
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			if (rightValue == TimeSpan.Zero)
				return left;
		}
		return new TTODAddOperator(left, right);
	}

	private Expression MakeIntSubOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				long difference = leftValue - rightValue;
				return MakeIntConstant(difference);
			}
			else if (leftValue == 0)
			{
				if (right is IntUnaryMinusOperator)
					return ((UnaryOperator)right).Operand;
				else 
					return new IntUnaryMinusOperator(right);
			}
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return left;
			else if (rightValue < 0)
			{
				right = MakeIntConstant(-rightValue);
				return this.MakeIntAddOp(left, right);
			}
		}
		else if (right is IntUnaryMinusOperator)
		{
			right = ((UnaryOperator)right).Operand;
			return this.MakeIntAddOp(left, right);
		}
		if (left.DataType == right.DataType)
			return new IntSubOperator(left, right, left.DataType);
		else if (left.DataType == TypeNode.LInt)
			return new IntSubOperator(left, this.MakeInt2LInt(right), TypeNode.LInt);
		else if (right.DataType == TypeNode.LInt)
			return new IntSubOperator(this.MakeInt2LInt(left), right, TypeNode.LInt);
		else {
			TypeNode resDataType = this.LargestDataType(left, right);
			return new IntSubOperator(left, right, resDataType);
		}	
	}

	private Expression MakeIntUIntSubOp(Expression left, Expression right, LexLocation location)
	{
		TypeNode resultDataType;
	
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				uint rightValue = Convert.ToUInt32(right.Evaluate());
				long difference = leftValue - rightValue;
				return MakeIntConstant(difference);
			}
		}
		if (left.DataType.Size > right.DataType.Size)
			resultDataType = left.DataType;
		else if (right.DataType == TypeNode.USInt)
			resultDataType = TypeNode.Int;
		else if (right.DataType == TypeNode.UInt)
			resultDataType = TypeNode.DInt;
		else if (right.DataType == TypeNode.UDInt)
			resultDataType = TypeNode.LInt;
		else {
			this.report.SemanticError(14, "-", left.DataType.Name, right.DataType.Name, location);
			return Expression.Error;
		}
		 return new UIntAddOperator(left, right, resultDataType);
	}

	private Expression MakeUIntSubOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (leftValue == 0)
				return right;
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				if (rightValue == 0)
					return left;
				else {
					ulong difference = leftValue - rightValue;
					return this.MakeIntConstant(difference);
				}
			}
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return left;
		}
		TypeNode resultDataType = this.LargestDataType(left, right);
		return new UIntSubOperator(left, right, resultDataType);		
	}

	private Expression MakeRealSubOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			float leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				float diff = leftValue - rightValue;
				if (float.IsPositiveInfinity(diff) || float.IsNegativeInfinity(diff))
				{
					diff = float.NaN;
					string text = left.ToString() + " - " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(diff);
			}
			else if (leftValue == 0.0f)
				return new RealUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return left;
		}
		else if (left is RealUnaryMinusOperator)
		{
			if (right is RealUnaryMinusOperator)
			{
				right = ((UnaryOperator)right).Operand;
				return new RealSubOperator(right, left);
			}
			else {
				left = ((UnaryOperator)left).Operand;
				Expression expr = new RealAddOperator(left, right);
				return new RealUnaryMinusOperator(expr);
			}
		}
		else if (right is RealUnaryMinusOperator)
		{
			right = ((UnaryOperator)right).Operand;
			return new RealAddOperator(left, right);
		}
		return new RealSubOperator(left, right);
	}

	private Expression MakeLRealSubOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				double diff = leftValue - rightValue;
				if (double.IsPositiveInfinity(diff) || double.IsNegativeInfinity(diff))
				{
					diff = double.NaN;
					string text = left.ToString() + " - " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(diff);
			}
			else if (leftValue == 0.0d)
				return new LRealUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return left;
		}
		else if (left is LRealUnaryMinusOperator)
		{
			if (right is LRealUnaryMinusOperator)
			{
				right = ((UnaryOperator)right).Operand;
				return new LRealSubOperator(right, left);
			}
			else {
				left = ((UnaryOperator)left).Operand;
				Expression expr = new LRealAddOperator(left, right);
				return new LRealUnaryMinusOperator(expr);
			}
		}
		else if (right is LRealUnaryMinusOperator)
		{
			right = ((UnaryOperator)right).Operand;
			return new LRealAddOperator(left, right);
		}
		return new LRealSubOperator(left, right);
	}

	private Expression MakeTimeSubOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			if (right.IsConstant)
			{
				TimeSpan difference;
				try {
					TimeSpan rightValue = (TimeSpan)right.Evaluate();
					difference = leftValue.Subtract(rightValue);
				}
				catch (System.OverflowException)
				{
					difference = TimeSpan.Zero;
					string text = left.ToString() + " - " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeConstant(difference);
			}
			else if (leftValue == TimeSpan.Zero)
				return new TimeUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			if (rightValue == TimeSpan.Zero)
				return left;
		}
		return new TimeSubOperator(left, right);
	}

	private Expression MakeDateTimeTimeSubOp(Expression left, Expression right, LexLocation location)
	{
		 if (! left.IsConstant || ! right.IsConstant)
			return new DTTimeSubOperator(left, right);
		else {
			DateTime difference;
			DateTime dateTime = Convert.ToDateTime(left.Evaluate());
			try {
				TimeSpan timeSpan =(TimeSpan)right.Evaluate();
				difference = dateTime.Subtract(timeSpan);
			}
			catch (System.ArgumentOutOfRangeException)
			{
				difference = DateTime.MinValue;
				string text = left.ToString() + " - " + right.ToString();
				this.report.SemanticError(118, text, location);
			}
			return this.MakeConstant(difference);
		}
	}

	private Expression MakeDateTimeSubOp(Expression left, Expression right, LexLocation location)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new DateTimeSubOperator(left, right);
		else {
			TimeSpan difference;
			DateTime leftValue = Convert.ToDateTime(left.Evaluate());
			try {
				DateTime rightValue = Convert.ToDateTime(right.Evaluate());
				difference = leftValue.Subtract(rightValue);
			}
			catch (System.ArgumentOutOfRangeException)
			{
				difference = TimeSpan.Zero;
				string text = left.ToString() + " - " + right.ToString();
				this.report.SemanticError(118, text, location);
			}
			return this.MakeConstant(difference);
		}
	}

	private Expression MakeDateSubOp(Expression left, Expression right, LexLocation location)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new DateSubOperator(left, right);
		else {
			TimeSpan difference;
			DateTime leftValue = Convert.ToDateTime(left.Evaluate());
			try {
				DateTime rightValue = Convert.ToDateTime(right.Evaluate());
				difference = leftValue.Subtract(rightValue);
			}
			catch (System.ArgumentOutOfRangeException)
			{
				difference = TimeSpan.Zero;
				string text = left.ToString() + " - " + right.ToString();
				this.report.SemanticError(118, text, location);
			}
			return this.MakeConstant(difference);
		}
	}

	private Expression MakeTimeOfDaySubOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant && right.IsConstant)
		{
			TimeSpan difference;
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			
			try {
				TimeSpan rightValue = (TimeSpan)right.Evaluate();
				difference = leftValue.Subtract(rightValue);
			}
			catch (System.OverflowException)
			{
				difference = TimeSpan.Zero;
				string text = left.ToString() + " - " + right.ToString();
				this.report.SemanticError(119, text, location);
			}
			return this.MakeConstant(difference);
		}
		return new TimeOfDaySubOperator(left, right);
	}

	private Expression MakeTimeOfDayTimeSubOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			if (leftValue == TimeSpan.Zero)
				return right;
			else if (right.IsConstant)
			{
				TimeSpan difference;
			
				try {
					TimeSpan rightValue = (TimeSpan)right.Evaluate();
					difference = leftValue.Subtract(rightValue);
				}
				catch (System.OverflowException)
				{
					difference = TimeSpan.Zero;
					string text = left.ToString() + " - " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeConstant(difference);
			}
		}
		return new TODTimeSubOperator(left, right);
	}

	private Expression MakeIntMulOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			
			if (leftValue == 0)
				return MakeIntConstant(0);
			else if (leftValue == 1)
				return right;
			else if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				long product = leftValue * rightValue;
				return MakeIntConstant(product);
			}
			else if (leftValue == -1)
				return new IntUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return MakeIntConstant(0);
			else if (rightValue == 1)
				return left;
			else if (rightValue == -1)
				return new IntUnaryMinusOperator(left);
		}
		else if ((left is IntUnaryMinusOperator) && (right is IntUnaryMinusOperator))
		{
			left = ((UnaryOperator)left).Operand;
			right = ((UnaryOperator)right).Operand;
		}
		if (left.DataType == right.DataType)
			return new IntMulOperator(left, right, left.DataType);
		else if (left.DataType == TypeNode.LInt)
			return new IntMulOperator(left, this.MakeInt2LInt(right), TypeNode.LInt);
		else if (right.DataType == TypeNode.LInt)
			return new IntMulOperator(this.MakeInt2LInt(left), right, TypeNode.LInt);
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			return new IntMulOperator(left, right, resultDataType);
		}
	}

	private Expression MakeUIntMulop(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			
			if (leftValue == 0)
				return MakeIntConstant((ulong)0);
			else if (leftValue == 1)
				return right;
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				ulong product = leftValue * rightValue;
				return this.MakeIntConstant(product);
			}
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return this.MakeIntConstant((ulong)0);
			else if (rightValue == 1)
				return left;
		}
		if (left.DataType == right.DataType)
			return new UIntMulOperator(left, right, left.DataType);
		else if (left.DataType == TypeNode.LInt)
			return new UIntMulOperator(left, this.MakeInt2LInt(right), TypeNode.LInt);
		else if (right.DataType == TypeNode.LInt)
			return new UIntMulOperator(this.MakeInt2LInt(left), right, TypeNode.LInt);
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			return new UIntMulOperator(left, right, resultDataType);
		}
	}

	private Expression MakeIntUIntMulop(Expression left, Expression right, LexLocation location)
	{
		TypeNode resultDataType;
		if (left.DataType.Size > right.DataType.Size)
			resultDataType = left.DataType;
		else if (right.DataType == TypeNode.USInt)
			resultDataType = TypeNode.Int;
		else if (right.DataType == TypeNode.UInt)
			resultDataType = TypeNode.DInt;
		else if (right.DataType == TypeNode.UDInt)
			resultDataType = TypeNode.LInt;
		else {
			this.report.SemanticError(14, "*", left.DataType.Name, right.DataType.Name, location);
			return Expression.Error;
		}
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (leftValue == 0)
				return MakeIntConstant(0);
			else if (leftValue == 1)
				return right;
			else if (right.IsConstant)
			{
				uint rightValue = Convert.ToUInt32(right.Evaluate());
				long product = leftValue * rightValue;
				return MakeIntConstant(product);
			}
			else if (leftValue == -1)
				return right;
		}
		else if (right.IsConstant)
		{
			uint rightValue = Convert.ToUInt32(right.Evaluate());
			if (rightValue == 0)
				return MakeIntConstant(0);
			else if (rightValue == 1)
				return left;
		}
		return new IntMulOperator(left, right, resultDataType);
	}

	private Expression MakeRealMulOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			float leftValue = Convert.ToSingle(left.Evaluate());
			if (leftValue == 0.0f)
				return MakeConstant(0.0f);
			else if (leftValue == 1.0f)
				return right;
			else if (right.IsConstant)
			{
				float product;

				try {
					float rightValue = Convert.ToSingle(right.Evaluate());
					product = leftValue * rightValue;
				}
				catch (System.OverflowException)
				{
					product = float.NaN;
					string text = left.ToString() + " * " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(product);
			}
			else if (leftValue == -1.0f)
				return new RealUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return MakeConstant(0.0f);
			else if (rightValue == 1.0f)
				return left;
			else if (rightValue == -1.0f)
				return new RealUnaryMinusOperator(left);
		}
		return new RealMulOperator(left, right);
	}

	private Expression MakeLRealMulOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (leftValue == 0.0d)
				return MakeConstant(0.0d);
			else if (leftValue == 1.0d)
				return right;
			else if (right.IsConstant)
			{
				double product;

				try {
					double rightValue = Convert.ToDouble(right.Evaluate());
					product = leftValue * rightValue;
				}
				catch (System.OverflowException)
				{
					product = double.NaN;
					string text = left.ToString() + " * " + right.ToString();
					this.report.SemanticError(116, text, location);
				}
				return MakeConstant(product);
			}
			else if (leftValue == -1.0d)
				return new LRealUnaryMinusOperator(right);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return MakeConstant(0.0d);
			else if (rightValue == 1.0d)
				return left;
			else if (rightValue == -1.0d)
				return new LRealUnaryMinusOperator(left);
		}
		return new LRealMulOperator(left, right);
	}

	private Expression MakeIntTimeMulOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan timeSpan = (TimeSpan)left.Evaluate();
			
			if (timeSpan == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
			else if (right.IsConstant)
			{
				long factor = Convert.ToInt64(right.Evaluate());
				long ticks = timeSpan.Ticks * factor;
				if (ticks < TimeSpan.MinValue.Ticks || ticks > TimeSpan.MaxValue.Ticks)
				{
					ticks = 0;
					string text = left.ToString() + " * " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeConstant(new TimeSpan(ticks));
			}
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return this.MakeConstant(TimeSpan.Zero);
			else if (rightValue == 1)
				return left;
			else if (rightValue == -1)
				return new TimeUnaryMinusOperator(left);
		}
		return new IntTimeMulOperator(left, right);
	}

	private Expression MakeRealTimeMulOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan timeSpan = (TimeSpan)left.Evaluate();
			
			if (timeSpan == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
			else if (right.IsConstant)
			{
				Single factor = Convert.ToSingle(right.Evaluate());
				long ticks = (long)(timeSpan.Ticks * factor);
				if (ticks < TimeSpan.MinValue.Ticks || ticks > TimeSpan.MaxValue.Ticks)
				{
					ticks = 0;
					string text = left.ToString() + " * " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeConstant(new TimeSpan(ticks));
			}
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return this.MakeConstant(TimeSpan.Zero);
			else if (rightValue == 1.0f)
				return left;
			else if (rightValue == -1.0f)
				return new TimeUnaryMinusOperator(left);
		}
		return new RealTimeMulOperator(left, right);
	}

	private Expression MakeLRealTimeMulOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan timeSpan = (TimeSpan)left.Evaluate();
			
			if (timeSpan == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
			else if (right.IsConstant)
			{
				double factor = Convert.ToDouble(right.Evaluate());
				long ticks = (long)(timeSpan.Ticks * factor);
				if (ticks < TimeSpan.MinValue.Ticks || ticks > TimeSpan.MaxValue.Ticks)
				{
					ticks = 0;
					string text = left.ToString() + " * " + right.ToString();
					this.report.SemanticError(117, text, location);
				}
				return this.MakeConstant(new TimeSpan(ticks));
			}
		}
		else if (right.IsConstant)
		{
			double factor = Convert.ToDouble(right.Evaluate());
			if (factor == 0.0d)
				return this.MakeConstant(TimeSpan.Zero);
			else if (factor == 1.0d)
				return left;
			else if (factor == -1.0d)
				return new TimeUnaryMinusOperator(left);
		}
		return new LRealTimeMulOperator(left, right);
	}

	private Expression MakeIntDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				if (rightValue == 0)
				{
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
				else {
					long quotient = leftValue / rightValue;
					return MakeIntConstant(quotient);
				}
			}
			else if (leftValue == 0)
				return MakeIntConstant((long)0);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1)
				return left;
			else if (rightValue == -1)
				return new IntUnaryMinusOperator(left);
			else {
				int power;
				if (this.IsPowerOf2((ulong)Math.Abs(rightValue), out power))
				{
					Expression expr = new LeftShiftOperator(left, power);
					if (rightValue < 0)
						expr = new IntUnaryMinusOperator(expr);
					return expr;
				}
			}
		}
		if (left.DataType == right.DataType)
			return new IntDivOperator(left, right, left.DataType);
		else if (left.DataType == TypeNode.LInt)
			return new IntDivOperator(left, this.MakeInt2LInt(right), TypeNode.LInt);
		else if (right.DataType == TypeNode.LInt)
			return new IntDivOperator(this.MakeInt2LInt(left), right, TypeNode.LInt);
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			return new IntDivOperator(left, right, resultDataType);
		}
	}

	private Expression MakeTimeIntDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				if (rightValue == 0)
				{
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
				else {
					long ticks = leftValue.Ticks/rightValue;
					return this.MakeConstant(new TimeSpan(ticks));
				}
			}
			else if (leftValue == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1)
				return left;
			else if (rightValue == -1)
				return new TimeUnaryMinusOperator(left);
		}
		return new TimeIntDivOperator(left, right);		
	}

	private Expression MakeTimeRealDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				if (rightValue == 0.0f)
				{
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
				else {
					double ticks = leftValue.Ticks/(double)rightValue;
					return this.MakeConstant(new TimeSpan((long)ticks));
				}
			}
			else if (leftValue == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1.0f)
				return left;
			else if (rightValue == -1.0f)
				return new TimeUnaryMinusOperator(left);
		}
		return new TimeLRealDivOperator(left, right);		
	}

	private Expression MakeTimeLRealDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				if (rightValue == 0.0d)
				{
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
				else {
					double ticks = leftValue.Ticks/rightValue;
					return this.MakeConstant(new TimeSpan((long)ticks));
				}
			}
			else if (leftValue == TimeSpan.Zero)
				return this.MakeConstant(TimeSpan.Zero);
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1.0f)
				return left;
			else if (rightValue == -1.0f)
				return new TimeUnaryMinusOperator(left);
		}
		return new TimeRealDivOperator(left, right);		
	}

	private Expression MakeRealDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			float leftValue = Convert.ToSingle(left.Evaluate());
			
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				float quotient = leftValue / rightValue;
				if (! float.IsInfinity(quotient))
					return MakeConstant(quotient);
				else {
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
			}
			if (leftValue == 0.0f)
				return MakeConstant(0.0f);
		}
		else if (right.IsConstant)
		{
			float rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1.0f)
				return left;
			else if (rightValue == -1.0f)
				return new RealUnaryMinusOperator(left);
		}
		return new RealDivOperator(left, right);		
	}

	private Expression MakeLRealDivOp(Expression left, Expression right, LexLocation location)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				double quotient   = leftValue / rightValue;
				if (! double.IsInfinity(quotient))
					return MakeConstant(quotient);
				else {
					this.report.SemanticError(42, location);
					return Expression.Error;
				}
			}
			else if (leftValue == 0.0d)
				return MakeConstant(0.0d);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (rightValue == 1.0d)
				return left;
			else if (rightValue == -1.0d)
				return new LRealUnaryMinusOperator(left);
		}
		return new LRealDivOperator(left, right);		
	}

	private Expression MakeIntUnaryMinusOp(Expression expression)
	{
		if (expression.IsConstant)
		{
			long value = Convert.ToInt64(expression.Evaluate());
			return MakeIntConstant(-value);
		}
		else if (expression is IntUnaryMinusOperator)
			return ((UnaryOperator)expression).Operand;
		else
			return new IntUnaryMinusOperator(expression);
	}

	private Expression MakeIntPowerOp(Expression left, Expression right)
	{
		if (right.IsConstant)
		{
			int exponent = Convert.ToInt32(right.Evaluate());
			if (exponent < 0)
				return MakeConstant(0);
			else if (exponent == 0)
				return MakeConstant(1);
			else if (exponent == 1)
				return left;
			else if (left.IsConstant)
			{
				if (left.DataType.IsSignedIntType)
				{
					long base_ = Convert.ToInt64(left.Evaluate());
					long result = this.IntPower(base_, exponent);
					return MakeIntConstant(result); 
				}
				else {
					ulong base_ = Convert.ToUInt64(left.Evaluate());
					ulong result = this.IntPower(base_, exponent);
					return this.MakeIntConstant(result); 
				}
			}
		}
		return new IntPowerOperator(left, right, left.DataType);
	}

	private Expression MakeRealPowerOp(Expression left, Expression right)
	{
		if (! right.IsConstant)
		{
			if (right.DataType.IsIntegerType)
				return new RealPowerOperator(left, new Int2RealOperator(right));
			else if (right.DataType == TypeNode.Real)
				return new RealPowerOperator(left, right);
			else {
				string msg;
				msg = "MakeRealPowerOp(): Real type exponent expected.";
				throw new STLangCompilerError(msg);
			}
		}
		else if (right.DataType.IsIntegerType)
		{
			int exponent = Convert.ToInt32(right.Evaluate());
			
			if (exponent == 0)
				return MakeConstant(1.0f);
			else if (exponent == 1)
				return left;
			else if (left.IsConstant)
			{
				double base_ = Convert.ToDouble(left.Evaluate());
				float result = (float)Math.Pow(base_, exponent);
				return MakeConstant(result);
			}
			else if (Math.Abs(exponent) > 4)
				right = MakeConstant((float)exponent);
		}
		else if (right.DataType == TypeNode.Real)
		{
			float exponent = Convert.ToSingle(right.Evaluate());
			if (exponent == 0.0f)
				return MakeConstant(1.0f);
			else if (exponent == 1.0f)
				return left;
			else if (left.IsConstant)
			{
				double base_ = Convert.ToDouble(left.Evaluate());
				float result = (float)Math.Pow(base_, exponent);
				return MakeConstant(result);
			}
		}
		return new RealPowerOperator(left, right);
	}

	private Expression MakeLRealPowerOp(Expression left, Expression right)
	{
		if (! right.IsConstant)
		{
			if (right.DataType.IsIntegerType)
				return new LRealPowerOperator(left, new Int2LRealOperator(right));
			else if (right.DataType == TypeNode.LReal)
				return new LRealPowerOperator(left, right);
			else {
				string msg;
				msg = "MakeRealPowerOp(): LReal type exponent expected.";
				throw new STLangCompilerError(msg);
			}
		}
		else if (right.DataType.IsIntegerType)
		{
			int exponent = Convert.ToInt32(right.Evaluate());
			
			if (exponent == 0)
				return MakeConstant(1.0d);
			else if (exponent == 1)
				return left;
			else if (left.IsConstant)
			{
				double base_ = Convert.ToDouble(left.Evaluate());
				double result = Math.Pow(base_, exponent);
				return MakeConstant(result);
			}
			else if (Math.Abs(exponent) > 4)
				right = MakeConstant((double)exponent);
		}
		else if (right.DataType == TypeNode.LReal)
		{
			double exponent = Convert.ToDouble(right.Evaluate());
			if (exponent == 0.0d)
				return MakeConstant(1.0d);
			else if (exponent == 1.0d)
				return left;
			else if (left.IsConstant)
			{
				double base_ = Convert.ToDouble(left.Evaluate());
				double result = Math.Pow(base_, exponent);
				return MakeConstant(result);
			}
		}
		return new LRealPowerOperator(left, right);
	}

	private Expression MakeIntModOp(Expression left, Expression right, LexLocation location)
	{
		if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
			{
				this.report.SemanticError(42, location);
				return Expression.Error;
			}
			else if (left.IsConstant)
			{
				ulong leftValue = Convert.ToUInt64(left.Evaluate());
				ulong result = leftValue % rightValue;
				if (left.DataType.IsUnsignedIntType || right.DataType.IsUnsignedIntType)
					return this.MakeIntConstant(result);
				else
					return MakeIntConstant((long)result);
			}
			else {
				int power;

				if (this.IsPowerOf2(rightValue, out power))
				{
					long bitMask = 1;
					bitMask <<= power;
					bitMask -= 1;
					right = MakeIntConstant(bitMask);
					return new BitAndOperator(left, right, right.DataType);
				}
			}
		}
		return new ModOperator(left, right);
	}

	private Expression MakeAddOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;

			if (leftDataType == TypeNode.Error || rightDataType == TypeNode.Error)
				return Expression.Error;
			else if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntAddOp(left, right);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeIntUIntAddop(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealAddOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealAddOp(this.MakeInt2LReal(left), right, location);
			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntUIntAddop(right, left, location);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntAddop(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealAddOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealAddOp(this.MakeInt2LReal(left), right, location);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealAddOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealAddOp(this.MakeReal2LReal(left), right, location);
				else if (rightDataType.IsIntegerType)
					return this.MakeRealAddOp(left, this.MakeInt2Real(right), location);
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealAddOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealAddOp(left, this.MakeReal2LReal(right), location);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealAddOp(left, this.MakeInt2LReal(right), location);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTTAddOp(left, right, location);
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTTODAddOp(left, right, location);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.Time)
				return this.MakeTTODAddOp(right, left, location);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.Time)
				return this.MakeDTTimeAddOp(left, right, location);
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.DateAndTime)
				return this.MakeDTTimeAddOp(right, left, location);
			//
			// Error. Incompatible operand types of operator +
			//
			this.report.SemanticError(14, "+", leftDataType.Name, rightDataType.Name, location);
			return Expression.Error;
		}
	}

	private Expression MakeSubOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;

			if (leftDataType == TypeNode.Error || rightDataType == TypeNode.Error)
				return Expression.Error;
			else if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntSubOp(left, right);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeIntUIntSubOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealSubOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealSubOp(this.MakeInt2LReal(left), right, location);
			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntUIntSubOp(right, left, location);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntSubOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealSubOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealSubOp(this.MakeInt2LReal(left), right, location);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealSubOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealSubOp(this.MakeReal2LReal(left), right, location);
				else if (rightDataType.IsIntegerType)
					return this.MakeRealSubOp(left, this.MakeInt2Real(right), location);
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealSubOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealSubOp(left, this.MakeReal2LReal(right), location);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealSubOp(left, this.MakeInt2LReal(right), location);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeSubOp(left, right, location);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDaySubOp(left, right, location);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.Time)
				return this.MakeTimeOfDayTimeSubOp(right, left, location);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.Time)
				return this.MakeDateTimeTimeSubOp(left, right, location);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeSubOp(right, left, location);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateSubOp(right, left, location);
			//
			// Error. Incompatible operand types of operator -
			//
			this.report.SemanticError(14, "-", leftDataType.Name, rightDataType.Name, location);
			return Expression.Error;
		}
	}

	private Expression MakeMulOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;

			if (leftDataType == TypeNode.Error || rightDataType == TypeNode.Error)
				return Expression.Error;
			else if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntMulOp(left, right);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeIntUIntMulop(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealMulOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealMulOp(this.MakeInt2LReal(left), right, location);
				else if (rightDataType == TypeNode.Time)
					return this.MakeIntTimeMulOp(right, left, location);
			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntUIntMulop(right, left, location);
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntMulop(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealMulOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealMulOp(this.MakeInt2LReal(left), right, location);
				else if (rightDataType == TypeNode.Time)
					return this.MakeIntTimeMulOp(right, left, location);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealMulOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealMulOp(this.MakeReal2LReal(left), right, location);
				else if (rightDataType.IsIntegerType)
					return this.MakeRealMulOp(left, this.MakeInt2Real(right), location);
				else if (rightDataType == TypeNode.Time)
					return this.MakeRealTimeMulOp(right, left, location);
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealMulOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealMulOp(left, this.MakeReal2LReal(right), location);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealMulOp(left, this.MakeInt2LReal(right), location);
				else if (rightDataType == TypeNode.Time)
					return this.MakeLRealTimeMulOp(right, left, location);
			}
			else if (leftDataType == TypeNode.Time)
			{
				if (rightDataType.IsIntegerType)
					return this.MakeIntTimeMulOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealTimeMulOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealTimeMulOp(right, left, location);
			}
			//
			// Error. Incompatible operand types of operator *
			//
			this.report.SemanticError(14, "*", leftDataType.Name, rightDataType.Name, location);
			return Expression.Error;
		}
	}

	private Expression MakeDivOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;

			if (leftDataType == TypeNode.Error || rightDataType == TypeNode.Error)
				return Expression.Error;
			else if (leftDataType.IsIntegerType)
			{
				if (rightDataType.IsIntegerType)
					return this.MakeIntDivOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealDivOp(this.MakeInt2Real(left), right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealDivOp(this.MakeInt2LReal(left), right, location);
			}         
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealDivOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealDivOp(this.MakeReal2LReal(left), right, location);
				else if (rightDataType.IsIntegerType)
					return this.MakeRealDivOp(left, this.MakeInt2Real(right), location);
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealDivOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealDivOp(left, this.MakeReal2LReal(right), location);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealDivOp(left, this.MakeInt2LReal(right), location);
			}
			else if (leftDataType == TypeNode.Time)
			{
				if (rightDataType.IsIntegerType)
					return this.MakeTimeIntDivOp(left, right, location);
				else if (rightDataType == TypeNode.Real)
					return this.MakeTimeRealDivOp(left, right, location);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeTimeLRealDivOp(right, left, location);
			}
			//
			// Error. Incompatible operand types of operator /
			//
			this.report.SemanticError(14, "/", leftDataType.Name, rightDataType.Name, location);
			return Expression.Error;
		}
	}

	private Expression MakeRealUnaryMinusOp(Expression expression)
	{
		if (! expression.IsConstant)
			return new RealUnaryMinusOperator(expression);
		else {
			float realValue = -(float)expression.Evaluate();
			return MakeConstant(realValue);
		}
	}

	private Expression MakeLRealUnaryMinusOp(Expression expression)
	{
		if (! expression.IsConstant)
			return new LRealUnaryMinusOperator(expression);
		else {
			double doubleValue = -(double)expression.Evaluate();
			return MakeConstant(doubleValue);
		}
	}

	private Expression MakeTimeUnaryMinusOp(Expression expression)
	{
		if (! expression.IsConstant)
			return new LRealUnaryMinusOperator(expression);
		else {
			double doubleValue = -(double)expression.Evaluate();
			return MakeConstant(doubleValue);
		}
	}

	private Expression MakeUnaryMinusOperator(Expression expression, LexLocation location)
	{
		if (expression == null)
			return Expression.Error;
		else {
			TypeNode dataType = expression.DataType;
			if (dataType == TypeNode.Error)
				return expression;
			else if (dataType.IsSignedIntType)
				return this.MakeIntUnaryMinusOp(expression);
			else if (dataType.IsUnsignedIntType)
			{
				// unary minus applied to unsigned int type has no effect
				this.report.Warning(8, dataType.Name, location);
				return expression;
			}
			else if (dataType == TypeNode.Real)
				return this.MakeRealUnaryMinusOp(expression);
			else if (dataType == TypeNode.LReal)
				return this.MakeLRealUnaryMinusOp(expression);
			else if (dataType == TypeNode.Time)
				return this.MakeTimeUnaryMinusOp(expression);
			else {
				this.report.SemanticError(-14, "-", dataType.Name, location);
				return Expression.Error;
			}
		}
	}

	private Expression MakeUnaryPlusOperator(Expression expression, LexLocation location)
	{
		if (expression == null)
			return Expression.Error;
		else {
			TypeNode dataType = expression.DataType;
			if (dataType == TypeNode.Error)
				return expression;
			else if (dataType.IsNumericalType)
				return expression;
			else if (dataType == TypeNode.Time)
				return expression;
			else {
				this.report.SemanticError(-14, "+", dataType.Name, location);
				return Expression.Error;
			}
		}
	}

	private bool IsBitWiseType(Expression expression)
	{
		TypeNode dataType = expression.DataType;
		return dataType.IsBitStringType || (dataType.IsIntegerType && expression.IsConstant);
	}

	private Expression MakeAndOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else if (! this.IsBitWiseType(left) || ! this.IsBitWiseType(right))
		{
			string dataTypeName1 = left.DataType.Name;
			string dataTypeName2 = right.DataType.Name;
			this.report.SemanticError(14, "AND", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			if (left.IsConstant)
			{
				ulong leftValue = Convert.ToUInt64(left.Evaluate());
				if (leftValue == 0)
					return this.MakeConstant(leftValue, resultDataType);
				else if (this.BitCount(leftValue) == resultDataType.BitCount)
					return right;
				else if (right.IsConstant)
				{
					ulong rightValue = Convert.ToUInt64(right.Evaluate());
					ulong result = leftValue & rightValue;
					return this.MakeConstant(result, resultDataType);
				}
			}
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				if (rightValue == 0)
					return this.MakeConstant(rightValue, resultDataType);
				else if (this.BitCount(rightValue) == resultDataType.BitCount)
					return left;
			}
			if (resultDataType != TypeNode.Bool)
				return new BitAndOperator(left, right, resultDataType);
			else if (left is AndOperator)
			{
				((AndOperator)left).Add(right);
				return left;
			}
			else if (right is AndOperator)
			{
				((AndOperator)right).AddLeft(left);
				return right;
			}
			return new AndOperator(left, right);
		}
	}

	private Expression MakeIOrOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else if (! this.IsBitWiseType(left) || ! this.IsBitWiseType(right))
		{
			string dataTypeName1 = left.DataType.Name;
			string dataTypeName2 = right.DataType.Name;
			this.report.SemanticError(14, "OR", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			if (left.IsConstant)
			{
				ulong leftValue = Convert.ToUInt64(left.Evaluate());
				if (leftValue == 0)
					return right;
				else if (this.BitCount(leftValue) == resultDataType.BitCount)
					return left;
				else if (right.IsConstant)
				{
					ulong rightValue = Convert.ToUInt64(right.Evaluate());
					ulong result = leftValue | rightValue;
					return this.MakeConstant(result, resultDataType);
				}
			}
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				if (rightValue == 0)
					return left;
				else if (this.BitCount(rightValue) == resultDataType.BitCount)
					return right;
			}
			if (resultDataType != TypeNode.Bool)
				return new BitIOrOperator(left, right, resultDataType);
			else if (left is IOrOperator)
			{
				((IOrOperator)left).Add(right);
				return left;
			}
			else if (right is IOrOperator)
			{
				((IOrOperator)right).AddLeft(left);
				return right;
			}
			return new IOrOperator(left, right);
		}
	}

	private Expression MakeXOrOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else if (! this.IsBitWiseType(left) || ! this.IsBitWiseType(right))
		{
			string DataTypeName1 = left.DataType.Name;
			string DataTypeName2 = right.DataType.Name;
			this.report.SemanticError(14, "XOR", DataTypeName1, DataTypeName2, location);
			return Expression.Error;
		}
		else {
			TypeNode resultDataType = this.LargestDataType(left, right);
			if (left.IsConstant)
			{
				ulong leftValue = Convert.ToUInt64(left.Evaluate());
				if (leftValue == 0)
					return right;
				else if (right.IsConstant)
				{
					ulong rightValue = Convert.ToUInt64(right.Evaluate());
					ulong result = leftValue ^ rightValue;
					return this.MakeConstant(result, resultDataType);
				}
			}
			else if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				if (rightValue == 0)
					return left;
			}
			if (resultDataType != TypeNode.Bool)
				return new BitXOrOperator(left, right, resultDataType);
			else {
				Expression leftTree = left.DeMorgan();
				Expression rightTree = right.DeMorgan();
				if (leftTree is AndOperator)
					((AndOperator)leftTree).Add(right);
				else
					leftTree = new AndOperator(leftTree, right);
				if (rightTree is AndOperator)
					((AndOperator)rightTree).Add(left);
				else
					rightTree = new AndOperator(left, rightTree);
				return new IOrOperator(leftTree, rightTree);
			}	
		}
	}

	private Expression MakeNotOperator(Expression expression, LexLocation location)
	{
		if (expression == null)
			return Expression.Error;
		else if (expression is FunctionName)
		{
			this.report.SemanticError(148, expression.ToString(), location);
			return Expression.Error;
		}
		else if (expression.DataType == TypeNode.Error)
			return Expression.Error;
		else if (! this.IsBitWiseType(expression))
		{
			string dataTypeName = expression.DataType.Name;
			this.report.SemanticError(-14, "NOT", dataTypeName, location);
			return Expression.Error;
		}
		else if (expression.IsConstant)
		{
			ulong value = Convert.ToUInt64(expression.Evaluate());
			return this.MakeConstant(~value, expression.DataType);
		}
		if (expression.DataType == TypeNode.Bool)
			return expression.DeMorgan();
		else
			return new BitNotOperator(expression);
	}

	private Expression MakePowOperator(Expression base_, Expression exponent, LexLocation location)
	{
		if (base_ == null || exponent == null)
			return Expression.Error;
        else if (base_ is FunctionName)
		{
			this.report.SemanticError(148, base_.ToString(), location);
			return Expression.Error;
		}
		else if (exponent is FunctionName)
		{
			this.report.SemanticError(148, exponent.ToString(), location);
			return Expression.Error;
		}
		else if (base_.DataType == TypeNode.Error || exponent.DataType == TypeNode.Error)
			return Expression.Error;
		else if (base_.DataType == TypeNode.LReal)
		{
			if (exponent.DataType == TypeNode.LReal)
				return this.MakeLRealPowerOp(base_, exponent);
			else if (exponent.DataType == TypeNode.Real)
				return this.MakeLRealPowerOp(base_, this.MakeReal2LReal(exponent));
			else if (exponent.DataType.IsIntegerType)
				return this.MakeLRealPowerOp(base_, exponent);
		}
		else if (base_.DataType == TypeNode.Real)
		{
			if (exponent.DataType == TypeNode.Real)
				return this.MakeRealPowerOp(base_, exponent);
			else if (exponent.DataType == TypeNode.LReal)
				return this.MakeRealPowerOp(this.MakeReal2LReal(base_), exponent);
			else if (exponent.DataType.IsIntegerType)
				return this.MakeRealPowerOp(base_, exponent);
		}
		else if (base_.DataType.IsIntegerType)
		{
			if (exponent.DataType.IsIntegerType)
				return this.MakeIntPowerOp(base_, exponent);
			else if (exponent.DataType == TypeNode.LReal)
				return this.MakeLRealPowerOp(this.MakeInt2LReal(base_), exponent);
			else if (exponent.DataType == TypeNode.Real)
				return this.MakeRealPowerOp(this.MakeInt2Real(base_), exponent);
		}
		//
		// Error. Incompatible operand types of operator **
		//
		string dataTypeName1 = base_.DataType.Name;
		string dataTypeName2 = exponent.DataType.Name;
		this.report.SemanticError(14, " ** ", dataTypeName1, dataTypeName2, location);
		return Expression.Error;
	}

	private Expression MakeModOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else if (left.DataType.IsIntegerType && right.DataType.IsIntegerType)
			return this.MakeIntModOp(left, right, location);
		else {
			//
			// Error. Incompatible operand types of operator MOD
			//
			string dataTypeName1 = left.DataType.Name;
			string dataTypeName2 = right.DataType.Name;
			this.report.SemanticError(14, " MOD ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeIntGtrOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue > rightValue);
			}
			else if (leftValue == 0)
				return new IntLesOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntGtrOperator(left, right, true);
		}
		return new IntGtrOperator(left, right);
	}

	private Expression MakeUIntGtrOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				return this.MakeConstant(leftValue > rightValue);
			}
			else if (leftValue == 0)
				return new IntLesOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntGtrOperator(left, right, true);
		}
		return new IntGtrOperator(left, right);
	}

	private Expression MakeRealGtrOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				Single rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue > rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatLesOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatGtrOperator(left, right, true);
		}
		return new FloatGtrOperator(left, right);
	}

	private Expression MakeLRealGtrOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue > rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealLesOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealGtrOperator(left, right, true);
		}
		return new LRealGtrOperator(left, right);
	}

	private Expression MakeTimeGtrOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeGtrOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeDateTimeGtrOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeGtrOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeStringGtrOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringGtrOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) > 0);
		}
	}

	private Expression MakeWStringGtrOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringGtrOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) > 0);
		}
	}

	private Expression MakeTimeOfDayGtrOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new TimeOfDayGtrOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeIntLesOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue < rightValue);
			}
			else if (leftValue == 0)
				return new IntGtrOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntLesOperator(left, right, true);
		}
		return new IntLesOperator(left, right);
	}

	private Expression MakeUIntLesOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				return this.MakeConstant(leftValue < rightValue);
			}
			else if (leftValue == 0)
				return new IntGtrOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntLesOperator(left, right, true);
		}
		return new IntLesOperator(left, right);
	}

	private Expression MakeRealLesOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				Single rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue < rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatGtrOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatLesOperator(left, right, true);
		}
		return new FloatLesOperator(left, right);
	}

	private Expression MakeLRealLesOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue < rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealGtrOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealLesOperator(left, right, true);
		}
		return new LRealLesOperator(left, right);
	}

	private Expression MakeTimeLesOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeLesOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeDateTimeLesOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeLesOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeStringLesOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringLesOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) > 0);
		}
	}

	private Expression MakeWStringLesOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringLesOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) > 0);
		}
	}

	private Expression MakeTimeOfDayLesOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new TimeOfDayLesOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue > rightValue);
		}
	}

	private Expression MakeUIntEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new IntEqlOperator(left, right);
		else {
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeIntEqlOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue == rightValue);
			}
			else if (leftValue == 0)
				return new IntEqlOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntEqlOperator(left, right, true);
		}
		return new IntEqlOperator(left, right);
	}

	private Expression MakeRealEqlOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue == rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatEqlOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatEqlOperator(left, right, true);
		}
		return new FloatEqlOperator(left, right);
	}

	private Expression MakeLRealEqlOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue == rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealEqlOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealEqlOperator(left, right, true);
		}
		return new LRealEqlOperator(left, right);
	}

	private Expression MakeTimeEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeEqlOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeDateTimeEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeEqlOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeStringEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringEqlOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeWStringEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringEqlOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeTimeOfDayEqlOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeOfDayEqlOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue == rightValue);
		}
	}

	private Expression MakeIntNeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue != rightValue);
			}
			else if (leftValue == 0)
				return new IntNeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntNeqOperator(left, right, true);
		}
		return new IntNeqOperator(left, right);
	}

	private Expression MakeUIntNeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				return this.MakeConstant(leftValue != rightValue);
			}
			else if (leftValue == 0)
				return new IntNeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntNeqOperator(left, right, true);
		}
		return new IntNeqOperator(left, right);
	}

	private Expression MakeRealNeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue != rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatNeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatNeqOperator(left, right, true);
		}
		return new FloatNeqOperator(left, right);
	}

	private Expression MakeLRealNeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue != rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealNeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealNeqOperator(left, right, true);
		}
		return new LRealNeqOperator(left, right);
	}

	private Expression MakeTimeNeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeNeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue != rightValue);
		}
	}

	private Expression MakeDateTimeNeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeNeqOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue != rightValue);
		}
	}

	private Expression MakeStringNeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringNeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) != 0);
		}
	}

	private Expression MakeWStringNeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringNeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) != 0);
		}
	}

	private Expression MakeTimeOfDayNeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new TimeOfDayGeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue != rightValue);
		}
	}

	private Expression MakeIntGeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue >= rightValue);
			}
			else if (leftValue == 0)
				return new IntGeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntGeqOperator(left, right, true);
		}
		return new IntGeqOperator(left, right);
	}

	private Expression MakeUIntGeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				return this.MakeConstant(leftValue >= rightValue);
			}
			else if (leftValue == 0)
				return new IntLeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntGeqOperator(left, right, true);
		}
		return new IntGeqOperator(left, right);
	}

	private Expression MakeRealGeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue >= rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatLeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatGeqOperator(left, right, true);
		}
		return new FloatGeqOperator(left, right);
	}

	private Expression MakeLRealGeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue >= rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealLeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealGeqOperator(left, right, true);
		}
		return new LRealGeqOperator(left, right);
	}

	private Expression MakeTimeGeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeGeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue >= rightValue);
		}
	}

	private Expression MakeDateTimeGeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeGeqOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue >= rightValue);
		}
	}

	private Expression MakeStringGeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringGeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) >= 0);
		}
	}
	
	private Expression MakeWStringGeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringGeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) >= 0);
		}
	}


	private Expression MakeTimeOfDayGeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new TimeOfDayGeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue >= rightValue);
		}
	}

	private Expression MakeIntLeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			long leftValue = Convert.ToInt64(left.Evaluate());
			if (right.IsConstant)
			{
				long rightValue = Convert.ToInt64(right.Evaluate());
				return this.MakeConstant(leftValue <= rightValue);
			}
			else if (leftValue == 0)
				return new IntGeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			long rightValue = Convert.ToInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntLeqOperator(left, right, true);
		}
		return new IntLeqOperator(left, right);
	}

	private Expression MakeUIntLeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			ulong leftValue = Convert.ToUInt64(left.Evaluate());
			if (right.IsConstant)
			{
				ulong rightValue = Convert.ToUInt64(right.Evaluate());
				return this.MakeConstant(leftValue <= rightValue);
			}
			else if (leftValue == 0)
				return new IntGeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			ulong rightValue = Convert.ToUInt64(right.Evaluate());
			if (rightValue == 0)
				return new IntLeqOperator(left, right, true);
		}
		return new IntLeqOperator(left, right);
	}

	private Expression MakeRealLeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			Single leftValue = Convert.ToSingle(left.Evaluate());
			if (right.IsConstant)
			{
				float rightValue = Convert.ToSingle(right.Evaluate());
				return this.MakeConstant(leftValue <= rightValue);
			}
			else if (leftValue == 0.0f)
				return new FloatGeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			Single rightValue = Convert.ToSingle(right.Evaluate());
			if (rightValue == 0.0f)
				return new FloatLeqOperator(left, right, true);
		}
		return new FloatLeqOperator(left, right);
	}

	private Expression MakeLRealLeqOp(Expression left, Expression right)
	{
		if (left.IsConstant)
		{
			double leftValue = Convert.ToDouble(left.Evaluate());
			if (right.IsConstant)
			{
				double rightValue = Convert.ToDouble(right.Evaluate());
				return this.MakeConstant(leftValue <= rightValue);
			}
			else if (leftValue == 0.0d)
				return new LRealGeqOperator(right, left, true);
		}
		else if (right.IsConstant)
		{
			double rightValue = Convert.ToDouble(right.Evaluate());
			if (rightValue == 0.0d)
				return new LRealLeqOperator(left, right, true);
		}
		return new LRealLeqOperator(left, right);
	}

	private Expression MakeTimeLeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new TimeLeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue <= rightValue);
		}
	}

	private Expression MakeDateTimeLeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new DateTimeLeqOperator(left, right);
		else {
			DateTime leftValue = (DateTime)left.Evaluate();
			DateTime rightValue = (DateTime)right.Evaluate();
			return this.MakeConstant(leftValue <= rightValue);
		}
	}

	private Expression MakeStringLeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new StringLeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) <= 0);
		}
	}

	private Expression MakeWStringLeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant) 
			return new WStringLeqOperator(left, right);
		else {
			string leftValue = (string)left.Evaluate();
			string rightValue = (string)right.Evaluate();
			return this.MakeConstant(leftValue.CompareTo(rightValue) <= 0);
		}
	}

	private Expression MakeTimeOfDayLeqOp(Expression left, Expression right)
	{
		if (! left.IsConstant || ! right.IsConstant)
			return new TimeOfDayLeqOperator(left, right);
		else {
			TimeSpan leftValue = (TimeSpan)left.Evaluate();
			TimeSpan rightValue = (TimeSpan)right.Evaluate();
			return this.MakeConstant(leftValue <= rightValue);
		}
	}

	private Expression MakeGtrOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, ">", location);
					return this.MakeIntGtrOp(left, right);
				}
				else if (rightDataType.IsSignedIntType)
					return this.MakeIntGtrOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealGtrOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGtrOp(this.MakeInt2LReal(left), right);

			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, ">", location);
					return this.MakeUIntGtrOp(left, right);
				}
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntGtrOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealGtrOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGtrOp(this.MakeInt2LReal(left), right);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealGtrOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGtrOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealGtrOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGtrOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealGtrOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealGtrOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntGtrOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntGtrOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeGtrOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayGtrOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeGtrOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeGtrOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringGtrOp(left, right);
			else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringGtrOp(left, right);
			//
			// Error. Incompatible operand types of operator >
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " > ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeLesOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, "<", location);
					return this.MakeIntLesOp(left, right);
				}
				else if (rightDataType.IsSignedIntType)
					return this.MakeIntLesOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealLesOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLesOp(this.MakeInt2LReal(left), right);

			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, "<", location);
					return this.MakeUIntLesOp(left, right);
				}
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntLesOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealLesOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLesOp(this.MakeInt2LReal(left), right);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealLesOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLesOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealLesOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLesOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealLesOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealLesOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntLesOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntLesOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeLesOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayLesOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeLesOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeLesOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringLesOp(left, right);
			else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringLesOp(left, right);
			//
			// Error. Incompatible operand types of operator <
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " < ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeEqlOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsSignedIntType)
					return this.MakeIntEqlOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealEqlOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealEqlOp(this.MakeInt2LReal(left), right);
				else if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, "=", location);
					return this.MakeIntEqlOp(left, right);
				}
			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
					return this.MakeIntEqlOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealEqlOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealEqlOp(this.MakeInt2LReal(left), right);
				else if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, "=", location);
					return this.MakeIntEqlOp(left, right);
				}
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealEqlOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealEqlOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealEqlOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealEqlOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealEqlOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealEqlOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntEqlOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntEqlOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeEqlOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayEqlOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeEqlOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeEqlOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringEqlOp(left, right);
			else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringEqlOp(left, right);
			//
			// Error. Incompatible operand types of operator =
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " = ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeNeqOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, "<>", location);
					return this.MakeIntNeqOp(left, right);
				}
				else if (rightDataType.IsSignedIntType)
					return this.MakeIntNeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealNeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealNeqOp(this.MakeInt2LReal(left), right);

			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, "<>", location);
					return this.MakeUIntNeqOp(left, right);
				}
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntNeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealNeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealNeqOp(this.MakeInt2LReal(left), right);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealNeqOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealNeqOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealNeqOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealNeqOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealNeqOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealNeqOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntNeqOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntNeqOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeNeqOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayNeqOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeNeqOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeNeqOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringNeqOp(left, right);
		    else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringNeqOp(left, right);
			//
			// Error. Incompatible operand types of operator <>
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " <> ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeGeqOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, ">=", location);
					return this.MakeIntGeqOp(left, right);
				}
				else if (rightDataType.IsSignedIntType)
					return this.MakeIntGeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealGeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGeqOp(this.MakeInt2LReal(left), right);

			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, "<>", location);
					return this.MakeUIntGeqOp(left, right);
				}
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntGeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealGeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGeqOp(this.MakeInt2LReal(left), right);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealGeqOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGeqOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealGeqOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealGeqOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealGeqOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealGeqOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntGeqOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntGeqOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeGeqOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayGeqOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeGeqOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeGeqOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringGeqOp(left, right);
			else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringGeqOp(left, right);
			//
			// Error. Incompatible operand types of operator >=
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " >= ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private Expression MakeLeqOperator(Expression left, Expression right, LexLocation location)
	{
		if (left == null || right == null)
			return Expression.Error;
		else if (left is FunctionName)
		{
			this.report.SemanticError(148, left.ToString(), location);
			return Expression.Error;
		}
		else if (right is FunctionName)
		{
			this.report.SemanticError(148, right.ToString(), location);
			return Expression.Error;
		}
		else if (left.DataType == TypeNode.Error || right.DataType == TypeNode.Error)
			return Expression.Error;
		else {
			TypeNode leftDataType = left.DataType;
			TypeNode rightDataType = right.DataType;
			if (leftDataType.IsSignedIntType)
			{
				if (rightDataType.IsUnsignedIntType)
				{
					this.report.Warning(9, ">=", location);
					return this.MakeIntLeqOp(left, right);
				}
				else if (rightDataType.IsSignedIntType)
					return this.MakeIntLeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealLeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLeqOp(this.MakeInt2LReal(left), right);

			}
			else if (leftDataType.IsUnsignedIntType)
			{
				if (rightDataType.IsSignedIntType)
				{
					this.report.Warning(9, "<>", location);
					return this.MakeUIntLeqOp(left, right);
				}
				else if (rightDataType.IsUnsignedIntType)
					return this.MakeUIntLeqOp(left, right);
				else if (rightDataType == TypeNode.Real)
					return this.MakeRealLeqOp(this.MakeInt2Real(left), right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLeqOp(this.MakeInt2LReal(left), right);
			}
			else if (leftDataType == TypeNode.Real)
			{
				if (rightDataType == TypeNode.Real)
					return this.MakeRealLeqOp(left, right);
				else if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLeqOp(this.MakeReal2LReal(left), right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealLeqOp(left, this.MakeInt2Real(right));
			}
			else if (leftDataType == TypeNode.LReal)
			{
				if (rightDataType == TypeNode.LReal)
					return this.MakeLRealLeqOp(left, right);
				else if (rightDataType.IsIntegerType)
					return this.MakeLRealLeqOp(left, this.MakeInt2LReal(right));
				else if (rightDataType == TypeNode.Real)
					return this.MakeLRealLeqOp(left, this.MakeReal2LReal(right));
			}
			else if (leftDataType.IsBitStringType)
			{
				if (rightDataType.IsBitStringType)
					return this.MakeUIntLeqOp(left, right);
				else if (rightDataType.IsIntegerType && right.IsConstant)
					return this.MakeUIntLeqOp(left, right);
			}
			else if (leftDataType == TypeNode.Time && rightDataType == TypeNode.Time)
				return this.MakeTimeLeqOp(left, right);
			else if (leftDataType == TypeNode.TimeOfDay && rightDataType == TypeNode.TimeOfDay)
				return this.MakeTimeOfDayLeqOp(left, right);
			else if (leftDataType == TypeNode.Date && rightDataType == TypeNode.Date)
				return this.MakeDateTimeLeqOp(left, right);
			else if (leftDataType == TypeNode.DateAndTime && rightDataType == TypeNode.DateAndTime)
				return this.MakeDateTimeLeqOp(left, right);
			else if (leftDataType.IsStringType && rightDataType.IsStringType)
				return this.MakeStringLeqOp(left, right);
			else if (leftDataType.IsWStringType && rightDataType.IsWStringType)
				return this.MakeWStringLeqOp(left, right);
			//
			// Error. Incompatible operand types of operator <=
			//
			string dataTypeName1 = leftDataType.Name;
			string dataTypeName2 = rightDataType.Name;
			this.report.SemanticError(14, " <= ", dataTypeName1, dataTypeName2, location);
			return Expression.Error;
		}
	}

	private ProgramOrganizationUnitCall MakePOUCall(string name, LexLocation location)
	{
		STLangSymbol symbol;
		if (! this.symbolTable.Lookup(name, out symbol, location))
		{
			STLangSymbol undefinedPOU;
			this.report.SemanticError(0, name, location);
			undefinedPOU = this.symbolTable.InstallUndefinedFunction(name, 10);
			return new STLangFunctionCall(undefinedPOU, location);
		}
		else if (symbol.IsFunction)
			return new STLangFunctionCall(symbol, location);
		else if (symbol.IsFunctionBlockInstance)
			return new STLangFunctionBlockCall(symbol, location);
		else
		{
			this.report.SemanticError(5, symbol.TypeName, name, location);
			return null;
		}
	}

	private ProgramOrganizationUnitCall MakePOUCall(string name, POUParameter argument, LexLocation location)
	{
		STLangSymbol symbol;
		if (! this.symbolTable.Lookup(name, out symbol, location))
		{
			STLangSymbol undefinedPOU;
			this.report.SemanticError(0, name, location);
			undefinedPOU = this.symbolTable.InstallUndefinedFunction(name, 10);
			return new STLangFunctionCall(undefinedPOU, argument, location);
		}
		else if (symbol.IsFunction)
		{
			if (argument.DataType == TypeNode.Bool && ! (symbol is SELFunctionSymbol))
			{
				if (argument.IsInputParameter && argument.RValue.IsCompoundExpression)
				{
					Expression input = new LoadBoolValueOperator(argument.RValue);
					LexLocation loc = argument.LexicalLocation;
					string inputName = argument.FormalName;
					argument = new InputParameter(inputName, input, loc);
				}
			}
			return new STLangFunctionCall(symbol, argument, location);
		}
		else if (symbol.IsFunctionBlockInstance)
		{
			FunctionBlockType dataType = symbol.DataType as FunctionBlockType;
			this.CheckFunctionBlockParameter(name, dataType, argument, location);
			if (argument.DataType == TypeNode.Bool && argument.RValue.IsCompoundExpression)
			{
				if (argument.IsInputParameter)
				{
					Expression input = new LoadBoolValueOperator(argument.RValue);
					LexLocation loc = argument.LexicalLocation;
					string inputName = argument.FormalName;
					argument = new InputParameter(inputName, input, loc);
				}
			}
			return new STLangFunctionBlockCall(symbol, argument, location);
		}
		else
		{
			this.report.SemanticError(5, symbol.TypeName, name, location);
			return null;
		}
	}

	private ProgramOrganizationUnitCall AddPOUParameter(ProgramOrganizationUnitCall pou, POUParameter argument)
	{
		if (pou == null)
			return null;
		else {
			if (pou.IsInputArgAssignment && ! argument.IsInputArgAssignment)
				this.report.SemanticError(185, argument.ToString(), argument.LexicalLocation);
			else if (! pou.IsInputArgAssignment && argument.IsInputArgAssignment)
				this.report.SemanticError(185,  argument.ToString(), argument.LexicalLocation);
			if (argument.DataType == TypeNode.Bool && argument.RValue.IsCompoundExpression)
			{
				if (argument.IsInputParameter)
				{
					Expression input = new LoadBoolValueOperator(argument.RValue);
					LexLocation loc = argument.LexicalLocation;
					string inputName = argument.FormalName;
					argument = new InputParameter(inputName, input, loc);
				}
			}
			if (pou.IsFunction)
			{
				pou.Add(argument);
				return pou;
			}
			else if (pou.IsFunctionBlock)
			{
				this.CheckFunctionBlockParameter(pou, argument);
				pou.Add(argument);
				return pou;
			}
		}
		throw new STLangCompilerError("AddPOUParameter(): Unknown type of POU.");
	}

	private ProgramOrganizationUnitCall MakePOUCall(ProgramOrganizationUnitCall pou, LexLocation location)
	{
		return pou;
	}

	private Expression MakeFunctionCall(ProgramOrganizationUnitCall pou)
	{
		if (pou == null)
			return Expression.Error;
		else if (pou.IsFunctionBlock)
		{
			// Error: Function block used as a function
			//
			this.report.SemanticError(135, pou.Name, pou.Location);
			return Expression.Error;
		}
		else {
			Expression functionCall = pou.MakeSyntaxTreeNode();
			if (! this.symbolTable.IsRecursiveCall(functionCall))
				return functionCall;
			else {
				// Error: Illegal recursive call
				//
				this.report.SemanticError(90, pou.Name, pou.Location);
				return Expression.Error;
			}
		}
	}

	private Statement MakeFunctionBlockCallStatement(ProgramOrganizationUnitCall pou)
	{
		if (pou == null)
			return Statement.Empty;
		else if (pou.IsFunction)
		{
			// Warning: Function call found where function block call was expected.
			//
			this.report.Warning(16, pou.Name, pou.Location);
			return Statement.Empty;
		}
		else
		{
			Expression expression = pou.MakeSyntaxTreeNode();
			return new FunctionBlockCallStatement(expression);
		}
	}

	private POUParameter MakeParameter(Expression argument, LexLocation location)
	{
		if (argument == null)
			return new InputParameter(Expression.Error, location);
		else if (argument is FunctionName)
		{
			this.report.SemanticError(148, argument.ToString(), location);
			return new InputParameter(Expression.Error, location);
		}
		return new InputParameter(argument, location);
	}

	private POUParameter MakeParameter(string formalParam, Tokens assignToken, Expression argument, LexLocation location, bool inverted = false)
	{
		if (argument == null)
			argument = Expression.Error;
		else if (argument is FunctionName)
			this.report.SemanticError(148, argument.ToString(), location);
		if (assignToken == Tokens.OUTPUT_ASSIGN)
			return new OutputParameter(formalParam, argument, inverted, location);
		else if (assignToken == Tokens.ASSIGN)
		{
			if (inverted)
				this.report.SyntaxError(184, formalParam, location);
			return new InputParameter(formalParam, argument, location);
		}
		throw new STLangCompilerError("MakeParameter(): Unkown assignment token.");
	}

	private void CheckFunctionBlockParameter(ProgramOrganizationUnitCall pou, POUParameter argument)
	{
		FunctionBlockType functionBlock;
		functionBlock = pou.Symbol.DataType as FunctionBlockType;
		this.CheckFunctionBlockParameter(pou.Name, functionBlock, argument, pou.Location);
	}

	private void CheckFunctionBlockParameter(string pouName, FunctionBlockType functionBlock, POUParameter argument, LexLocation location)
	{
		InstanceSymbol formal;
		string formalName = argument.FormalName;

		if (formalName.Length == 0)
			this.report.SemanticError(174, pouName, argument.LexicalLocation);
		else if (! functionBlock.LookUp(formalName, out formal))
			this.report.SemanticError(141, formalName, pouName, argument.LexicalLocation);
		else if (argument.RValue != null)
		{
			argument.Position = formal.Position;
			if (argument.IsOutputParameter)
			{
				Expression lValue;

				lValue = formal.MakeSyntaxTreeNode(argument.LexicalLocation);
				argument.LValue = lValue;
			}
			Expression actual = argument.RValue;
			TypeNode actualDataType = actual.DataType;
			LexLocation formalLoc = argument.LexicalLocation;
			switch (formal.VariableType)
			{
				case STVarType.VAR_INPUT:
				break;

				case STVarType.VAR_INOUT:
					//
					// Check that the actual argument is an l-value
					//
					if (! actual.IsLValue && actualDataType != TypeNode.Error)
						this.report.SemanticError(78, pouName, formalName, formalLoc);
					if (! argument.IsInputParameter)
						this.report.SemanticError(175, formalName, formalLoc);
					break;

				case STVarType.VAR_OUTPUT:
					if (! actual.IsLValue && actualDataType != TypeNode.Error)
						this.report.SemanticError(189, pouName, formalName, formalLoc);
					if (! argument.IsOutputParameter)
					{
						if (! actual.IsLValue)
							this.report.SemanticError(176, formalName, formalLoc);
						else
							this.report.SemanticError(173, actual.ToString(), formalName, formalLoc);
					}
					break;

				default:
					this.report.SemanticError(180, formalName, formalLoc);
					break;
			}
			TypeNode formalDataType = formal.DataType;
			float conversionCost = formalDataType.ConversionCost(actual);
			if (conversionCost > 0.0 && actualDataType != TypeNode.Error)
			{
				if (actual.IsConstant)
				{
					if (formalDataType == TypeNode.LReal)
					{
						if (actualDataType == TypeNode.Real || actualDataType.IsIntegerType)
						{
							double doubleValue;
							doubleValue = Convert.ToDouble(actual.Evaluate());
							actual = MakeConstant(doubleValue);
						}
						else {
							string typeName = formalDataType.Name;
							string constValue = actual.ToString();
							this.report.SemanticError(177, formalName, constValue, typeName, location);
							actual = Expression.Error;
						}
					}
					else if (formalDataType == TypeNode.Real)
					{
						if (actualDataType.IsIntegerType)
						{
							float floatValue;
							floatValue = Convert.ToSingle(actual.Evaluate());
							actual = MakeConstant(floatValue);
						}
						else {
							string typeName = formalDataType.Name;
							string constValue = actual.ToString();
							this.report.SemanticError(177, formalName, constValue, typeName, location);
							actual = Expression.Error;
						}
					}
					else if (formalDataType.IsIntegerType)
					{
						if (actualDataType.IsIntegerType)
						{
							if (actualDataType.Size > formalDataType.Size)
							{
								string typeName = formalDataType.Name;
								string constValue = actual.ToString();
								this.report.SemanticError(178, constValue, formalName, typeName, location);
							}
						}
						else {
							string typeName = formalDataType.Name;
							string constValue = actual.ToString();
							this.report.SemanticError(177, formalName, constValue, typeName, location);
							actual = Expression.Error;
						}
					}
					else if (formalDataType.IsBitStringType)
					{
						if (actualDataType.IsBitStringType)
						{
							if (actualDataType.Size > formalDataType.Size)
							{
								string typeName = formalDataType.Name;
								string constValue = actual.ToString();
								this.report.SemanticError(178, constValue, formalName, typeName, location);
							}
						}
						else if (actualDataType.IsIntegerType)
						{
							if (actualDataType.Size > formalDataType.Size)
							{
								string typeName = formalDataType.Name;
								string constValue = actual.ToString();
								this.report.SemanticError(178, constValue, formalName, typeName, location);
							}
							else {
								ulong value = Convert.ToUInt64(actual.Evaluate());
								actual = this.MakeConstant(value, formalDataType);
							}
						}
						else {
							string typeName = formalDataType.Name;
							string constValue = actual.ToString();
							this.report.SemanticError(177, formalName, constValue, typeName, location);
							actual = Expression.Error;
						}
					}
				}
				else if (formalDataType == TypeNode.LReal)
				{
					if (actualDataType.IsIntegerType)
						actual = this.MakeInt2LReal(actual);
					else if (actualDataType == TypeNode.Real)
						actual = this.MakeReal2LReal(actual);
					else if (this.ConversionOperatorExists(TypeNode.LReal, actualDataType))
					{
						actual = Expression.Error;
						this.report.SemanticError(64, actualDataType.Name, formalDataType.Name, location);
					}
					else {
						actual = Expression.Error;
						this.report.SemanticError(150, actualDataType.Name, formalDataType.Name, location);
					}
				}
				else if (formalDataType == TypeNode.Real)
				{
					if (actualDataType.IsIntegerType)
						actual = this.MakeInt2Real(actual);
					else if (this.ConversionOperatorExists(TypeNode.Real, actualDataType))
					{
						actual = Expression.Error;
						this.report.SemanticError(64, actualDataType.Name, formalDataType.Name, location);
					}
					else {
						actual = Expression.Error;
						this.report.SemanticError(150, actualDataType.Name, formalDataType.Name, location);
					}
				}
			}
		}
	}

	private void CheckVarTypeQualUsage(STVarType variableType, STVarQualifier qualifier, LexLocation loc1, LexLocation loc2)
	{
		this.variableType = variableType;
		this.variableQualifier = qualifier;

		// Kolla att kombinationen POU-typ + variabeltyp + attribut ï¿½r giltig.

		switch (variableType)
		{
		case STVarType.VAR:
			break;

		case STVarType.VAR_INPUT:
			if (qualifier == STVarQualifier.CONSTANT)
				this.report.SemanticError(158, "VAR_INPUT", "CONSTANT", loc1);
			break;

		case STVarType.VAR_OUTPUT:
			if (qualifier == STVarQualifier.CONSTANT)
				this.report.SemanticError(158, "VAR_OUTPUT", "CONSTANT", loc1);
			break;

		case STVarType.VAR_INOUT:
			if (qualifier != STVarQualifier.NONE)
				this.report.SemanticError(158, "VAR_INOUT", variableType.ToString(), loc1);
			break;

		case STVarType.VAR_GLOBAL:
			this.report.SemanticError(156, "VAR_GLOBAL", loc1);
			break;

		case STVarType.VAR_CONFIG:
			if (qualifier != STVarQualifier.NONE)
				this.report.SemanticError(158, "VAR_ACCESS", variableType.ToString(), loc1);
			break;

		case STVarType.VAR_EXTERNAL:
			if (this.isFunctionDecl)
				this.report.SemanticError(156, "VAR_EXTERNAL", loc1);
			if (qualifier == STVarQualifier.RETAIN) 
				this.report.SemanticError(158, "VAR_EXTERNAL", "RETAIN", loc1);
			else if (qualifier == STVarQualifier.NON_RETAIN)
				this.report.SemanticError(158, "VAR_EXTERNAL", "NON_RETAIN", loc1);
			break;

		case STVarType.VAR_TEMP:
			if (this.isFunctionDecl)
				this.report.SemanticError(46, "VAR_TEMP", loc1);
			if (qualifier == STVarQualifier.RETAIN) 
				this.report.SemanticError(158, "VAR_TEMP", "RETAIN", loc1);
			else if (qualifier == STVarQualifier.NON_RETAIN)
				this.report.SemanticError(158, "VAR_TEMP", "NON_RETAIN", loc1);
			break;

		case STVarType.VAR_ACCESS:
			this.report.SemanticError(156, "VAR_ACCESS", loc1);
			if (qualifier != STVarQualifier.NONE)
				this.report.SemanticError(158, "VAR_ACCESS", variableType.ToString(), loc1);
			break;

		default:
			break;
		}
	}

	private void CheckDeclQualifierUsage(TypeNode dataType, STVarQualifier varQualifier, STDeclQualifier declQualifier, LexLocation location)
	{
		switch (declQualifier)
		{
		case STDeclQualifier.NONE:
			break;

		case STDeclQualifier.READ_ONLY:
		case STDeclQualifier.WRITE_ONLY:
			if (this.variableType != STVarType.VAR_ACCESS)
			{
				string varType = this.variableType.ToString();
				string edgeQual = declQualifier.ToString();
				this.report.SemanticError(158, varType, edgeQual, location);
			}
			break;

		case STDeclQualifier.F_EDGE:
		case STDeclQualifier.R_EDGE:
			if (this.isFunctionDecl)
				this.report.SemanticError(159, declQualifier.ToString(), location);
			if (dataType != TypeNode.Bool)
				this.report.SemanticError(160, declQualifier.ToString(), location);
			break;
		}
		if (dataType.IsFunctionBlockType && varQualifier == STVarQualifier.CONSTANT)
			this.report.SemanticError(179, dataType.Name, location);
	}

	private POUType ProgOrgType
	{
		get 
		{
			if (this.isFunctionDecl)
				return POUType.FUNCTION;
			else if (this.isFunctionBlockDecl)
				return POUType.FUNCTION_BLOCK;
			else
				return POUType.PROGRAM;
		}
	}

	private DeclarationStatement MakeFormalParameterDecl(STVarType varType, STVarQualifier varQual, List<VarDeclStatement> formalParDeclList)
	{
		return new IOParameterDeclaration(varType, varQual, formalParDeclList, this.ProgOrgType);
	}

	private DeclarationStatement MakeLocalVariableDecl(STVarType varType, STVarQualifier varQual, List<VarDeclStatement> localVarDeclList)
	{
		return new LocalVarDeclaration(localVarDeclList, varType, varQual, this.ProgOrgType);
	}

	private POUVarDeclarations MakeEmptyPOUVarDecl()
	{
		return new POUVarDeclarations();
	}

	private List<VarDeclStatement> MakeEmptyVarDecl()
	{
		return new List<VarDeclStatement>();
	}

	private List<VarDeclStatement> MakeVariableDeclList(VarDeclStatement varInitDecl)
	{
		List<VarDeclStatement> varInitDeclList = new List<VarDeclStatement>();
		if (varInitDecl != null)
			varInitDeclList.Add(varInitDecl);
		return varInitDeclList;
	}

	private List<VarDeclStatement> AddToVariableDeclList(List<VarDeclStatement> varInitDeclList, VarDeclStatement varInitDecl)
	{
		if (varInitDeclList == null)
			varInitDeclList = new List<VarDeclStatement>();
		if (varInitDecl != null)
			varInitDeclList.Add(varInitDecl);
		return varInitDeclList;
	}

	private POUVarDeclarations MakePOUVarDeclList(DeclarationStatement declaration)
	{
		POUVarDeclarations pouVarDeclarations = new POUVarDeclarations();
		if (declaration != null)
			pouVarDeclarations.Add(declaration);
		return pouVarDeclarations;
	}

	private POUVarDeclarations AddPOUVarDeclToList(POUVarDeclarations pouDeclList, DeclarationStatement declaration)
	{
		if (pouDeclList == null)
			pouDeclList = new POUVarDeclarations();
		if (declaration != null)
			pouDeclList.Add(declaration);
		return pouDeclList;
	}

	private void StoreArrayInitializer(ArrayInitializer arrayInit)
	{
		TypeNode elementType = arrayInit.BasicElementType;
		int alignment = (int)elementType.Alignment;
		byte[] bytes = arrayInit.GetBytes();
		int offset = ByteCodeGenerator.StoreByteArray(bytes, alignment);
		arrayInit.AbsoluteAddress = MakeIntConstant(offset);
	}

	private VarDeclStatement MakeVarDeclStatement(List<MemoryObject> variables, TypeNode dataType, STVarType varType, 
	                                    STDeclQualifier declQual, Expression initialValue, int elementCount = 1)
	{
		Expression declSize;
		if (varType == STVarType.VAR_INOUT)
		{
		    // Store offset of variable as a DINT
			//
			int byteCount = variables.Count*(int)TypeNode.DInt.Size;
			declSize = MakeIntConstant(byteCount);
			return new ElementaryVarDeclStatement(variables, dataType, declQual, initialValue, declSize);
		}
		else if (dataType.IsElementaryType)
		{
			int byteCount = variables.Count*(int)dataType.Size;
			declSize = MakeIntConstant(byteCount);
			return new ElementaryVarDeclStatement(variables, dataType, declQual, initialValue, declSize);
		}
		else if (dataType.IsAnyStringType)
		{
            //
            // Store information about string buffer offset and size.
            //
			int stringType = dataType.IsStringType ? 0 : 1;
            foreach (MemoryObject variable in variables)
            {
                if (variable.Location is StringLocation)
                {
                    StringLocation stringLocation;

                    stringLocation = (StringLocation)variable.Location;
                    int bufferSize = (int)variable.DataType.Size;
                    int bufferOffset = stringLocation.BufferOffset;
					int index = stringLocation.Index;
					ByteCodeGenerator.StoreStringVariableData(bufferOffset, index, bufferSize, stringType);
                }
            }
			int byteCount = variables.Count*(int)dataType.Size;
			declSize = MakeIntConstant(byteCount);
			return new ElementaryVarDeclStatement(variables, dataType, declQual, initialValue, declSize);
		}
		else if (dataType.IsStructType)
		{
			VarDeclStatement memberInitStat;
			List<VarDeclStatement> memberInitCollection;
			int byteCount = variables.Count*(int)dataType.Size;
			FieldSymbol field = ((StructType)dataType.BaseType).FirstField;

			declSize = MakeIntConstant(byteCount);
			memberInitCollection = new List<VarDeclStatement>();
			if (initialValue is StructInitializer)
			{
				Expression initializer;
				List<MemoryObject> members;
				StructInitializer structInit = (StructInitializer)initialValue;
				while (field != null)
				{
					if (structInit.Contains(field.Name, out initializer))
					{
						members = this.CreateMemberList(variables, field.Name);
						memberInitStat = this.MakeVarDeclStatement(members, field.DataType, varType, declQual, initializer, elementCount);
						memberInitCollection.Add(memberInitStat);
					}
					field = field.Next;
				}
			}
			return new StructVarDeclStatement(variables, dataType, declQual, initialValue, declSize, memberInitCollection);
		}
		else if (dataType.IsFunctionBlockType)
		{
			if (initialValue is FunctionBlockInitializer)
			{
				int byteCount;
				InstanceSymbol member;
				Expression initializer;
				List<MemoryObject> members;
				VarDeclStatement memberDeclStat;
				List<VarDeclStatement> memberDeclStats;
				FunctionBlockInitializer functionBlockInit;

				byteCount = variables.Count*(int)dataType.Size;
				declSize = MakeIntConstant(byteCount);
				memberDeclStats = new List<VarDeclStatement>();
				functionBlockInit = (FunctionBlockInitializer)initialValue;
				member = ((FunctionBlockType)dataType.BaseType).FirstMember;
				while (member != null)
				{
					if (functionBlockInit.Contains(member.Name, out initializer))
					{
						members = this.CreateMemberList(variables, member.Name);
						memberDeclStat = this.MakeVarDeclStatement(members, member.DataType, varType, declQual, initializer, elementCount);
						memberDeclStats.Add(memberDeclStat);
					}
					member = member.Next;
				}
				return new FunctionBlockVarDeclStat(variables, dataType, declQual, initialValue, declSize, memberDeclStats);
			}
		}
		else if (dataType.IsArrayType)
		{
		    ArrayType array = (ArrayType)dataType;
            TypeNode elementType = array.BasicElementType;

			if (elementType.IsElementaryType || elementType.IsAnyStringType)
            {
				if (initialValue is DefaultArrayInitializer)
				{
					int initValCase;
					if (initialValue.IsZero)
					{
						initValCase = 0;
						int byteCount = variables.Count*(int)dataType.Size;
						declSize = MakeIntConstant(byteCount);
					}
					else {
						initValCase = 1;
						uint size = elementType.Size;
						long elemCount = (dataType.Size / size)*variables.Count;
						declSize = MakeIntConstant(elemCount);
					}
					if (elementType.IsAnyStringType)
					{
						int stringType = elementType.IsStringType ? 0 : 1;
						int bufferSize = (int)elementType.Size;
						int elemCount = (int)(dataType.Size / bufferSize);
						foreach (MemoryObject variable in variables)
						{
							if (variable.Location is StringLocation)
							{
								StringLocation stringLocation;

								stringLocation = (StringLocation)variable.Location;
								int bufferOffset = stringLocation.BufferOffset;
								int index = stringLocation.Index;
								ByteCodeGenerator.StoreStringVariableData(bufferOffset, index, bufferSize, stringType, elemCount);
							}
						}
					}
					return new ArrayVarDeclStatement(variables, dataType, declQual, initialValue, declSize, initValCase);
				}
				else if (initialValue is ArrayInitializer)
				{
					STVarQualifier varQual = this.variableQualifier;
					ArrayInitializer arrayInit = (ArrayInitializer)initialValue;
					if (elementType.IsAnyStringType)
					{
						int stringType = elementType.IsStringType ? 0 : 1;
						int bufferSize = (int)elementType.Size;
						int elemCount = (int)(dataType.Size / bufferSize);
						foreach (MemoryObject variable in variables)
						{
							if (variable.Location is StringLocation)
							{
								StringLocation stringLocation;

								stringLocation = (StringLocation)variable.Location;
								int bufferOffset = stringLocation.BufferOffset;
								int index = stringLocation.Index;
								ByteCodeGenerator.StoreStringVariableData(bufferOffset, index, bufferSize, stringType, elemCount);
							}
						}
					}
					if (arrayInit.IsConstant)
					{
						this.StoreArrayInitializer(arrayInit);
						declSize = MakeIntConstant((long)dataType.Size);
						if (this.IsConstantVarDecl(varQual))
							return new ArrayVarDeclStatement(variables, dataType, declQual, arrayInit, declSize, 3);
						else
							return new ArrayVarDeclStatement(variables, dataType, declQual, arrayInit, declSize, 2);
					}
					else {
						int constCount = 0;
						IEnumerable<Expression> initializerList;

						initializerList = arrayInit.FlattenedInitializerList;
						foreach (Expression initValue in initializerList)
						{
							if (initValue.IsConstant)
								constCount++;
						}
						double constRatio = (double)constCount/initializerList.Count();
						if (constRatio < 0.7)
						{
							declSize = MakeIntConstant(initializerList.Count());
							if (this.IsConstantVarDecl(varQual))
								return new ArrayVarDeclStatement(variables, dataType, declQual, initialValue, declSize, 3, constRatio);
							else
								return new ArrayVarDeclStatement(variables, dataType, declQual, initialValue, declSize, 2, constRatio);
						}
						else {
							int i,offset;
							int baseIndex; 
							Expression defaultValue;
							ArrayInitializer newArrayInit;
							List<AssignmentStat> assignStatList;
							List<Expression> constInitList,nonConstInitList;

							constInitList = new List<Expression>();
							nonConstInitList = new List<Expression>();
							defaultValue = elementType.DefaultValue;
							declSize = MakeIntConstant((long)dataType.Size);
							foreach (Expression initValue in initializerList)
							{
								if (initValue.IsConstant)
									constInitList.Add(initValue);
								else {
									constInitList.Add(defaultValue);
									nonConstInitList.Add(initValue);
								}
							}
							assignStatList = new List<AssignmentStat>();
							newArrayInit = arrayInit.CreateInitList(constInitList);
							this.StoreArrayInitializer(newArrayInit);
							foreach (MemoryObject variable in variables)
							{
								i = 0;
								offset = 0;
								baseIndex = variable.Location.Index;
								foreach (Expression initValue in initializerList)
								{
									if (! initValue.IsConstant)
									{
										Expression lValue;
										MemoryLocation location;
										AssignmentStat assignStat;
                                        string name = variable + "[" + offset + "]";
										Expression rValue = nonConstInitList[i++];
										location = new ElementaryLocation(baseIndex + offset, elementType);
										lValue = new MemoryObject(name, location, elementType, variable.Symbol, 4);
										assignStat = new SimpleAssignmentStat(lValue, rValue);
										assignStatList.Add(assignStat);
									}
									offset++;
								}
							}
							if (this.IsConstantVarDecl(varQual))
								return new ArrayVarDeclStatement(variables, dataType, declQual, newArrayInit, declSize, 3, constRatio, assignStatList);
							else
								return new ArrayVarDeclStatement(variables, dataType, declQual, newArrayInit, declSize, 2, constRatio, assignStatList);
						}
					}
				}
			}
			else if (elementType.IsStructType)
			{
				VarDeclStatement memberInitStat;
				InitializerList flattenedInitList;
				StructType structure = (StructType)elementType.BaseType;
				FieldSymbol field = structure.FirstField;
				List<VarDeclStatement> memberInitCollection;
				Expression size = MakeIntConstant((long)dataType.Size);

				memberInitCollection = new List<VarDeclStatement>();
			    if (initialValue is ArrayOfStructInitializer)
				{
					List<MemoryObject> members;
					ArrayOfStructInitializer arrayOfStructInit;
					arrayOfStructInit = (ArrayOfStructInitializer)initialValue;
					elementCount = (int)(array.Size/elementType.Size)*elementCount;

					while (field != null)
					{
						members = this.CreateMemberList(variables, field); 
						flattenedInitList = arrayOfStructInit.GetFlattenedInitializerList(field.Name);
						memberInitStat = this.MakeVarDeclStatement(members, flattenedInitList.DataType, varType, declQual, flattenedInitList, elementCount);
						memberInitCollection.Add(memberInitStat);
						field = field.Next;
					}
				}
				return new ArrayOfStructVarDeclStatement(variables, dataType, declQual, initialValue, size, memberInitCollection);
			}
			else if (elementType.IsFunctionBlockType)
			{
			}
		}
		Expression zeroSize = MakeIntConstant((long)0);
		return new ElementaryVarDeclStatement(variables, dataType, declQual, initialValue, zeroSize);
	}

	private List<MemoryObject> CreateMemberList(List<MemoryObject> variables, FieldSymbol field)
	{
		InstanceSymbol symbol;
		List<MemoryObject> members = new List<MemoryObject>();

		foreach (MemoryObject variable in variables)
		{
			symbol = variable.Symbol;
			if (symbol.IsArrayInstance)
			{
                InstanceSymbol elementSymbol;
                ArrayInstanceSymbol arraySymbol;

				arraySymbol = (ArrayInstanceSymbol)symbol;
                elementSymbol = arraySymbol.ElementSymbol;
                if (elementSymbol.IsStructInstance)
                {
                    InstanceSymbol memberSymbol;
                    StructInstanceSymbol structure;

                    structure = (StructInstanceSymbol)elementSymbol;
                    if (structure.LookUp(field.Name, out memberSymbol))
					{
						MemoryObject member;

						member = (MemoryObject)memberSymbol.MakeSyntaxTreeNode();
                        members.Add(member);
					}
                }
			}
		}
		return members;
	}

	private List<MemoryObject> CreateMemberList(List<MemoryObject> variables, string member)
	{
		InstanceSymbol symbol;
		List<MemoryObject> members = new List<MemoryObject>();

		foreach (MemoryObject variable in variables)
		{
			symbol = variable.Symbol;
            if (symbol.IsCompoundInstanceSymbol)
            {
                InstanceSymbol memberSymbol;
                CompoundInstanceSymbol compoundSymbol;

                compoundSymbol = (CompoundInstanceSymbol)symbol;
                if (compoundSymbol.LookUp(member, out memberSymbol))
				{
					MemoryObject memberObject;

					memberObject = (MemoryObject)memberSymbol.MakeSyntaxTreeNode();
                    members.Add(memberObject);
				}
            }
		}
		return members;
	}

	private VarDeclStatement InstallLocalVars(List<string> identifiers, TypeNode dataType, STDeclQualifier declQual, LexLocation location)
	{
		if (identifiers == null)
			return null;
		else if (identifiers.Count == 0)
			return null;
		else {
			STVarType varType = this.variableType;
			Expression initialValue = dataType.DefaultValue;
			STVarQualifier varQual = this.variableQualifier;
			List<InstanceSymbol> symbols = new List<InstanceSymbol>();

			this.CheckDeclQualifierUsage(dataType, varQual, declQual, location);
			foreach (string name in identifiers)
			{
				InstanceSymbol symbol;
				symbol = this.rwMemoryManager.CreateSymbol(name, dataType, varType, varQual, declQual, initialValue, this.variablePosition);
				symbols.Add(symbol);
				this.variablePosition++;
			}
			this.symbolTable.InstallLocalVariables(symbols);
			if (this.IsConstantVarDecl(varQual))
            {
                // Error. Constant variables must be assigned a value in the declaration.
                this.report.SemanticError(9, location);
				// CONSTANT variables (with constant initializers) are initialized at compile time
                if (dataType.IsElementaryType)
                    return null;
            }
            MemoryObject variable;
            List<MemoryObject> variables = new List<MemoryObject>();

            foreach (InstanceSymbol symbol in symbols)
            {
                variable = (MemoryObject)symbol.MakeSyntaxTreeNode();
                variables.Add(variable);
            }
            return this.MakeVarDeclStatement(variables, dataType, varType, declQual, initialValue);
		}
	}

	private bool IsConstantVarDecl(STVarQualifier varQual)
	{
		return varQual == STVarQualifier.CONSTANT 
		    || varQual == STVarQualifier.CONSTANT_RETAIN;
	}

	private VarDeclStatement InstallLocalVars(List<string> identifiers, TypeNode dataType, STDeclQualifier declQual, Expression initialValue, LexLocation location)
	{
		this.Pop(); // Remove datatype saved on stack.
		if (identifiers == null)
			return null;
		else if (identifiers.Count == 0)
			return null;
		else {
			STVarType varType = this.variableType;
			STVarQualifier varQual = this.variableQualifier;
			List<InstanceSymbol> symbols = new List<InstanceSymbol>();

			this.CheckDeclQualifierUsage(dataType, varQual, declQual, location);
			foreach (string name in identifiers)
			{
				InstanceSymbol symbol;
				int pos = this.variablePosition++;
				symbol = this.rwMemoryManager.CreateSymbol(name, dataType, varType, varQual, declQual, initialValue, pos);
				symbols.Add(symbol);
			}
			this.symbolTable.InstallLocalVariables(symbols);
			if (this.IsConstantVarDecl(varQual) && initialValue.IsConstant && dataType.IsElementaryType)
				return null;  // Don't reserve memory for CONSTANT variables (with constant initializers) of elementary type.
			else {
				MemoryObject variable;
				List<MemoryObject> variables = new List<MemoryObject>();

				foreach (InstanceSymbol symbol in symbols)
				{
					variable = (MemoryObject)symbol.MakeSyntaxTreeNode();
					variables.Add(variable);
				}
				if (initialValue.IsLValue && !dataType.IsElementaryType)
				{
					MemoryObject memoryObject = (MemoryObject)initialValue;

					initialValue = memoryObject.InitialValue;
				}
				return this.MakeVarDeclStatement(variables, dataType, varType, declQual, initialValue);
			}
		}
	}

	private VarDeclStatement InstallSymbolicVariable(string name, DataTypeSpec dataTypeSpec, TokenDirectVar directVar, LexLocation loc)
	{
		if (! this.symbolTable.IsValidUserDefinedSymbol(name, loc))
			return null;
		else {
			InstanceSymbol symbol;
			TypeNode dataType = dataTypeSpec.DataType;
			STDeclQualifier declQual = dataTypeSpec.DeclQualifier;
			Expression initialValue = dataTypeSpec.InitialValue;
			this.symbolTable.InstallDirectVariable(name, dataType, this.variableType, this.variableQualifier,
			                                       dataTypeSpec.DeclQualifier, directVar.Size, directVar.Location, 
												   directVar.Address, out symbol);
			Expression size = MakeIntConstant((long)dataType.Size);
			List<MemoryObject> variables = new List<MemoryObject>();
			variables.Add((MemoryObject)symbol.MakeSyntaxTreeNode());
			return new ElementaryVarDeclStatement(variables, dataType, declQual, size, initialValue);
		}
	}

	private VarDeclStatement InstallDirectVariable(TokenDirectVar directVar, DataTypeSpec dataTypeSpec, LexLocation loc)
	{
		string name = directVar.ToString();
		if (! this.symbolTable.IsValidUserDefinedSymbol(name, loc))
			return null;
		else if (! this.isProgramDecl)
		{
			this.report.SemanticError(186, name, loc);
			return null;
		}
		else {
			InstanceSymbol symbol;
			TypeNode dataType = dataTypeSpec.DataType;
			STDeclQualifier declQual = dataTypeSpec.DeclQualifier;
			Expression initialValue = dataTypeSpec.InitialValue;
			this.symbolTable.InstallDirectVariable(name, dataType, this.variableType, this.variableQualifier,
			                                       dataTypeSpec.DeclQualifier, directVar.Size, directVar.Location, 
												   directVar.Address, out symbol);
			Expression size = MakeIntConstant((long)dataType.Size);
			List<MemoryObject> variables = new List<MemoryObject>();
			variables.Add((MemoryObject)symbol.MakeSyntaxTreeNode());
			return new ElementaryVarDeclStatement(variables, dataType, declQual, size, initialValue);
		}
	}

	private Expression TypeCheckInitialValue(Expression initialValue, LexLocation location)
	{	
		TypeNode declDataType = this.attributeStack.Top;

		if (initialValue == null)
			return declDataType.DefaultValue;
		else if (declDataType == TypeNode.Error)
			return Expression.Error;
		else if (initialValue.DataType == TypeNode.Error)
			return declDataType.DefaultValue;
		else if (initialValue is FunctionName)
		{
			this.report.SemanticError(148, initialValue.ToString(), location);
			return declDataType.DefaultValue;
		}
		else {
			TypeNode initValDataType = initialValue.DataType;

			if (initValDataType == TypeNode.Bool && initialValue.IsCompoundExpression)
				initialValue = new LoadBoolValueOperator(initialValue);
			if (declDataType == initValDataType)
			{
				if (declDataType.IsOrdinalType && declDataType.IsSubrangeType)
				{
					if (initialValue.IsConstant)
					{
						if (declDataType.IsSignedIntType)
						{
							long numericValue = Convert.ToInt64(initialValue.Evaluate());
							if (! declDataType.IsInRange(numericValue))
							{
								string strValue = initialValue.ToString();
								string typeName = declDataType.Name;
								this.report.SemanticError(171, strValue, typeName, location);
							}
						}
						else {
							ulong numericValue = Convert.ToUInt64(initialValue.Evaluate());
							if (! declDataType.IsInRange(numericValue))
							{
								string strValue = initialValue.ToString();
								string typeName = declDataType.Name;
								this.report.SemanticError(171, strValue, typeName, location);
							}
						}
					}
					else if (initValDataType.IsSubrangeType)
					{
						SubRange initSubrange = initValDataType.GetSubrange();
						SubRange declSubrange = declDataType.GetSubrange();
						if (declSubrange.IsDisjoint(initSubrange))
							this.report.SemanticError(11, declDataType.Name, initValDataType.Name, location);
					}
				}
				return initialValue;
			}
			else if (declDataType == TypeNode.LReal && initValDataType.IsIntegerType)
			{
				if (! initialValue.IsConstant)
					return new Int2LRealOperator(initialValue);
				else {
					double doubleValue = Convert.ToDouble(initialValue.Evaluate());
					return MakeConstant(doubleValue);
				}
			}
			else if (declDataType == TypeNode.LReal && initValDataType == TypeNode.Real)
			{
				if (! initialValue.IsConstant)
					return new Real2LRealOperator(initialValue);
				else {
					double doubleValue = Convert.ToDouble(initialValue.Evaluate());
					return MakeConstant(doubleValue);
				}
			}
			else if (declDataType == TypeNode.Real && initValDataType == TypeNode.LReal)
			{
				if (! initialValue.IsConstant)
					this.report.SemanticError(27, declDataType.Name, initValDataType.Name, location);
				else {
					float floatValue = Convert.ToSingle(initialValue.Evaluate());
					return MakeConstant(floatValue);
				}
			}
			else if (declDataType == TypeNode.Real && initValDataType.IsIntegerType)
			{
				if (! initialValue.IsConstant)
					return new Int2RealOperator(initialValue);
				else {
					float singleValue = Convert.ToSingle(initialValue.Evaluate());
					return MakeConstant(singleValue);
				}
			}
			else if (declDataType.IsIntegerType && initValDataType.IsIntegerType)
			{
				if (declDataType.IsUnsignedIntType && initValDataType.IsSignedIntType
				 || declDataType.IsSignedIntType && initValDataType.IsUnsignedIntType
				 || declDataType.Size < initValDataType.Size)
				{
					this.report.SemanticError(64, initValDataType.Name, declDataType.Name, location);
					initialValue = declDataType.DefaultValue;
				}
			}
			else if (declDataType.IsBitStringType && initValDataType.IsIntegerType)
			{
				if (! initialValue.IsConstant)
					this.report.SemanticError(64, initValDataType.Name, declDataType.Name, location);
				else {
					ulong value = Convert.ToUInt64(initialValue.Evaluate());
					if (declDataType.Size < initValDataType.Size)
						this.report.SemanticError(64, initValDataType.Name, declDataType.Name, location);
					return this.MakeConstant(value, declDataType);
				}
			}
			else if (declDataType.IsBitStringType && initValDataType.IsBitStringType)
			{
				if (declDataType.Size < initValDataType.Size)
					this.report.SemanticError(64, initValDataType.Name, declDataType.Name, location);
			}
			else if (declDataType.IsStringType && initValDataType.IsStringType)
			{
				if (declDataType.Size < initValDataType.Size)
					this.report.SemanticError(35, initialValue.ToString(), location);
			}
			else if (declDataType.IsWStringType && initValDataType.IsWStringType)
			{
				if (declDataType.Size < initValDataType.Size)
					this.report.SemanticError(35, initialValue.ToString(), location);
			}
			else
				this.report.SemanticError(27, declDataType.Name, initValDataType.Name, location);
			return initialValue;
		}
	}

	private List<object> MakeExpressionList(Expression expression, LexLocation location)
	{
		if (expression == null)
			return new List<object>{Expression.Error};
		else if (expression is FunctionName)
		{
			this.report.SemanticError(148, expression.ToString(), location);
			return new List<object>{Expression.Error};
		}
		else
			return new List<object>{expression};
	}

	private List<object> MakeExpressionList(List<object> exprList, Expression expression, LexLocation location)
	{
		if (expression == null)
			exprList.Add(Expression.Error);
		else if (expression is FunctionName)
		{
			this.report.SemanticError(148, expression.ToString(), location);
			exprList.Add(Expression.Error);
		}
		else
			exprList.Add(expression);
		return exprList;
	}

	private Expression MakeSymbolicVariable(Expression expression)
	{
		if (expression == null || expression == Expression.Error)
			return Expression.Error;
		else if (! expression.IsLValue)
			return expression;
		else if (expression.DataType.IsArrayType)
		{
			ArrayType array = (ArrayType)expression.DataType;
			TypeNode elementType = array.BasicElementType;

			if (elementType.IsElementaryType || elementType.IsAnyStringType)
			{
                Expression absoluteAddress;
				Expression size = MakeIntConstant(array.Size);
                MemoryObject lValue = (MemoryObject)expression;
				absoluteAddress = this.rwMemoryManager.GetAbsoluteAddress(lValue.Symbol);
				if (lValue.Offset != null)
				{
					Expression factor = MakeIntConstant(elementType.Size);
					Expression offset = this.MakeIntMulOp(lValue.Offset, factor);
                    absoluteAddress = this.MakeIntAddOp(offset, absoluteAddress);
				}
				lValue.Location.AbsoluteAddress = absoluteAddress;
				lValue.Location.Size = size;
			}
		}
		return expression;
	}

	private Expression MakeSimpleVariable(string identifier, LexLocation location)
	{
		STLangSymbol symbol;
		if (this.isSubrangeDecl)
		{
			if (! this.symbolTable.Lookup(identifier, this.subrangeDataType, out symbol, location))
			{
				this.report.SemanticError(0, identifier, location);
				this.symbolTable.InstallUndeclaredVariable(identifier, out symbol);
			}
		}
		else if (! this.symbolTable.Lookup(identifier, out symbol, location))
		{
			this.report.SemanticError(0, identifier, location);
			this.symbolTable.InstallUndeclaredVariable(identifier, out symbol);
		}
		return symbol.MakeSyntaxTreeNode(location);
	}

	private Expression MakeSimpleVariable(Expression expression, string memberName, LexLocation location)
	{
		if (expression == null)
			return Expression.Error;
		else if (expression == Expression.Error)
			return Expression.Error;
		else if (! expression.IsLValue)
		{
			this.report.SemanticError(3, expression.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode dataType = expression.DataType;
			if (dataType.IsStructType)
			{
				MemoryObject memoryObject = (MemoryObject)expression;
				InstanceSymbol symbol = memoryObject.Symbol;
				if (symbol.IsArrayInstance)
                {
					ArrayInstanceSymbol arrayInstance;

					arrayInstance = (ArrayInstanceSymbol)symbol;
					symbol = arrayInstance.ElementSymbol;
					if (! symbol.IsStructInstance)
					{
						string msg = "MakeSimpleVariable() failed.";
						msg += " StructInstanceSymbol expected: " + symbol.Name;
						throw new STLangCompilerError(msg);
					}
                }
				InstanceSymbol member;
				StructInstanceSymbol structure = (StructInstanceSymbol)symbol;
				if (! structure.LookUp(memberName, out member))
				{
					this.report.SemanticError(4, memberName, dataType.Name, location);
					return Expression.Error;
				}
				else
				{
					int length = memoryObject.Length + 2;
					Expression offset = memoryObject.Offset;
					string stringValue = expression + "." + memberName;
					return new MemoryObject(member, offset, stringValue, length);
				}
			}
			else if (dataType == TypeNode.Error)
				return Expression.Error;
			else if (dataType.IsFunctionBlockType)
			{
				MemoryObject memoryObject = (MemoryObject)expression;
				InstanceSymbol symbol = memoryObject.Symbol;
				if (! symbol.IsFunctionBlockInstance)
				{
					string msg = "MakeSimpleVariable() failed.";
					msg += " FunctionBlockInstanceSymbol expected: " + symbol.Name;
					throw new STLangCompilerError(msg);
				}
				else
				{
					InstanceSymbol member;
					FunctionBlockInstanceSymbol functionBlock;

					functionBlock = (FunctionBlockInstanceSymbol)symbol;
					if (! functionBlock.LookUp(memberName, out member))
					{
						this.report.SemanticError(136, memberName, dataType.Name, location);
						return Expression.Error;
					}
					else if (member.IsLocalVariable)
					{
						string varType = member.VariableType.ToString();
						this.report.SemanticError(137, varType, memberName, dataType.Name, location);
						return Expression.Error;
					}
					else {
						int length = memoryObject.Length + 2;
						Expression offset = memoryObject.Offset;
						string stringValue = expression + "." + memberName;
						return new MemoryObject(member, offset, stringValue, length);
					}
				}
			}
		}
		this.report.SemanticError(3, expression.ToString(), location);
        return Expression.Error;
	}

	private void CheckArrayIndex(Expression index, ArrayType array, string varName, LexLocation location)
	{
		long indexValue = Convert.ToInt64(index.Evaluate());
		if (indexValue < array.LowerBound)
			this.report.SemanticError(123, indexValue, varName, array.LowerBound, location);
		else if (indexValue > array.UpperBound)
			this.report.SemanticError(124, indexValue, varName, array.UpperBound, location);
	}

	private Expression MakeIndexedVariable(IndexedVariable variable)
	{
		if (variable == null)
			return Expression.Error;
		else {
			string name = variable.Name + "]";
			int length = variable.Length + 1; 
			MemoryLocation location = variable.Offset;
			InstanceSymbol symbol = variable.Symbol;
			int constantPart = variable.ConstantPart;
			Expression variablePart = variable.VariablePart;
			TypeNode dataType = variable.DataType;
			this.isIndexExpr = false;
			if (variablePart == null)
				throw new STLangCompilerError("MakeIndexedVariable() failed: Offset is null.");
			else if (dataType.IsElementaryType || dataType.IsAnyStringType)
			{
				if (variablePart.IsConstant)
				{
					int varPart = Convert.ToInt32(variablePart.Evaluate());
					int offset = varPart - constantPart;
					if (! symbol.IsConstant)
					{
						int index = location.Index + offset;
						location = new ElementaryLocation(index, dataType);
						return new MemoryObject(name, location, dataType, symbol, length);
					}
					else if (symbol.InitialValue is ArrayInitializer)
					{
						// Constant array with constant array index. Get array element
						// at position 'offset' in the array initializer.
						//
						ArrayInitializer arrayInit;
						arrayInit = (ArrayInitializer)symbol.InitialValue;
						Expression rValue = arrayInit.GetElementAt(offset);
						return new MemoryObject(rValue, name, symbol, length);
					}
					else if (symbol.InitialValue is ArrayOfStructInitializer)
					{
						ArrayOfStructInitializer arrayInit;
						arrayInit = (ArrayOfStructInitializer)symbol.InitialValue;
						Expression rValue = arrayInit.GetElementAt(offset);
						return new MemoryObject(rValue, name, symbol, length);
					}
					throw new STLangCompilerError("ArrayInitializer type expected.");
				}
				else if (constantPart == 0)
					return new MemoryObject(name, location, variablePart, dataType, symbol, length);
				else 
				{
				    if (variablePart is IntAddOperator)
					{
						Expression rightOperand;
						rightOperand = ((IntAddOperator)variablePart).RightOperand;
						if (rightOperand.IsConstant)
							constantPart = Convert.ToInt32(rightOperand.Evaluate()) - constantPart;
					}
					Expression constant = MakeIntConstant(constantPart);
					Expression offset = new IntSubOperator(variablePart, constant, TypeNode.DInt);
					return new MemoryObject(name, location, offset, dataType, symbol, length);
				}
			}
			else if (dataType.IsArrayType)
			{
				ArrayType array = (ArrayType)dataType;
				long elementWidth = (long)array.Size/array.BasicElementType.Size;
				Expression elemWidth = MakeIntConstant(elementWidth);
				Expression offset = this.MakeIntMulOp(variablePart, elemWidth);
				if (constantPart != 0)
				{
					long value = constantPart*elementWidth;
					Expression constant = MakeIntConstant(value);
					offset = this.MakeIntSubOp(offset, constant);
				}
				Expression size = MakeIntConstant((long)array.Size);
				if (!offset.IsConstant)
					return new MemoryObject(name, location, offset, dataType, symbol, length);
				else
				{
					int value = Convert.ToInt32(offset.Evaluate());
					location = location.AddOffset(value);
					return new MemoryObject(name, location, dataType, symbol, length);
				}
			}
			else if (dataType.IsStructType)
			{
			}
			return Expression.Error;
		}
	}

	private IndexedVariable MakeIndexedVariable(IndexedVariable variable, Expression index, LexLocation loc1, LexLocation loc2)
	{
		if (variable == null)
			return null;
		else if (index == null)
			return variable;
		else if (! index.DataType.IsIntegerType && index.DataType != TypeNode.Error)
			this.report.SemanticError(30, index.ToString(), loc2);
		if (! variable.DataType.IsArrayType)
		{
			string parameter = variable.Name + "," + index + "]";
			this.report.SemanticError(167, parameter, loc1);
			return variable;
		}
		else {
			Expression variablePart;
			InstanceSymbol symbol = variable.Symbol;
			MemoryLocation offset = variable.Offset;
			int constantPart = variable.ConstantPart;
			string name = variable.Name + "," + index;
			int length = variable.Length + index.Length;
			ArrayType array = (ArrayType)variable.DataType;
			if (index.IsConstant)
				this.CheckArrayIndex(index, array, variable.Symbol.Name, loc2);
			else if (! index.IsLinear()  || !index.ConstantForLoopBounds(this.forLoopDataList))
				index = this.MakeRangeCheckOperator(index, array);
			else {
				int lowerBound = array.LowerBound;
				int upperBound = array.UpperBound;
				int powerSetSize = 1 << this.forLoopDataList.Count;
				for (int word = 0; word < powerSetSize; word++)
				{
					int indexValue = index.Evaluate(word, this.forLoopDataList);
					if (indexValue < lowerBound || indexValue > upperBound)
					{
						index = this.MakeRangeCheckOperator(index, array);
						break;
					}
				}
			}
			Expression factor = MakeIntConstant(array.Range);
			variablePart = this.MakeIntMulOp(variable.VariablePart, factor);
			variablePart = this.MakeIntAddOp(variablePart, index);
			constantPart = array.Range*constantPart + array.LowerBound;
			TypeNode elemType = array.ElementType;
			return new IndexedVariable(offset, elemType, variablePart, constantPart, symbol, name, length);
		}
	}

	private Expression MakeRangeCheckOperator(Expression index, ArrayType array)
	{
		Expression lowerBound = MakeIntConstant(array.LowerBound);
		Expression upperBound = MakeIntConstant(array.UpperBound);
		return new RangeCheckOperator(index, lowerBound, upperBound);
	}

	private IndexedVariable MakeIndexedVariable(Expression expression, Expression index, LexLocation loc1, LexLocation loc2)
	{
		if (expression == null || index == null)
			return null;
		else if (! index.DataType.IsIntegerType && index.DataType != TypeNode.Error)
			this.report.SemanticError(30, index.ToString(), loc2);
		if (expression.DataType == TypeNode.Error)
			return null;
		if (! expression.IsLValue)
		{
			this.report.SemanticError(2, expression.ToString(), loc1);
			return null;
		}
		else if (! expression.DataType.IsArrayType)
		{
			this.report.SemanticError(2, expression.ToString(), loc1);
			return null;
		}
		else {
			MemoryObject lValue = (MemoryObject)expression;
			MemoryLocation location = lValue.Location;
			InstanceSymbol symbol = lValue.Symbol;
			Expression offset = lValue.Offset;
			ArrayType array = (ArrayType)expression.DataType;
			TypeNode elemType = array.ElementType;
			int constPart = array.LowerBound;
			int length = index.Length + 2;
			string name = lValue + "[" + index;
			if (index.IsConstant)
				this.CheckArrayIndex(index, array, symbol.Name, loc2);
			else if (! index.IsLinear() || !index.ConstantForLoopBounds(this.forLoopDataList))
				index = this.MakeRangeCheckOperator(index, array);
			else {
				int lowerBound = array.LowerBound;
				int upperBound = array.UpperBound;
				int powerSetSize = 1 << this.forLoopDataList.Count;
				for (int word = 0; word < powerSetSize; word++)
				{
					int indexValue = index.Evaluate(word, this.forLoopDataList);
					if (indexValue < lowerBound || indexValue > upperBound)
					{
						index = this.MakeRangeCheckOperator(index, array);
						break;
					}
				}
			}
			if (offset == null)
				return new IndexedVariable(location, elemType, index, constPart, symbol, name, length);
			else if (offset is IntSubOperator)
			{
				BinaryOperator binaryOp = (BinaryOperator)offset;
				Expression variablePart = binaryOp.LeftOperand;
				Expression factor = MakeIntConstant(array.Range);
				object constantValue = binaryOp.RightOperand.Evaluate();
				int constantPart = Convert.ToInt32(constantValue);
				variablePart = this.MakeIntMulOp(variablePart, factor);
				variablePart = this.MakeIntAddOp(variablePart, index);
				constantPart = array.Range*constantPart + array.LowerBound;
				return new IndexedVariable(location, elemType, variablePart, constantPart, symbol, name, length);
			}
			return null;
		}
	}

	private Expression MakeDirectVariable(TokenDirectVar directVar, LexLocation location)
	{
		STLangSymbol symbol;
		string name = directVar.ToString();
		if (! this.symbolTable.Lookup(name, out symbol, location))
		{
			this.report.SemanticError(129, name, location);
			this.symbolTable.InstallUndeclaredDirectVariable(directVar, out symbol);
		}
		return symbol.MakeSyntaxTreeNode(location);
	}

	private List<CaseLabel> MakeCaseLabelList(CaseLabel caseLabel, LexLocation location)
	{
		List<CaseLabel> caseLabelList = new List<CaseLabel>();
		return this.AddCaseLabelToList(caseLabelList, caseLabel, location);
	}

	private CaseElement MakeCaseElement(List<CaseLabel> constList, StatementList statList)
	{
		this.PopTop();
		CaseElement caseElem = new CaseElement();
		if (constList == null)
			constList = new List<CaseLabel>();
		caseElem.LabelList = constList;
		caseElem.StatementList = statList;
		return caseElem;
	}

	private CaseElement MakeDefaultCaseElement(StatementList statList)
	{
		this.PopTop();
		CaseElement defaultCaseElem = new CaseElement();
		defaultCaseElem.StatementList = statList;
		defaultCaseElem.LabelList = null; // Empty list
		return defaultCaseElem;
	}

	private List<CaseElement> MakeCaseElementList(object caseElement)
	{
		List<CaseElement> caseElemList = new List<CaseElement>();
		if (caseElement != null)
			caseElemList.Add((CaseElement)caseElement);
		return caseElemList;
	}

	private List<CaseElement> AddCaseElementToList(List<CaseElement> caseElemList, object caseElem, LexLocation location)
	{
		if (caseElemList == null || caseElem == null)
			return caseElemList;
		else if (! (caseElem is CaseElement))
			throw new STLangCompilerError("Type of parameter caseElem must be CaseElement");
		else {
			CaseElement caseElement = (CaseElement)caseElem;
			if (caseElement.LabelList != null)
				caseElemList.Add(caseElement);
			else {
				// caseElement is a default statment. Make sure that there isn't another 
				// default statement in the list.

				CaseElement defaultStat;
				defaultStat = caseElemList.Find(caseEl => caseEl.LabelList == null);
				if (defaultStat == null)
					caseElemList.Add(caseElement);
				else
					this.report.SemanticError(146, location);
			}
			return caseElemList;
		}
	}

	private List<CaseLabel> AddCaseLabelToList(List<CaseLabel> caseLabelList, CaseLabel caseLabel, LexLocation loc)
	{
		if (caseLabel == null)
			return caseLabelList;
		else if (caseLabel is NumericLabel)
		{
			NumericLabel numericLabel = (NumericLabel)caseLabel;
			foreach (CaseLabel thisCaseLabel in this.caseLabelList)
			{
				if (! thisCaseLabel.IsDisjoint(numericLabel))
				{
					int errorCode = thisCaseLabel is NumericLabel ? 33 : 53;
					this.report.SemanticError(errorCode, numericLabel.ToString(), thisCaseLabel.ToString(), loc);
					return caseLabelList;
				}
			}
			caseLabelList.Add(caseLabel);
			this.caseLabelList.Add(caseLabel);
			return caseLabelList;
		}
		else 
		{
			SubrangeLabel subRangeLabel = (SubrangeLabel)caseLabel;
			foreach (CaseLabel thisCaseLabel in this.caseLabelList)
			{
				if (! thisCaseLabel.IsDisjoint(subRangeLabel))
				{
					int errorCode = thisCaseLabel is NumericLabel ? 53 : 52;
					this.report.SemanticError(errorCode, thisCaseLabel.ToString(), subRangeLabel.ToString(), loc);
					return caseLabelList;
				}
			}
			caseLabelList.Add(caseLabel);
			this.caseLabelList.Add(caseLabel);
			return caseLabelList;
		}
	}

	private Expression CheckIfBoolCondition(string statement, Expression expression, LexLocation location)
	{
		if (expression == null)
			return Expression.Error;
		else if (expression.DataType == TypeNode.Error)
			return Expression.Error;
		else if (expression is FunctionName)
		{
			this.report.SemanticError(148, expression.ToString(), location);
			return Expression.Error;
		}
		else if (expression.DataType == TypeNode.Bool)
			return expression;
		else {
			this.report.SemanticError(34, statement, location);
			return Expression.Error;
		}
	}

	private Statement MakeWhileStatement(Expression expression, StatementList statementList, LexLocation location)
	{
		this.PopTop();
		this.loopNestingDepth--;
		if (expression == null || statementList == null)
			return Statement.Empty;
		else {
			if (expression.IsConstant)
			{
				bool conditonIsTrue = Convert.ToBoolean(expression.Evaluate());
				if (conditonIsTrue && !statementList.ContainsExit)
					this.report.SemanticError(92, location);
			}
			return new WhileStatement(expression.InvertRelation(), statementList);
		}
	}

	private Statement MakeRepeatStatement(StatementList statementList = null, Expression expression = null, LexLocation location = null)
	{
		this.PopTop();
		this.loopNestingDepth--;
		if (statementList == null || expression == null)
			return Statement.Empty;
		else {
			if (expression.IsConstant)
			{
				bool conditonIsFalse = !Convert.ToBoolean(expression.Evaluate());
				if (conditonIsFalse && !statementList.ContainsExit)
					this.report.SemanticError(93, location);
			}
			return new RepeatStatement(statementList, expression.InvertRelation());
		}
	}

	private List<object> MakeElseIfStatement(Expression expression, StatementList statementList)
	{
		this.PopTop();
		ElseIfStatement elseIfStat;
		elseIfStat = new ElseIfStatement(expression.InvertRelation(), statementList);
		return new List<object>{ elseIfStat };
	}

	private Statement MakeIfStatement(Expression condition, StatementList thenStat, List<object> objList, StatementList elseStat)
	{
		if (objList == null)
			return new IfStatement(condition.InvertRelation(), thenStat, elseStat);
		else {
			List<ElseIfStatement> elseIfStatList;
			elseIfStatList = objList.Cast<ElseIfStatement>().ToList();
			return new IfStatement(condition.InvertRelation(), thenStat, elseStat, elseIfStatList);
		}
	}

	private List<object> AddElseIfStatementToList(List<object> elseIfList, Expression expr, StatementList statList)
	{
		if (statList == null)
			return elseIfList;
		else {
			ElseIfStatement elseIfStat;
			elseIfStat = new ElseIfStatement(expr.InvertRelation(), statList);
			elseIfList.Add(elseIfStat);
			return elseIfList;
		}
	}

	private void InstallFunctionProtoType(string name, TypeNode resultDataType, POUVarDeclarations varDecls, LexLocation loc)
	{
		this.symbolTable.InstallFunctionProtoType(name, resultDataType, varDecls, loc);
	}

	private void InstallFunctionBlockProtoType(string name, POUVarDeclarations pouVarDecls, LexLocation loc)
	{
		uint byteCount;
		FunctionBlockType dataType;
		List<InstanceSymbol> members;
		List<InstanceSymbol> instanceSymbols;

		string typeID = "{" + name + "}";
        instanceSymbols = pouVarDecls.InputParameters.ToList();
        members = instanceSymbols.Cast<InstanceSymbol>().ToList();
		byteCount = (uint)this.rwMemoryManager.RWDataSegmentSize;
        Expression size = MakeIntConstant((long)byteCount);
		pouVarDecls.Size = size;
		dataType = new FunctionBlockType(name, members, byteCount, size, typeID);
		this.symbolTable.InstallFunctionBlockProtoType(name, dataType, pouVarDecls, loc);
	}

	private ExitStatement MakeExitStatement(LexLocation location)
	{
		if (this.loopNestingDepth == 0)
			this.report.SemanticError(21, location);
		return new ExitStatement();
	}

	private ReturnStatement MakeReturnStatement(LexLocation location)
	{
		if (this.isFunctionDecl)
			this.CheckFunctionValueIsDefined(location);
		return new ReturnStatement();
	}

	private ReturnStatement MakeReturnStatement2(LexLocation location)
	{
		this.report.SyntaxError(47, location);
		return new ReturnStatement();
	}

	private void PushForLoopData(Expression expression, ForLoopData forLoopData)
	{
		if (expression != null && forLoopData != null)
		{
			Predicate<ForLoopData> searchCond;
			MemoryObject memoryObj = (MemoryObject)expression;
			searchCond = forLoop => forLoop.ControlVariable.Symbol == memoryObj.Symbol;
			if (this.forLoopDataList.Find(searchCond) == null)
			{
				memoryObj.Symbol.IsForLoopCtrlVar = true;
				forLoopData.ControlVariable = memoryObj;
				this.forLoopDataList.Add(forLoopData);
			}
		}
	}

	private MemoryObject GenerateTemporary(Expression expr)
    {
        return this.rwMemoryManager.GenerateTemporary(expr);
    }

    private MemoryObject GenerateTemporary(TypeNode dataType)
    {
        return this.rwMemoryManager.GenerateTemporary(dataType);
    }

	private Statement MakeForLoopStatement(Expression controlVar, ForLoopData forLoop, StatementList statList)
	{
		this.PopTop();
		this.loopNestingDepth--;
		this.PopForLoopVariables();
		if (controlVar == null || forLoop == null)
			return Statement.Empty;
		else {
			Expression initValue = forLoop.InitialValue;
			Expression stopValue = forLoop.StopValue;
			Expression increment = forLoop.Increment;

			if (initValue == null || stopValue == null || increment == null)
				return Statement.Empty;
			else {
				Expression condition;
				bool executeLoopOnce = false;

				if (increment.IsConstant)
				{
					if (stopValue.IsCompoundExpression)
					{
						MemoryObject temporary = this.GenerateTemporary(controlVar);
						int incr = Convert.ToInt32(increment.Evaluate());
						if (incr > 0)
							condition = new IntLeqOperator(controlVar, temporary);
						else 
							condition = new IntGeqOperator(controlVar, temporary);
						return new ForStatement((MemoryObject)controlVar, initValue, stopValue, temporary, condition, increment, statList);
					}
					else {
						int incrValue = Convert.ToInt32(increment.Evaluate());
						if (incrValue > 0)
							condition = new IntLeqOperator(controlVar, stopValue);
						else 
							condition = new IntGeqOperator(controlVar, stopValue);
						if (initValue.IsConstant && stopValue.IsConstant)
						{
							int initVal = Convert.ToInt32(initValue.Evaluate());
							int stopVal = Convert.ToInt32(stopValue.Evaluate());
							if (incrValue > 0)
								executeLoopOnce = initVal <= stopVal;
							else 
								executeLoopOnce = initVal >= stopVal;
						}
					}
				}
				else if (initValue.IsConstant && stopValue.IsConstant)
				{
					int initVal = Convert.ToInt32(initValue.Evaluate());
					int stopVal = Convert.ToInt32(stopValue.Evaluate());
					if (initVal <= stopVal)
					{
						condition = new IntLeqOperator(controlVar, stopValue);
						executeLoopOnce = initVal <= stopVal;
					}
					else {
						condition = new IntGeqOperator(controlVar, stopValue);
						executeLoopOnce = initVal >= stopVal;
					}
				}
				else if (! stopValue.IsCompoundExpression)
					condition = new IntLeqOperator(controlVar, stopValue);
				else {
					MemoryObject temporary;
					temporary = this.GenerateTemporary(controlVar);
					condition = new IntLeqOperator(controlVar, temporary);
					return new ForStatement((MemoryObject)controlVar, initValue, stopValue, temporary, condition, increment, statList);
				} 
				return new ForStatement((MemoryObject)controlVar, initValue, condition, increment, statList, executeLoopOnce);
			}
		}
	}

	private Statement MakeCaseStatement(Expression controlExpr, List<CaseElement> caseElemList, LexLocation location)
	{
		this.PopCaseLabelList();
		if (caseElemList.Count == 0)
		{
			this.report.Warning(26, location);
			return Statement.Empty;
		}
		else {
			CaseElement defaultStatement;
			
			defaultStatement = caseElemList.Find(caseElem => caseElem.LabelList == null);
			if (defaultStatement == null)
				return new CaseStatement(controlExpr, caseElemList);
			else {
				caseElemList.Remove(defaultStatement);
				if (caseElemList.Count == 0)
					this.report.Warning(27, location);
				return new CaseStatement(controlExpr, caseElemList, defaultStatement);
			}
		}
	}

	private ForLoopData MakeForLoopData(Expression initialValue, Expression stopValue, Expression increment, LexLocation loc1 = null, LexLocation loc2 = null, LexLocation loc3 = null)
	{
		ForLoopData forLoopData = new ForLoopData();
		if (initialValue == null)
			initialValue = MakeIntConstant((long)0);
		else if (initialValue is FunctionName)
		{
			this.report.SemanticError(148, initialValue.ToString(), loc1);
			initialValue = MakeIntConstant((long)0);
		}
		if (stopValue == null)
			stopValue = Expression.Error;
		else if (stopValue is FunctionName)
		{
			this.report.SemanticError(148, stopValue.ToString(), loc2);
			stopValue = Expression.Error;
		}
		if (increment == null)
			increment = MakeIntConstant((long)1);
		else if (increment is FunctionName)
		{
			this.report.SemanticError(148, increment.ToString(), loc3);
			increment = MakeIntConstant((long)1);
		}
		forLoopData.InitialValue = initialValue;
		forLoopData.StopValue = stopValue;
		forLoopData.Increment = increment;
		this.forLoopVarKind = 0x0;
		this.loopNestingDepth++;
		return forLoopData;
	}

	private Expression SaveControlVariable(Expression expr, LexLocation location)
	{
		if (expr == null)
			return Expression.Error;
		else if (expr is FunctionName)
		{
			this.report.SemanticError(148, expr.ToString(), location);
			return Expression.Error;
		}
		else if (! expr.IsLValue)
		{
			// Error: expr is not an L-Value
			this.report.SemanticError(54, expr.ToString(), location);
			return Expression.Error;
		}
		else {
			TypeNode dataType = expr.DataType;
			MemoryObject variable = (MemoryObject)expr;
			InstanceSymbol varSymbol = variable.Symbol;
			if (variable.IsConstant)
				this.report.SemanticError(8, expr.ToString(), location);
			if ((dataType.IsSignedIntType || dataType == TypeNode.Error) && variable.IsSimpleVariable)
				this.RegisterForLoopVariable(varSymbol, ForLoopVariableType.CONTROL_VARIABLE, location);
			else {
				if (! variable.IsSimpleVariable)
					this.report.SemanticError(49, varSymbol.Name, location); // Control variable can't be an element of an array or struct
				if (! dataType.IsSignedIntType && dataType != TypeNode.Error)
					this.report.SemanticError(132, varSymbol.Name, location); // Control variable must be of a signed integer type
			}
			return expr;
		}
	}

	private void CheckIfForLoopVar(Expression expr, LexLocation location)
	{
		if (expr == null)
			return;
		else if (expr is MemoryObject && this.forLoopVarKind != 0)
		{
			ForLoopVariableType loopVarKind;
			MemoryObject memObject = (MemoryObject)expr;

			if (this.forLoopVarKind == 0x1)
				loopVarKind = ForLoopVariableType.CONTROL_VARIABLE;
			else if (this.forLoopVarKind == 0x2)
				loopVarKind = ForLoopVariableType.START_VARIABLE;
			else if (this.forLoopVarKind == 0x4)
				loopVarKind = ForLoopVariableType.STOP_VARIABLE;
			else if (this.forLoopVarKind == 0x8)
				loopVarKind = ForLoopVariableType.INCR_VARIABLE;
			else
				loopVarKind = ForLoopVariableType.NONE;
			this.RegisterForLoopVariable(memObject.Symbol, loopVarKind, location);
		}
	}

	private bool ConversionOperatorExists(TypeNode fromType, TypeNode toType)
	{
		if (fromType == TypeNode.Error || toType == TypeNode.Error)
			return false;
		else if (!fromType.IsElementaryType || !toType.IsElementaryType)
			return false;
		else if (fromType.IsSubrangeType || toType.IsSubrangeType)
			return true;
		else {
			STLangSymbol symbol;
			string conversionOp;

			conversionOp = string.Format("{0}_TO_{1}", fromType.Name, toType.Name);
			return this.symbolTable.Lookup(conversionOp, out symbol, null);
		}
	}

	private Statement MakeAssignmentStatement(STLangSymbol lSymbol, STLangSymbol rSymbol, Expression lIndex = null, Expression rIndex = null)
	{
		TypeNode dataType = lSymbol.DataType;
		if (dataType.IsStructType)
		{
			if (! lSymbol.IsStructInstance || ! rSymbol.IsStructInstance)
				throw new STLangCompilerError(Resources.MAKEASSGNSTAT1);
			else {
				Statement assignmentStat;
				CompoundAssignmentStat compoundAssignStat;		
				StructInstanceSymbol lStruct = (StructInstanceSymbol)lSymbol;
				StructInstanceSymbol rStruct = (StructInstanceSymbol)rSymbol;
				InstanceSymbol lMember = lStruct.FirstMember;
				InstanceSymbol rMember = rStruct.FirstMember;

				compoundAssignStat = new CompoundAssignmentStat();
				while (lMember != null && rMember != null)
				{
					assignmentStat = this.MakeAssignmentStatement(lMember, rMember, lIndex, rIndex);
					compoundAssignStat.Add(assignmentStat);
					lMember = lMember.Next;
					rMember = rMember.Next;
				}
				return compoundAssignStat;
			}
		}
		else if (dataType.IsArrayType)
		{
			if (! lSymbol.IsArrayInstance || ! rSymbol.IsArrayInstance)
				throw new STLangCompilerError(Resources.MAKEASSGNSTAT2);
			else {
				ArrayType array = (ArrayType)dataType;
				TypeNode elementType = array.BasicElementType;

				if (elementType.IsStructType || elementType.IsArrayType)
				{
					ArrayInstanceSymbol lArray = (ArrayInstanceSymbol)lSymbol;
					ArrayInstanceSymbol rArray = (ArrayInstanceSymbol)rSymbol;
					STLangSymbol lElement = lArray.ElementSymbol;
					STLangSymbol rElement = rArray.ElementSymbol;
					return this.MakeAssignmentStatement(lElement, rElement, lIndex, rIndex);
				}
				else {
					long sizeOfDataType = dataType.Size;
					Expression size = MakeIntConstant(sizeOfDataType);
					this.rwMemoryManager.SetAbsoluteAddress(lSymbol);
					this.rwMemoryManager.SetAbsoluteAddress(rSymbol);
					Expression lValue = lSymbol.MakeSyntaxTreeNode();
					Expression rValue = rSymbol.MakeSyntaxTreeNode();
					((MemoryObject)lValue).Location.Size = size;
					((MemoryObject)rValue).Location.Size = size;
					return new SimpleAssignmentStat(lValue, rValue);
				}
			}
		}
		else if (dataType.IsElementaryType || dataType.IsAnyStringType)
		{
	        // Obs! Om man allokerar mer minne fÃ¶r att spara undan vÃ¤rdet av ett 
		    // deluttryck efter ett anrop av SetAbsoluteAddress() kan absolutad- 
            // ressen bli fel. Man borde egentligen spara undan lSymbol och rSymbol
            // i en lista fÃ¶r att senare fylla i absolutadressen.

			int elementCount = lSymbol.Location.ElementCount;
			Expression lValue = lSymbol.MakeSyntaxTreeNode();
			Expression rValue = rSymbol.MakeSyntaxTreeNode();
			if (elementCount > 1)
			{ 
				// Array assignment

				long sizeOfDataType = lSymbol.DataType.Size * elementCount;
				Expression size = MakeIntConstant(sizeOfDataType);
				this.rwMemoryManager.SetAbsoluteAddress(lSymbol);
				this.rwMemoryManager.SetAbsoluteAddress(rSymbol);
				((MemoryObject)lValue).Location.Size = size;
				((MemoryObject)rValue).Location.Size = size;
			}
			return new SimpleAssignmentStat(lValue, rValue);
		}
		return Statement.Empty;
	}

	private Statement MakeAssignmentStatement(Expression lExpression, Expression rValue, LexLocation location)
	{
		if (lExpression == null || rValue == null)
			return Statement.Empty;
		else if (lExpression == Expression.Error)
			return Statement.Empty;
		else if (rValue is FunctionName)
		{
			this.report.SemanticError(148, rValue.ToString(), location);
			return Statement.Empty;
		}
		else if (lExpression is FunctionName)
		{
			TypeNode rValueDataType = rValue.DataType;
			TypeNode resultType = lExpression.DataType;
			if (rValue.DataType == TypeNode.Bool && rValue.IsCompoundExpression)
				rValue = new LoadBoolValueOperator(rValue);
			if (! this.symbolTable.IsCurrentFunction(lExpression))
			{
				this.report.SemanticError(149, lExpression.ToString(), location);
				return Statement.Empty;
			}
			else if (resultType == TypeNode.Error || rValueDataType == TypeNode.Error)
				return new FunctionResultStatement(Expression.Error);
			else if (resultType == rValueDataType)
				return new FunctionResultStatement(rValue);
			else if (resultType.IsIntegerType && rValueDataType.IsIntegerType)
			{
				if (rValueDataType.Size <= resultType.Size)
					return new FunctionResultStatement(rValue);
			}
			else if (resultType.IsBitStringType)
			{
				if (rValueDataType.IsBitStringType)
				{
					if (rValueDataType.Size <= resultType.Size)
						return new FunctionResultStatement(rValue);
				}
				else if (rValueDataType.IsIntegerType)
				{
					if (rValue.IsConstant && rValueDataType.Size <= resultType.Size)
						return new FunctionResultStatement(rValue);
				}
			}
			else if (resultType == TypeNode.Real)
			{
				if (rValueDataType.IsIntegerType)
				{
					if (! rValue.IsConstant)
						rValue = this.MakeInt2Real(rValue); // Insert conversion operator
					else {
						// Convert constant value from integer to float
						float floatValue = Convert.ToSingle(rValue.Evaluate());
						rValue = MakeConstant(floatValue);
					}
					return new FunctionResultStatement(rValue);
				}
			}
			else if (resultType == TypeNode.LReal)
			{
				if (rValueDataType.IsIntegerType)
				{
					if (! rValue.IsConstant)
						rValue = new Int2LRealOperator(rValue); // Insert conversion operator
					else {
						// Convert constant value from integer to double
						double doubleValue = Convert.ToDouble(rValue.Evaluate());
						rValue = MakeConstant(doubleValue);
					}
					return new FunctionResultStatement(rValue);
				}
				else if (rValueDataType == TypeNode.Real)
				{
					if (! rValue.IsConstant)
						rValue = new Real2LRealOperator(rValue);
					else {
						double doubleValue = Convert.ToDouble(rValue.Evaluate());
						rValue = MakeConstant(doubleValue);
					}
					return new FunctionResultStatement(rValue);
				}
			}
			if (this.ConversionOperatorExists(rValueDataType, resultType))
				this.report.SemanticError(64, rValueDataType.Name, resultType.Name, location);
			else
				this.report.SemanticError(150, rValueDataType.Name, resultType.Name, location);
			return Statement.Empty;
		}
		else if (! lExpression.IsLValue)
		{
			this.report.SemanticError(54, lExpression.ToString(), location);
			return Statement.Empty;
		}
		else {
			TypeNode rValueDataType = rValue.DataType;
			TypeNode lValueDataType = lExpression.DataType;
			MemoryObject lmemObject = (MemoryObject)lExpression;
			InstanceSymbol symbol = lmemObject.Symbol;
			foreach (Hashtable forLoopVars in this.forLoopVarTable)
			{
				if (forLoopVars.Contains(symbol))
				{
					ForLoopVariableType forLoopVarType;
					forLoopVarType = (ForLoopVariableType)forLoopVars[symbol];
					if ((forLoopVarType & ForLoopVariableType.CONTROL_VARIABLE) != 0)
						this.report.SemanticError(125, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.START_VARIABLE) != 0)
						this.report.SemanticError(126, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.STOP_VARIABLE) != 0)
						this.report.SemanticError(127, symbol.Name, location);
					if ((forLoopVarType & ForLoopVariableType.INCR_VARIABLE) != 0)
						this.report.Warning(15, symbol.Name, location);
				}
			}
			if (rValue.DataType == TypeNode.Bool && rValue.IsCompoundExpression)
				rValue = new LoadBoolValueOperator(rValue);
			if (lExpression.IsConstant)
			{
				if (lmemObject.IsSimpleVariable)
					this.report.SemanticError(169, lExpression.ToString(), location);
				else
					this.report.SemanticError(170, lExpression.ToString(), location);
			}
			else if (lExpression.IsConstantLValue)
			{
				if (lmemObject.IsSimpleVariable)
					this.report.SemanticError(168, lExpression.ToString(), location);
				else
					this.report.SemanticError(170, lExpression.ToString(), location);
			}
			if (lValueDataType == rValueDataType)
			{
				if (rValueDataType.IsStructType)
				{
					MemoryObject rmemObject = (MemoryObject)rValue;
					STLangSymbol lSymbol = lmemObject.Symbol;
					STLangSymbol rSymbol = rmemObject.Symbol;
					return this.MakeAssignmentStatement(lSymbol, rSymbol);
				}
     			else if (rValueDataType.IsArrayType)
				{
					MemoryObject rmemObject = (MemoryObject)rValue;
					STLangSymbol lSymbol = lmemObject.Symbol;
					STLangSymbol rSymbol = rmemObject.Symbol;
					Expression lIndex = lmemObject.Offset;
					Expression rIndex = rmemObject.Offset;
					return this.MakeAssignmentStatement(lSymbol, rSymbol, lIndex, rIndex);
				}
				else if (lValueDataType.IsOrdinalType && lValueDataType.IsSubrangeType)
				{
					if (rValue.IsConstant)
					{
						if (lValueDataType.IsSignedIntType)
						{
							long numericValue = Convert.ToInt64(rValue.Evaluate());
							if (! lValueDataType.IsInRange(numericValue))
							{
								string strValue = rValue.ToString();
								string typeName = lValueDataType.Name;
								this.report.SemanticError(171, strValue, typeName, location);
							}
						}
						else {
							ulong numericValue = Convert.ToUInt64(rValue.Evaluate());
							if (! lValueDataType.IsInRange(numericValue))
							{
								string strValue = rValue.ToString();
								string typeName = lValueDataType.Name;
								this.report.SemanticError(171, strValue, typeName, location);
							}
						}
					}
					else if (rValueDataType.IsSubrangeType)
					{
						SubRange rValueSubrange = rValueDataType.GetSubrange();
						SubRange lValueSubrange = lValueDataType.GetSubrange();
						if (lValueSubrange.IsDisjoint(rValueSubrange))
						{
							string lValName = lValueDataType.Name;
							string rValName = rValueDataType.Name;
							this.report.SemanticError(11, lValName, rValName, location);
						}
					}
				}
				return new SimpleAssignmentStat(lExpression, rValue);
			}
			else if (lValueDataType == TypeNode.Error || rValueDataType == TypeNode.Error)
				return new SimpleAssignmentStat(lExpression, rValue);
			else if (lValueDataType.IsIntegerType && rValueDataType.IsIntegerType)
			{
				if (rValueDataType.Size <= lValueDataType.Size)
					return new SimpleAssignmentStat(lExpression, rValue);
			}
			else if (lValueDataType.IsBitStringType)
			{
				if (rValueDataType.IsBitStringType)
				{
					if (rValueDataType.Size <= lValueDataType.Size)
						return new SimpleAssignmentStat(lExpression, rValue);
				}
				else if (rValueDataType.IsIntegerType)
				{
					if (rValue.IsConstant && rValueDataType.Size <= lValueDataType.Size)
						return new SimpleAssignmentStat(lExpression, rValue);
				}
			}
			else if (lValueDataType == TypeNode.Real)
			{
				if (rValueDataType.IsIntegerType)
				{
					if (! rValue.IsConstant)
						rValue = this.MakeInt2Real(rValue); // Insert conversion operator
					else {
						// Convert constant value from integer to float
						float floatValue = Convert.ToSingle(rValue.Evaluate());
						rValue = MakeConstant(floatValue);
					}
					return new SimpleAssignmentStat(lExpression, rValue);
				}
			}
			else if (lValueDataType == TypeNode.LReal)
			{
				if (rValueDataType.IsIntegerType)
				{
					if (! rValue.IsConstant)
						rValue = new Int2LRealOperator(rValue); // Insert conversion operator
					else {
						// Convert constant value from integer to double
						double doubleValue = Convert.ToDouble(rValue.Evaluate());
						rValue = MakeConstant(doubleValue);
					}
					return new SimpleAssignmentStat(lExpression, rValue);
				}
				else if (rValueDataType == TypeNode.Real)
				{
					if (! rValue.IsConstant)
						rValue = new Real2LRealOperator(rValue);
					else {
						double doubleValue = Convert.ToDouble(rValue.Evaluate());
						rValue = MakeConstant(doubleValue);
					}
					return new SimpleAssignmentStat(lExpression, rValue);
				}
			}
			else if (lValueDataType.IsStringType && rValueDataType.IsStringType)
			{
				if (lValueDataType.Size >= rValueDataType.Size)
					return new SimpleAssignmentStat(lExpression, rValue);
				else {
					this.report.SemanticError(188, rValue.ToString(), lExpression.ToString(), location);
					return Statement.Empty;
				}
			}
			else if (lValueDataType.IsWStringType && rValueDataType.IsWStringType)
			{
				if (lValueDataType.Size >= rValueDataType.Size)
					return new SimpleAssignmentStat(lExpression, rValue);
				else {
					this.report.SemanticError(188, rValue.ToString(), lExpression.ToString(), location);
					return Statement.Empty;
				}
			}
			if (this.ConversionOperatorExists(rValueDataType, lValueDataType))
				this.report.SemanticError(64, rValueDataType.Name, lValueDataType.Name, location);
			else
				this.report.SemanticError(150, rValueDataType.Name, lValueDataType.Name, location);
			return Statement.Empty;
		}
	}

	private StatementList MakeStatementList(Statement statement)
	{
		StatementList statementList = new StatementList();
		if (statement != null && statement != Statement.Empty)
		{
			statementList.Add(statement);
			this.CopyValue(statement.IsFunctionValueDefined);
		}
		return statementList;
	}

	private StatementList AddToStatementList(StatementList statementList, Statement statement, LexLocation location)
	{
		if (statementList != null && statement != null)
		{
			if (statement == Statement.Empty)
				return statementList;
			else if (statementList.Count > 0 && statementList.Last.ControlFlowTerminates)
				this.report.Warning(2, location);
			else {
				statementList.Add(statement);
				this.CopyValue(statement.IsFunctionValueDefined);
			}
		}
		return statementList;
	}

	private StatementList MakeCaseStatList(Statement statement)
	{
		StatementList statementList = new StatementList();
		if (statement != null && statement != Statement.Empty)
		{
			statementList.Add(statement);
			this.CopyValue(statement.IsFunctionValueDefined);
		}
		this.CheckForEndOfCaseStatList();
		return statementList;
	}

	private StatementList AddToCaseStatList(StatementList statementList, Statement statement, LexLocation location)
	{
		if (statementList != null && statement != null)
		{
			if (statement == Statement.Empty)
				return statementList;
			else if (statementList.Count > 0 && statementList.ControlFlowTerminates)
				this.report.Warning(2, location);
			else {
				statementList.Add(statement);
				this.CopyValue(statement.IsFunctionValueDefined);
			}
		}
		this.CheckForEndOfCaseStatList();
		return statementList;
	}

	private void CheckForEndOfCaseStatList()
	{
		STLangScanner scanner = (STLangScanner)this.Scanner;
		Tokens token = scanner.GetNextToken();
		switch (token)
		{
		case Tokens.IF:
		case Tokens.ELSE:
		case Tokens.WHILE:
		case Tokens.FOR:
		case Tokens.RETURN:
		case Tokens.REPEAT:
		case Tokens.CASE:
		case Tokens.EXIT:
		case Tokens.END_CASE:
			// Control flow statement. 
			scanner.DoPushBack(false); 
		    break;

        case Tokens.TRUE:           
		case Tokens.FALSE:        
		case Tokens.INT_LIT:      
		case Tokens.REAL_LIT:     
		case Tokens.TOD_LIT:      
		case Tokens.TIME_LIT:     
		case Tokens.DATE_LIT:     
		case Tokens.DT_LIT:        
		case Tokens.STRING_LIT:        
		case Tokens.WSTRING_LIT:     
		case Tokens.TYPED_INT:       
		case Tokens.TYPED_REAL:   
		case Tokens.TYPED_ENUM:
		    // Constant ==> End of statement.
			scanner.DoPushBack(true);
			break;

		case Tokens.IDENT:
			token = scanner.GetNextToken();
			if (token == Tokens.ASSIGN)
				scanner.DoPushBack(false);
			else if (token == Tokens.DOTDOT || (char)token == ',' || (char)token == ':')
				scanner.DoPushBack(true);
			else if ((char)token != '(')
				scanner.DoPushBack(false);
			else {
				// Determine whether it is a function call or function block call
				STLangSymbol symbol;
				string ident = scanner.GetBufferedValue(0).Ident;

				if (! this.symbolTable.Lookup(ident, out symbol, null))
					scanner.DoPushBack(false);
				else if (symbol.IsFunctionBlock)
					scanner.DoPushBack(false); // Statement
				else
					scanner.DoPushBack(true);  // Expression
			}
			break;

		default:
			scanner.DoPushBack(true);
			break;
        }
	}

	private void PushSymbolTable(int declarationType = -1)
	{
		if (declarationType == 0)
			this.isFunctionDecl = true;
		else if (declarationType == 1)
			this.isFunctionBlockDecl = true;
		else if (declarationType == 2)
			this.isProgramDecl = true;
		this.symbolTable.Push();
	}

	private void PopSymbolTable()
	{
		this.symbolTable.Pop();
	}

	private void StoreInputOutputData(POUVarDeclarations pouDeclarations)
	{
		IEnumerable<InstanceSymbol> inputs = pouDeclarations.InputParameters;
		IEnumerable<InstanceSymbol> outputs = pouDeclarations.OutputParameters;
		IEnumerable<InstanceSymbol> retainedVars = pouDeclarations.RetainedVariables;

		foreach (InstanceSymbol input in inputs)
			ByteCodeGenerator.StoreInputParameter(input.Name, input.Position);
		foreach (InstanceSymbol output in outputs)
			ByteCodeGenerator.StoreOutputParameter(output.Name, output.Location.Index);
		foreach (InstanceSymbol retainedVar in retainedVars)
			ByteCodeGenerator.StoreRetainedVariable(retainedVar.Name, retainedVar.Location.Index);
		ByteCodeGenerator.StoreIOParameterCount();
	}

	// void GenerateInitInputs(POUVarDeclarations pouDeclarations)
	//
	// Generates code that initializes input parameters (VAR_INPUT).
	//
	private void GenerateInitInputs(POUVarDeclarations pouDeclarations)
	{
		Expression inputParam;
		IEnumerable<InstanceSymbol> inputs;

		inputs = pouDeclarations.InputParameters.Reverse();
		foreach (InstanceSymbol input in inputs)
		{
			inputParam = input.MakeSyntaxTreeNode(null);
			inputParam.GenerateStore();
		}
	}

	// void GenerateInitLocalVars(POUVarDeclarations pouDeclarations)
	//
	// Generates code that initializes local variables (VAR, VAR_TEMP (and VAR_OUTPUT in functions).
	//
	private void GenerateInitLocalVars(POUVarDeclarations pouDeclaration, bool isFunction)
    {
		IEnumerable<DeclarationStatement> localVariables;
		if (isFunction)
		{
			localVariables = pouDeclaration.LocalVariables;
			foreach (DeclarationStatement localVariable in localVariables)
			{
				localVariable.GenerateCode();
			}
		}
		else {
		}
	}

	private void GenerateStatementList(StatementList statementList)
	{
		if (statementList == null)
			throw new STLangCompilerError(Resources.GENFCNBODY);
		else
			statementList.GenerateCode();
	}

    string GetBaseName(string sourceFileName)
    {
        char[] separators = new char[] { '.' };
        string[] result = sourceFileName.Split(separators);
        if (result.Length > 0)
            return result[0];
        else
            return "";
    }

    private void GenerateObjectCode(string path, string sourceFile)
    {
		string executableFile;
		POUVarDeclarations varDeclarations;
		RWMemoryLayoutManager rwMemoryManager;
		ROMemoryLayoutManager roMemoryManager;
		IEnumerable<ProgramOrganizationUnitSymbol> pouSymbols;

		roMemoryManager = new ROMemoryLayoutManager();
		GenericConstant.ConstMemoryManager = roMemoryManager;
		pouSymbols = this.symbolTable.ProgramOrganizationUnits;
		executableFile = this.GetBaseName(sourceFile) + ".xstl";
		foreach (ProgramOrganizationUnitSymbol pouSymbol in pouSymbols)
		{
			foreach (ProgramOrganizationUnit pou in pouSymbol.Definitions)
			{
				varDeclarations = pou.VarDeclarations;
				rwMemoryManager = pou.RWMemoryLayout;
				constantTable = pou.ConstantTable;
				this.StoreInputOutputData(varDeclarations);
				this.GenerateInitInputs(varDeclarations);
                this.GenerateInitLocalVars(varDeclarations, pouSymbol.IsFunction);
                this.GenerateStatementList(pou.Body);
				ByteCodeGenerator.StorePOUName(pou.Name);
				ByteCodeGenerator.StorePOUType(pou.POUType);
				ByteCodeGenerator.StoreRWDataSegmentInfo(rwMemoryManager);
				ByteCodeGenerator.StoreConstantTable(constantTable);
				ByteCodeGenerator.StoreRODataSegmentInfo(roMemoryManager);
				ByteCodeGenerator.OptimizeByteCode();
				ByteCodeGenerator.CreateExecutable(path, executableFile);
				roMemoryManager.Reset();
			}
		}
    }

	internal STLangPOUObject GenerateObjectCode(bool overWrite)
    {
		STLangPOUObject pouObject;
		POUVarDeclarations varDeclarations;
		RWMemoryLayoutManager rwMemoryManager;
		ROMemoryLayoutManager roMemoryManager;
		IEnumerable<ProgramOrganizationUnitSymbol> pouSymbolList;
		List<STLangPOUObject> pouObjectList = new List<STLangPOUObject>();

		roMemoryManager = new ROMemoryLayoutManager();
		GenericConstant.ConstMemoryManager = roMemoryManager;
		pouSymbolList = this.symbolTable.ProgramOrganizationUnits;
		foreach (ProgramOrganizationUnitSymbol pouSymbol in pouSymbolList)
		{
			foreach (ProgramOrganizationUnit pou in pouSymbol.Definitions)
			{
				rwMemoryManager = pou.RWMemoryLayout;
				varDeclarations = pou.VarDeclarations;
				constantTable = pou.ConstantTable;
				this.StoreInputOutputData(varDeclarations);
				this.GenerateInitInputs(varDeclarations);
                this.GenerateInitLocalVars(varDeclarations, pouSymbol.IsFunction);
                this.GenerateStatementList(pou.Body);
				ByteCodeGenerator.StorePOUName(pou.Name);
				ByteCodeGenerator.StorePOUType(pou.POUType);
				ByteCodeGenerator.StoreRWDataSegmentInfo(rwMemoryManager);
				ByteCodeGenerator.StoreConstantTable(constantTable);
				ByteCodeGenerator.StoreRODataSegmentInfo(roMemoryManager);
				ByteCodeGenerator.OptimizeByteCode();
				pouObject = ByteCodeGenerator.CreateExecutable(pou.Name, overWrite);
				pouObjectList.Add(pouObject);
				roMemoryManager.Reset();
			}
		}
		return pouObjectList[0];
    }

	public bool Parse(string path, string sourceFile)
	{
		this.ReInitializeParser();
		bool result = this.Parse();
		if (!result || this.Errors > 0)
			return false;
		else {
			this.GenerateObjectCode(path, sourceFile);
			return true;
		}
	}
}
}
